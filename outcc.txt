     1	// Copyright 2020 Mobvoi Inc. All Rights Reserved.
     2	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
     3	//         di.wu@mobvoi.com (Di Wu)
     4	
     5	#include <iomanip>
     6	#include <utility>
     7	
     8	#include "torch/script.h"
     9	
    10	#include "decoder/params.h"
    11	#include "frontend/wav.h"
    12	#include "utils/flags.h"
    13	#include "utils/log.h"
    14	#include "utils/string.h"
    15	#include "utils/timer.h"
    16	#include "utils/utils.h"
    17	
    18	DEFINE_bool(simulate_streaming, false, "simulate streaming input");
    19	DEFINE_bool(output_nbest, false, "output n-best of decode result");
    20	DEFINE_string(wav_path, "", "single wave path");
    21	DEFINE_string(wav_scp, "", "input wav scp");
    22	DEFINE_string(result, "", "result output file");
    23	
    24	int main(int argc, char *argv[]) {
    25	  gflags::ParseCommandLineFlags(&argc, &argv, false);
    26	  google::InitGoogleLogging(argv[0]);
    27	
    28	  auto decode_config = wenet::InitDecodeOptionsFromFlags();
    29	  auto feature_config = wenet::InitFeaturePipelineConfigFromFlags();
    30	  auto decode_resource = wenet::InitDecodeResourceFromFlags();
    31	
    32	  if (FLAGS_wav_path.empty() && FLAGS_wav_scp.empty()) {
    33	    LOG(FATAL) << "Please provide the wave path or the wav scp.";
    34	  }
    35	  std::vector<std::pair<std::string, std::string>> waves;
    36	  if (!FLAGS_wav_path.empty()) {
    37	    waves.emplace_back(make_pair("test", FLAGS_wav_path));
    38	  } else {
    39	    std::ifstream wav_scp(FLAGS_wav_scp);
    40	    std::string line;
    41	    while (getline(wav_scp, line)) {
    42	      std::vector<std::string> strs;
    43	      wenet::SplitString(line, &strs);
    44	      CHECK_GE(strs.size(), 2);
    45	      waves.emplace_back(make_pair(strs[0], strs[1]));
    46	    }
    47	  }
    48	
    49	  std::ofstream result;
    50	  if (!FLAGS_result.empty()) {
    51	    result.open(FLAGS_result, std::ios::out);
    52	  }
    53	  std::ostream &buffer = FLAGS_result.empty() ? std::cout : result;
    54	
    55	  int total_waves_dur = 0;
    56	  int total_decode_time = 0;
    57	  for (auto &wav : waves) {
    58	    wenet::WavReader wav_reader(wav.second);
    59	    CHECK_EQ(wav_reader.sample_rate(), FLAGS_sample_rate);
    60	
    61	    auto feature_pipeline =
    62	        std::make_shared<wenet::FeaturePipeline>(*feature_config);
    63	    feature_pipeline->AcceptWaveform(std::vector<float>(
    64	        wav_reader.data(), wav_reader.data() + wav_reader.num_sample()));
    65	    feature_pipeline->set_input_finished();
    66	    LOG(INFO) << "num frames " << feature_pipeline->num_frames();
    67	
    68	    wenet::TorchAsrDecoder decoder(feature_pipeline, decode_resource,
    69	                                   *decode_config);
    70	
    71	    int wave_dur =
    72	        static_cast<int>(static_cast<float>(wav_reader.num_sample()) /
    73	                         wav_reader.sample_rate() * 1000);
    74	    int decode_time = 0;
    75	    while (true) {
    76	      wenet::Timer timer;
    77	      wenet::DecodeState state = decoder.Decode();
    78	      if (state == wenet::DecodeState::kEndFeats) {
    79	        decoder.Rescoring();
    80	      }
    81	      int chunk_decode_time = timer.Elapsed();
    82	      decode_time += chunk_decode_time;
    83	      if (decoder.DecodedSomething()) {
    84	        LOG(INFO) << "Partial result: " << decoder.result()[0].sentence;
    85	      }
    86	
    87	      if (state == wenet::DecodeState::kEndFeats) {
    88	        break;
    89	      } else if (FLAGS_chunk_size > 0 && FLAGS_simulate_streaming) {
    90	        float frame_shift_in_ms =
    91	            static_cast<float>(feature_config->frame_shift) /
    92	            wav_reader.sample_rate() * 1000;
    93	        auto wait_time =
    94	            decoder.num_frames_in_current_chunk() * frame_shift_in_ms -
    95	            chunk_decode_time;
    96	        if (wait_time > 0) {
    97	          LOG(INFO) << "Simulate streaming, waiting for " << wait_time << "ms";
    98	          std::this_thread::sleep_for(
    99	              std::chrono::milliseconds(static_cast<int>(wait_time)));
   100	        }
   101	      }
   102	    }
   103	    std::string final_result;
   104	    if (decoder.DecodedSomething()) {
   105	      final_result = decoder.result()[0].sentence;
   106	    }
   107	    LOG(INFO) << wav.first << " Final result: " << final_result << std::endl;
   108	    LOG(INFO) << "Decoded " << wave_dur << "ms audio taken " << decode_time
   109	              << "ms.";
   110	
   111	    if (!FLAGS_output_nbest) {
   112	      buffer << wav.first << " " << final_result << std::endl;
   113	    } else {
   114	      buffer << "wav " << wav.first << std::endl;
   115	      auto &results = decoder.result();
   116	      for (auto &r : results) {
   117	        if (r.sentence.empty())
   118	          continue;
   119	        buffer << "candidate " << r.score << " " << r.sentence << std::endl;
   120	      }
   121	    }
   122	
   123	    total_waves_dur += wave_dur;
   124	    total_decode_time += decode_time;
   125	  }
   126	  LOG(INFO) << "Total: decoded " << total_waves_dur << "ms audio taken "
   127	            << total_decode_time << "ms.";
   128	  LOG(INFO) << "RTF: " << std::setprecision(4)
   129	            << static_cast<float>(total_decode_time) / total_waves_dur;
   130	  return 0;
   131	}
   132	// Copyright (c) 2021 Ximalaya Speech Team (Xiang Lyu)
   133	//
   134	// Licensed under the Apache License, Version 2.0 (the "License");
   135	// you may not use this file except in compliance with the License.
   136	// You may obtain a copy of the License at
   137	//
   138	//   http://www.apache.org/licenses/LICENSE-2.0
   139	//
   140	// Unless required by applicable law or agreed to in writing, software
   141	// distributed under the License is distributed on an "AS IS" BASIS,
   142	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   143	// See the License for the specific language governing permissions and
   144	// limitations under the License.
   145	
   146	#include "frontend/wav.h"
   147	#include "grpc/grpc_client.h"
   148	#include "utils/flags.h"
   149	#include "utils/log.h"
   150	#include "utils/timer.h"
   151	
   152	DEFINE_string(host, "127.0.0.1", "host of websocket server");
   153	DEFINE_int32(port, 10086, "port of websocket server");
   154	DEFINE_int32(nbest, 1, "n-best of decode result");
   155	DEFINE_string(wav_path, "", "test wav file path");
   156	DEFINE_bool(continuous_decoding, false, "continuous decoding mode");
   157	
   158	int main(int argc, char *argv[]) {
   159	  gflags::ParseCommandLineFlags(&argc, &argv, false);
   160	  google::InitGoogleLogging(argv[0]);
   161	  wenet::GrpcClient client(FLAGS_host, FLAGS_port, FLAGS_nbest,
   162	                           FLAGS_continuous_decoding);
   163	
   164	  wenet::WavReader wav_reader(FLAGS_wav_path);
   165	  const int sample_rate = 16000;
   166	  // Only support 16K
   167	  CHECK_EQ(wav_reader.sample_rate(), sample_rate);
   168	  const int num_sample = wav_reader.num_sample();
   169	  std::vector<float> pcm_data(wav_reader.data(),
   170	                              wav_reader.data() + num_sample);
   171	  // Send data every 0.5 second
   172	  const float interval = 0.5;
   173	  const int sample_interval = interval * sample_rate;
   174	  for (int start = 0; start < num_sample; start += sample_interval) {
   175	    if (client.done()) {
   176	      break;
   177	    }
   178	    int end = std::min(start + sample_interval, num_sample);
   179	    // Convert to short
   180	    std::vector<int16_t> data;
   181	    data.reserve(end - start);
   182	    for (int j = start; j < end; j++) {
   183	      data.push_back(static_cast<int16_t>(pcm_data[j]));
   184	    }
   185	    // Send PCM data
   186	    client.SendBinaryData(data.data(), data.size() * sizeof(int16_t));
   187	    VLOG(2) << "Send " << data.size() << " samples";
   188	    std::this_thread::sleep_for(
   189	        std::chrono::milliseconds(static_cast<int>(interval * 1000)));
   190	  }
   191	  wenet::Timer timer;
   192	
   193	  client.Join();
   194	  VLOG(2) << "Total latency: " << timer.Elapsed() << "ms.";
   195	  return 0;
   196	}
   197	// Copyright (c) 2021 Ximalaya Speech Team (Xiang Lyu)
   198	//
   199	// Licensed under the Apache License, Version 2.0 (the "License");
   200	// you may not use this file except in compliance with the License.
   201	// You may obtain a copy of the License at
   202	//
   203	//   http://www.apache.org/licenses/LICENSE-2.0
   204	//
   205	// Unless required by applicable law or agreed to in writing, software
   206	// distributed under the License is distributed on an "AS IS" BASIS,
   207	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   208	// See the License for the specific language governing permissions and
   209	// limitations under the License.
   210	
   211	#include <grpcpp/ext/proto_server_reflection_plugin.h>
   212	#include <grpcpp/grpcpp.h>
   213	#include <grpcpp/health_check_service_interface.h>
   214	
   215	#include "decoder/params.h"
   216	#include "grpc/grpc_server.h"
   217	#include "utils/log.h"
   218	
   219	DEFINE_int32(port, 10086, "grpc listening port");
   220	DEFINE_int32(workers, 4, "grpc num workers");
   221	
   222	using grpc::Server;
   223	using grpc::ServerBuilder;
   224	
   225	int main(int argc, char *argv[]) {
   226	  gflags::ParseCommandLineFlags(&argc, &argv, false);
   227	  google::InitGoogleLogging(argv[0]);
   228	
   229	  auto decode_config = wenet::InitDecodeOptionsFromFlags();
   230	  auto feature_config = wenet::InitFeaturePipelineConfigFromFlags();
   231	  auto decode_resource = wenet::InitDecodeResourceFromFlags();
   232	
   233	  wenet::GrpcServer service(feature_config, decode_config, decode_resource);
   234	  grpc::EnableDefaultHealthCheckService(true);
   235	  grpc::reflection::InitProtoReflectionServerBuilderPlugin();
   236	  ServerBuilder builder;
   237	  std::string address("0.0.0.0:" + std::to_string(FLAGS_port));
   238	  builder.AddListeningPort(address, grpc::InsecureServerCredentials());
   239	  builder.RegisterService(&service);
   240	  builder.SetSyncServerOption(ServerBuilder::SyncServerOption::NUM_CQS,
   241	                              FLAGS_workers);
   242	  std::unique_ptr<Server> server(builder.BuildAndStart());
   243	  LOG(INFO) << "Listening at port " << FLAGS_port;
   244	  server->Wait();
   245	  google::ShutdownGoogleLogging();
   246	  return 0;
   247	}
   248	// Copyright 2021 Mobvoi Inc. All Rights Reserved.
   249	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
   250	
   251	#include <memory>
   252	#include <sstream>
   253	#include <unordered_map>
   254	#include <vector>
   255	
   256	#include "decoder/params.h"
   257	#include "frontend/wav.h"
   258	#include "utils/flags.h"
   259	#include "utils/log.h"
   260	#include "utils/string.h"
   261	
   262	DEFINE_string(text, "", "kaldi style text input file");
   263	DEFINE_string(wav_scp, "", "kaldi style wav scp");
   264	DEFINE_double(is_penalty, 1.0,
   265	              "insertion/substitution penalty for align insertion");
   266	DEFINE_double(del_penalty, 1.0, "deletion penalty for align insertion");
   267	DEFINE_string(result, "", "result output file");
   268	DEFINE_string(timestamp, "", "timestamp output file");
   269	
   270	namespace wenet {
   271	
   272	const char *kDeletion = "<del>";
   273	// Is: Insertion and substitution
   274	const char *kIsStart = "<is>";
   275	const char *kIsEnd = "</is>";
   276	
   277	bool MapToLabel(const std::string &text,
   278	                std::shared_ptr<fst::SymbolTable> symbol_table,
   279	                std::vector<int> *labels) {
   280	  labels->clear();
   281	  // Split label to char sequence
   282	  std::vector<std::string> chars;
   283	  SplitUTF8StringToChars(text, &chars);
   284	  for (size_t i = 0; i < chars.size(); i++) {
   285	    // ▁ is special symbol for white space
   286	    std::string label = chars[i] != " " ? chars[i] : "▁";
   287	    int id = symbol_table->Find(label);
   288	    if (id != -1) {  // fst::kNoSymbol
   289	      // LOG(INFO) << label << " " << id;
   290	      labels->push_back(id);
   291	    }
   292	  }
   293	}
   294	
   295	std::shared_ptr<fst::SymbolTable> MakeSymbolTableForFst(
   296	    std::shared_ptr<fst::SymbolTable> isymbol_table) {
   297	  LOG(INFO) << isymbol_table;
   298	  CHECK(isymbol_table != nullptr);
   299	  auto osymbol_table = std::make_shared<fst::SymbolTable>();
   300	  osymbol_table->AddSymbol("<eps>", 0);
   301	  CHECK_EQ(isymbol_table->Find("<blank>"), 0);
   302	  osymbol_table->AddSymbol("<blank>", 1);
   303	  for (int i = 1; i < isymbol_table->NumSymbols(); i++) {
   304	    std::string symbol = isymbol_table->Find(i);
   305	    osymbol_table->AddSymbol(symbol, i + 1);
   306	  }
   307	  osymbol_table->AddSymbol(kDeletion, isymbol_table->NumSymbols() + 1);
   308	  osymbol_table->AddSymbol(kIsStart, isymbol_table->NumSymbols() + 2);
   309	  osymbol_table->AddSymbol(kIsEnd, isymbol_table->NumSymbols() + 3);
   310	  return osymbol_table;
   311	}
   312	
   313	void CompileCtcFst(std::shared_ptr<fst::SymbolTable> symbol_table,
   314	                   fst::StdVectorFst *ofst) {
   315	  ofst->DeleteStates();
   316	  int start = ofst->AddState();
   317	  ofst->SetStart(start);
   318	  CHECK_EQ(symbol_table->Find("<eps>"), 0);
   319	  CHECK_EQ(symbol_table->Find("<blank>"), 1);
   320	  ofst->AddArc(start, fst::StdArc(1, 0, 0.0, start));
   321	  // Exclude kDeletion and kInsertion
   322	  for (int i = 2; i < symbol_table->NumSymbols() - 3; i++) {
   323	    int s = ofst->AddState();
   324	    ofst->AddArc(start, fst::StdArc(i, i, 0.0, s));
   325	    ofst->AddArc(s, fst::StdArc(i, 0, 0.0, s));
   326	    ofst->AddArc(s, fst::StdArc(0, 0, 0.0, start));
   327	  }
   328	  ofst->SetFinal(start, fst::StdArc::Weight::One());
   329	  fst::ArcSort(ofst, fst::StdOLabelCompare());
   330	}
   331	
   332	void CompileAlignFst(std::vector<int> labels,
   333	                     std::shared_ptr<fst::SymbolTable> symbol_table,
   334	                     fst::StdVectorFst *ofst) {
   335	  ofst->DeleteStates();
   336	  int deletion = symbol_table->Find(kDeletion);
   337	  int insertion_start = symbol_table->Find(kIsStart);
   338	  int insertion_end = symbol_table->Find(kIsEnd);
   339	
   340	  int start = ofst->AddState();
   341	  ofst->SetStart(start);
   342	  // Filler State
   343	  int filler_start = ofst->AddState();
   344	  int filler_end = ofst->AddState();
   345	  for (int i = 2; i < symbol_table->NumSymbols() - 3; i++) {
   346	    ofst->AddArc(filler_start, fst::StdArc(i, i, FLAGS_is_penalty, filler_end));
   347	  }
   348	  ofst->AddArc(filler_end, fst::StdArc(0, 0, 0.0, filler_start));
   349	
   350	  int prev = start;
   351	  // Alignment path and optional filler
   352	  for (size_t i = 0; i < labels.size(); i++) {
   353	    int cur = ofst->AddState();
   354	    // 1. Insertion or Substitution
   355	    ofst->AddArc(prev, fst::StdArc(0, insertion_start, 0.0, filler_start));
   356	    ofst->AddArc(filler_end, fst::StdArc(0, insertion_end, 0.0, prev));
   357	    // 2. Correct
   358	    ofst->AddArc(prev, fst::StdArc(labels[i], labels[i], 0.0, cur));
   359	    // 3. Deletion
   360	    ofst->AddArc(prev, fst::StdArc(0, deletion, FLAGS_del_penalty, cur));
   361	
   362	    prev = cur;
   363	  }
   364	  // Optional add endding filler
   365	  ofst->AddArc(prev, fst::StdArc(0, insertion_start, 0.0, filler_start));
   366	  ofst->AddArc(filler_end, fst::StdArc(0, insertion_end, 0.0, prev));
   367	  ofst->SetFinal(prev, fst::StdArc::Weight::One());
   368	  fst::ArcSort(ofst, fst::StdILabelCompare());
   369	}
   370	
   371	}  // namespace com.demo.wenet
   372	
   373	int main(int argc, char *argv[]) {
   374	  gflags::ParseCommandLineFlags(&argc, &argv, false);
   375	  google::InitGoogleLogging(argv[0]);
   376	
   377	  auto decode_config = wenet::InitDecodeOptionsFromFlags();
   378	  auto feature_config = wenet::InitFeaturePipelineConfigFromFlags();
   379	  auto decode_resource = wenet::InitDecodeResourceFromFlags();
   380	  CHECK(decode_resource->unit_table != nullptr);
   381	
   382	  auto wfst_symbol_table =
   383	      wenet::MakeSymbolTableForFst(decode_resource->unit_table);
   384	  // wfst_symbol_table->WriteText("fst.txt");
   385	  // Reset symbol_table to on-the-fly generated wfst_symbol_table
   386	  decode_resource->symbol_table = wfst_symbol_table;
   387	
   388	  // Compile ctc FST
   389	  fst::StdVectorFst ctc_fst;
   390	  wenet::CompileCtcFst(wfst_symbol_table, &ctc_fst);
   391	  // ctc_fst.Write("ctc.fst");
   392	
   393	  std::unordered_map<std::string, std::string> wav_table;
   394	  std::ifstream wav_is(FLAGS_wav_scp);
   395	  std::string line;
   396	  while (std::getline(wav_is, line)) {
   397	    std::vector<std::string> strs;
   398	    wenet::SplitString(line, &strs);
   399	    CHECK_EQ(strs.size(), 2);
   400	    wav_table[strs[0]] = strs[1];
   401	  }
   402	
   403	  std::ifstream text_is(FLAGS_text);
   404	  std::ofstream result_os(FLAGS_result, std::ios::out);
   405	  std::ofstream timestamp_out;
   406	  if (!FLAGS_timestamp.empty()) {
   407	    timestamp_out.open(FLAGS_timestamp, std::ios::out);
   408	  }
   409	  std::ostream &timestamp_os =
   410	      FLAGS_timestamp.empty() ? std::cout : timestamp_out;
   411	
   412	  while (std::getline(text_is, line)) {
   413	    std::vector<std::string> strs;
   414	    wenet::SplitString(line, &strs);
   415	    if (strs.size() < 2) continue;
   416	    std::string key = strs[0];
   417	    LOG(INFO) << "Processing " << key;
   418	    if (wav_table.find(key) != wav_table.end()) {
   419	      strs.erase(strs.begin());
   420	      std::string text = wenet::JoinString(" ", strs);
   421	      std::vector<int> labels;
   422	      wenet::MapToLabel(text, wfst_symbol_table, &labels);
   423	      // Prepare FST for alignment decoding
   424	      fst::StdVectorFst align_fst;
   425	      wenet::CompileAlignFst(labels, wfst_symbol_table, &align_fst);
   426	      // align_fst.Write("align.fst");
   427	      auto decoding_fst = std::make_shared<fst::StdVectorFst>();
   428	      fst::Compose(ctc_fst, align_fst, decoding_fst.get());
   429	      // decoding_fst->Write("decoding.fst");
   430	      // Preapre feature pipeline
   431	      wenet::WavReader wav_reader;
   432	      if (!wav_reader.Open(wav_table[key])) {
   433	        LOG(WARNING) << "Error in reading " << wav_table[key];
   434	        continue;
   435	      }
   436	      CHECK_EQ(wav_reader.sample_rate(), FLAGS_sample_rate);
   437	      auto feature_pipeline =
   438	          std::make_shared<wenet::FeaturePipeline>(*feature_config);
   439	      feature_pipeline->AcceptWaveform(std::vector<float>(
   440	          wav_reader.data(), wav_reader.data() + wav_reader.num_sample()));
   441	      feature_pipeline->set_input_finished();
   442	      decode_resource->fst = decoding_fst;
   443	      LOG(INFO) << "num frames " << feature_pipeline->num_frames();
   444	      wenet::TorchAsrDecoder decoder(feature_pipeline, decode_resource,
   445	                                     *decode_config);
   446	      while (true) {
   447	        wenet::DecodeState state = decoder.Decode();
   448	        if (state == wenet::DecodeState::kEndFeats) {
   449	          decoder.Rescoring();
   450	          break;
   451	        }
   452	      }
   453	      std::string final_result;
   454	      std::string timestamp_str;
   455	      if (decoder.DecodedSomething()) {
   456	        const wenet::DecodeResult &result = decoder.result()[0];
   457	        final_result = result.sentence;
   458	        std::stringstream ss;
   459	        for (const auto &w : result.word_pieces) {
   460	          ss << " " << w.word << " " << w.start << " " << w.end;
   461	        }
   462	        timestamp_str = ss.str();
   463	      }
   464	      result_os << key << " " << final_result << std::endl;
   465	      timestamp_os << key << " " << timestamp_str << std::endl;
   466	      LOG(INFO) << key << " " << final_result;
   467	    } else {
   468	      LOG(WARNING) << "No wav file for " << key;
   469	    }
   470	  }
   471	  return 0;
   472	}
   473	// Copyright (c) 2020 Mobvoi Inc (Binbin Zhang)
   474	//
   475	// Licensed under the Apache License, Version 2.0 (the "License");
   476	// you may not use this file except in compliance with the License.
   477	// You may obtain a copy of the License at
   478	//
   479	//   http://www.apache.org/licenses/LICENSE-2.0
   480	//
   481	// Unless required by applicable law or agreed to in writing, software
   482	// distributed under the License is distributed on an "AS IS" BASIS,
   483	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   484	// See the License for the specific language governing permissions and
   485	// limitations under the License.
   486	
   487	#include "frontend/wav.h"
   488	#include "utils/flags.h"
   489	#include "utils/log.h"
   490	#include "utils/timer.h"
   491	#include "websocket/websocket_client.h"
   492	
   493	DEFINE_string(host, "127.0.0.1", "host of websocket server");
   494	DEFINE_int32(port, 10086, "port of websocket server");
   495	DEFINE_int32(nbest, 1, "n-best of decode result");
   496	DEFINE_string(wav_path, "", "test wav file path");
   497	DEFINE_bool(continuous_decoding, false, "continuous decoding mode");
   498	
   499	int main(int argc, char *argv[]) {
   500	  gflags::ParseCommandLineFlags(&argc, &argv, false);
   501	  google::InitGoogleLogging(argv[0]);
   502	  wenet::WebSocketClient client(FLAGS_host, FLAGS_port);
   503	  client.set_nbest(FLAGS_nbest);
   504	  client.set_continuous_decoding(FLAGS_continuous_decoding);
   505	  client.SendStartSignal();
   506	
   507	  wenet::WavReader wav_reader(FLAGS_wav_path);
   508	  const int sample_rate = 16000;
   509	  // Only support 16K
   510	  CHECK_EQ(wav_reader.sample_rate(), sample_rate);
   511	  const int num_sample = wav_reader.num_sample();
   512	  std::vector<float> pcm_data(wav_reader.data(),
   513	                              wav_reader.data() + num_sample);
   514	  // Send data every 0.5 second
   515	  const float interval = 0.5;
   516	  const int sample_interval = interval * sample_rate;
   517	  for (int start = 0; start < num_sample; start += sample_interval) {
   518	    if (client.done()) {
   519	      break;
   520	    }
   521	    int end = std::min(start + sample_interval, num_sample);
   522	    // Convert to short
   523	    std::vector<int16_t> data;
   524	    data.reserve(end - start);
   525	    for (int j = start; j < end; j++) {
   526	      data.push_back(static_cast<int16_t>(pcm_data[j]));
   527	    }
   528	    // Send PCM data
   529	    client.SendBinaryData(data.data(), data.size() * sizeof(int16_t));
   530	    VLOG(2) << "Send " << data.size() << " samples";
   531	    std::this_thread::sleep_for(
   532	        std::chrono::milliseconds(static_cast<int>(interval * 1000)));
   533	  }
   534	  wenet::Timer timer;
   535	  client.SendEndSignal();
   536	  client.Join();
   537	  VLOG(2) << "Total latency: " << timer.Elapsed() << "ms.";
   538	  return 0;
   539	}
   540	// Copyright (c) 2020 Mobvoi Inc (Binbin Zhang)
   541	//
   542	// Licensed under the Apache License, Version 2.0 (the "License");
   543	// you may not use this file except in compliance with the License.
   544	// You may obtain a copy of the License at
   545	//
   546	//   http://www.apache.org/licenses/LICENSE-2.0
   547	//
   548	// Unless required by applicable law or agreed to in writing, software
   549	// distributed under the License is distributed on an "AS IS" BASIS,
   550	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   551	// See the License for the specific language governing permissions and
   552	// limitations under the License.
   553	
   554	#include "decoder/params.h"
   555	#include "utils/log.h"
   556	#include "websocket/websocket_server.h"
   557	
   558	DEFINE_int32(port, 10086, "websocket listening port");
   559	
   560	int main(int argc, char *argv[]) {
   561	  gflags::ParseCommandLineFlags(&argc, &argv, false);
   562	  google::InitGoogleLogging(argv[0]);
   563	
   564	  auto decode_config = wenet::InitDecodeOptionsFromFlags();
   565	  auto feature_config = wenet::InitFeaturePipelineConfigFromFlags();
   566	  auto decode_resource = wenet::InitDecodeResourceFromFlags();
   567	
   568	  wenet::WebSocketServer server(FLAGS_port, feature_config, decode_config,
   569	                                decode_resource);
   570	  LOG(INFO) << "Listening at port " << FLAGS_port;
   571	  server.Start();
   572	  return 0;
   573	}
   574	// Copyright 2021 Mobvoi Inc. All Rights Reserved.
   575	// Author: zhendong.peng@mobvoi.com (Zhendong Peng)
   576	
   577	#include "decoder/context_graph.h"
   578	
   579	#include <utility>
   580	
   581	#include "fst/determinize.h"
   582	
   583	#include "utils/string.h"
   584	
   585	namespace wenet {
   586	
   587	ContextGraph::ContextGraph(ContextConfig config) : config_(config) {}
   588	
   589	void ContextGraph::BuildContextGraph(
   590	    const std::vector<std::string>& query_contexts,
   591	    const std::shared_ptr<fst::SymbolTable>& symbol_table) {
   592	  CHECK(symbol_table != nullptr) << "Symbols table should not be nullptr!";
   593	  start_tag_id_ = symbol_table->AddSymbol("<context>");
   594	  end_tag_id_ = symbol_table->AddSymbol("</context>");
   595	  symbol_table_ = symbol_table;
   596	  if (query_contexts.empty()) {
   597	    graph_.reset();
   598	    return;
   599	  }
   600	
   601	  std::unique_ptr<fst::StdVectorFst> ofst(new fst::StdVectorFst());
   602	  // State 0 is the start state and the final state.
   603	  int start_state = ofst->AddState();
   604	  ofst->SetStart(start_state);
   605	  ofst->SetFinal(start_state, fst::StdArc::Weight::One());
   606	
   607	  LOG(INFO) << "Contexts count size: " << query_contexts.size();
   608	  int count = 0;
   609	  for (const auto& context : query_contexts) {
   610	    if (context.size() > config_.max_context_length) {
   611	      LOG(INFO) << "Skip long context: " << context;
   612	      continue;
   613	    }
   614	    if (++count > config_.max_contexts) break;
   615	
   616	    std::vector<std::string> words;
   617	    // Split context to words by symbol table, and build the context graph.
   618	    bool no_oov = SplitUTF8StringToWords(Trim(context), symbol_table, &words);
   619	    if (!no_oov) {
   620	      LOG(WARNING) << "Ignore unknown word found during compilation.";
   621	      continue;
   622	    }
   623	
   624	    int prev_state = start_state;
   625	    int next_state = start_state;
   626	    float escape_score = 0;
   627	    for (size_t i = 0; i < words.size(); ++i) {
   628	      int word_id = symbol_table_->Find(words[i]);
   629	      float score = config_.context_score * UTF8StringLength(words[i]);
   630	      next_state = (i < words.size() - 1) ? ofst->AddState() : start_state;
   631	      ofst->AddArc(prev_state,
   632	                   fst::StdArc(word_id, word_id, score, next_state));
   633	      // Add escape arc to clean the previous context score.
   634	      if (i > 0) {
   635	        // ilabel and olabel of the escape arc is 0 (<epsilon>).
   636	        ofst->AddArc(prev_state, fst::StdArc(0, 0, -escape_score, start_state));
   637	      }
   638	      prev_state = next_state;
   639	      escape_score += score;
   640	    }
   641	  }
   642	  std::unique_ptr<fst::StdVectorFst> det_fst(new fst::StdVectorFst());
   643	  fst::Determinize(*ofst, det_fst.get());
   644	  graph_ = std::move(det_fst);
   645	}
   646	
   647	int ContextGraph::GetNextState(int cur_state, int word_id, float* score,
   648	                               bool* is_start_boundary, bool* is_end_boundary) {
   649	  int next_state = 0;
   650	  for (fst::ArcIterator<fst::StdFst> aiter(*graph_, cur_state); !aiter.Done();
   651	       aiter.Next()) {
   652	    const fst::StdArc& arc = aiter.Value();
   653	    if (arc.ilabel == 0) {
   654	      // escape score, will be overwritten when ilabel equals to word id.
   655	      *score = arc.weight.Value();
   656	    } else if (arc.ilabel == word_id) {
   657	      next_state = arc.nextstate;
   658	      *score = arc.weight.Value();
   659	      if (cur_state == 0) {
   660	        *is_start_boundary = true;
   661	      }
   662	      if (graph_->Final(arc.nextstate) == fst::StdArc::Weight::One()) {
   663	        *is_end_boundary = true;
   664	      }
   665	      break;
   666	    }
   667	  }
   668	  return next_state;
   669	}
   670	
   671	}  // namespace com.demo.wenet
   672	// Copyright 2021 Mobvoi Inc. All Rights Reserved.
   673	// Author: zhendong.peng@mobvoi.com (Zhendong Peng)
   674	
   675	#include "decoder/ctc_endpoint.h"
   676	
   677	#include <string>
   678	
   679	#include "utils/log.h"
   680	
   681	namespace wenet {
   682	
   683	CtcEndpoint::CtcEndpoint(const CtcEndpointConfig& config) : config_(config) {
   684	  Reset();
   685	}
   686	
   687	void CtcEndpoint::Reset() {
   688	  num_frames_decoded_ = 0;
   689	  num_frames_trailing_blank_ = 0;
   690	}
   691	
   692	static bool RuleActivated(const CtcEndpointRule& rule,
   693	                          const std::string& rule_name, bool decoded_sth,
   694	                          int trailing_silence, int utterance_length) {
   695	  bool ans = (decoded_sth || !rule.must_decoded_sth) &&
   696	             trailing_silence >= rule.min_trailing_silence &&
   697	             utterance_length >= rule.min_utterance_length;
   698	  if (ans) {
   699	    VLOG(2) << "Endpointing rule " << rule_name
   700	            << " activated: " << (decoded_sth ? "true" : "false") << ','
   701	            << trailing_silence << ',' << utterance_length;
   702	  }
   703	  return ans;
   704	}
   705	
   706	bool CtcEndpoint::IsEndpoint(const torch::Tensor& ctc_log_probs,
   707	                             bool decoded_something) {
   708	  for (int t = 0; t < ctc_log_probs.size(0); ++t) {
   709	    torch::Tensor logp_t = ctc_log_probs[t];
   710	    float blank_prob = expf(logp_t[config_.blank].item<float>());
   711	
   712	    num_frames_decoded_++;
   713	    if (blank_prob > config_.blank_threshold) {
   714	      num_frames_trailing_blank_++;
   715	    } else {
   716	      num_frames_trailing_blank_ = 0;
   717	    }
   718	  }
   719	  CHECK_GE(num_frames_decoded_, num_frames_trailing_blank_);
   720	  CHECK_GT(frame_shift_in_ms_, 0);
   721	  int utterance_length = num_frames_decoded_ * frame_shift_in_ms_;
   722	  int trailing_silence = num_frames_trailing_blank_ * frame_shift_in_ms_;
   723	  if (RuleActivated(config_.rule1, "rule1", decoded_something, trailing_silence,
   724	                    utterance_length))
   725	    return true;
   726	  if (RuleActivated(config_.rule2, "rule2", decoded_something, trailing_silence,
   727	                    utterance_length))
   728	    return true;
   729	  if (RuleActivated(config_.rule3, "rule3", decoded_something, trailing_silence,
   730	                    utterance_length))
   731	    return true;
   732	  return false;
   733	}
   734	
   735	}  // namespace com.demo.wenet
   736	// Copyright 2020 Mobvoi Inc. All Rights Reserved.
   737	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
   738	
   739	#include "decoder/ctc_prefix_beam_search.h"
   740	
   741	#include <algorithm>
   742	#include <tuple>
   743	#include <unordered_map>
   744	#include <utility>
   745	
   746	#include "utils/log.h"
   747	
   748	namespace wenet {
   749	
   750	CtcPrefixBeamSearch::CtcPrefixBeamSearch(
   751	    const CtcPrefixBeamSearchOptions& opts,
   752	    const std::shared_ptr<ContextGraph>& context_graph)
   753	    : opts_(opts), context_graph_(context_graph) {
   754	  Reset();
   755	}
   756	
   757	void CtcPrefixBeamSearch::Reset() {
   758	  hypotheses_.clear();
   759	  likelihood_.clear();
   760	  cur_hyps_.clear();
   761	  viterbi_likelihood_.clear();
   762	  times_.clear();
   763	  outputs_.clear();
   764	  abs_time_step_ = 0;
   765	  PrefixScore prefix_score;
   766	  prefix_score.s = 0.0;
   767	  prefix_score.ns = -kFloatMax;
   768	  prefix_score.v_s = 0.0;
   769	  prefix_score.v_ns = 0.0;
   770	  std::vector<int> empty;
   771	  cur_hyps_[empty] = prefix_score;
   772	}
   773	
   774	static bool PrefixScoreCompare(
   775	    const std::pair<std::vector<int>, PrefixScore>& a,
   776	    const std::pair<std::vector<int>, PrefixScore>& b) {
   777	  return a.second.total_score() > b.second.total_score();
   778	}
   779	
   780	void CtcPrefixBeamSearch::UpdateOutputs(
   781	    const std::pair<std::vector<int>, PrefixScore>& prefix) {
   782	  const std::vector<int>& input = prefix.first;
   783	  const std::vector<int>& start_boundaries = prefix.second.start_boundaries;
   784	  const std::vector<int>& end_boundaries = prefix.second.end_boundaries;
   785	
   786	  std::vector<int> output;
   787	  int s = 0;
   788	  int e = 0;
   789	  for (int i = 0; i < input.size(); ++i) {
   790	    if (s < start_boundaries.size() && i == start_boundaries[s]) {
   791	      output.emplace_back(context_graph_->start_tag_id());
   792	      ++s;
   793	    }
   794	    output.emplace_back(input[i]);
   795	    if (e < end_boundaries.size() && i == end_boundaries[e]) {
   796	      output.emplace_back(context_graph_->end_tag_id());
   797	      ++e;
   798	    }
   799	  }
   800	  outputs_.emplace_back(output);
   801	}
   802	
   803	// Please refer https://robin1001.github.io/2020/12/11/ctc-search
   804	// for how CTC prefix beam search works, and there is a simple graph demo in
   805	// it.
   806	void CtcPrefixBeamSearch::Search(const torch::Tensor& logp) {
   807	  CHECK_EQ(logp.dtype(), torch::kFloat);
   808	  CHECK_EQ(logp.dim(), 2);
   809	  for (int t = 0; t < logp.size(0); ++t, ++abs_time_step_) {
   810	    torch::Tensor logp_t = logp[t];
   811	    std::unordered_map<std::vector<int>, PrefixScore, PrefixHash> next_hyps;
   812	    // 1. First beam prune, only select topk candidates
   813	    std::tuple<Tensor, Tensor> topk = logp_t.topk(opts_.first_beam_size);
   814	    Tensor topk_score = std::get<0>(topk);
   815	    Tensor topk_index = std::get<1>(topk);
   816	
   817	    // 2. Token passing
   818	    for (int i = 0; i < topk_index.size(0); ++i) {
   819	      int id = topk_index[i].item<int>();
   820	      auto prob = topk_score[i].item<float>();
   821	      for (const auto& it : cur_hyps_) {
   822	        const std::vector<int>& prefix = it.first;
   823	        const PrefixScore& prefix_score = it.second;
   824	        // If prefix doesn't exist in next_hyps, next_hyps[prefix] will insert
   825	        // PrefixScore(-inf, -inf) by default, since the default constructor
   826	        // of PrefixScore will set fields s(blank ending score) and
   827	        // ns(none blank ending score) to -inf, respectively.
   828	        if (id == opts_.blank) {
   829	          // Case 0: *a + ε => *a
   830	          PrefixScore& next_score = next_hyps[prefix];
   831	          next_score.s = LogAdd(next_score.s, prefix_score.score() + prob);
   832	          next_score.v_s = prefix_score.viterbi_score() + prob;
   833	          next_score.times_s = prefix_score.times();
   834	          // Prefix not changed, copy the context from prefix.
   835	          if (context_graph_ && !next_score.has_context) {
   836	            next_score.CopyContext(prefix_score);
   837	            next_score.has_context = true;
   838	          }
   839	        } else if (!prefix.empty() && id == prefix.back()) {
   840	          // Case 1: *a + a => *a
   841	          PrefixScore& next_score1 = next_hyps[prefix];
   842	          next_score1.ns = LogAdd(next_score1.ns, prefix_score.ns + prob);
   843	          if (next_score1.v_ns < prefix_score.v_ns + prob) {
   844	            next_score1.v_ns = prefix_score.v_ns + prob;
   845	            if (next_score1.cur_token_prob < prob) {
   846	              next_score1.cur_token_prob = prob;
   847	              next_score1.times_ns = prefix_score.times_ns;
   848	              CHECK_GT(next_score1.times_ns.size(), 0);
   849	              next_score1.times_ns.back() = abs_time_step_;
   850	            }
   851	          }
   852	          if (context_graph_ && !next_score1.has_context) {
   853	            next_score1.CopyContext(prefix_score);
   854	            next_score1.has_context = true;
   855	          }
   856	
   857	          // Case 2: *aε + a => *aa
   858	          std::vector<int> new_prefix(prefix);
   859	          new_prefix.emplace_back(id);
   860	          PrefixScore& next_score2 = next_hyps[new_prefix];
   861	          next_score2.ns = LogAdd(next_score2.ns, prefix_score.s + prob);
   862	          if (next_score2.v_ns < prefix_score.v_s + prob) {
   863	            next_score2.v_ns = prefix_score.v_s + prob;
   864	            next_score2.cur_token_prob = prob;
   865	            next_score2.times_ns = prefix_score.times_s;
   866	            next_score2.times_ns.emplace_back(abs_time_step_);
   867	          }
   868	          if (context_graph_ && !next_score2.has_context) {
   869	            // Prefix changed, calculate the context score.
   870	            next_score2.UpdateContext(context_graph_, prefix_score, id,
   871	                                      prefix.size());
   872	            next_score2.has_context = true;
   873	          }
   874	        } else {
   875	          // Case 3: *a + b => *ab, *aε + b => *ab
   876	          std::vector<int> new_prefix(prefix);
   877	          new_prefix.emplace_back(id);
   878	          PrefixScore& next_score = next_hyps[new_prefix];
   879	          next_score.ns = LogAdd(next_score.ns, prefix_score.score() + prob);
   880	          if (next_score.v_ns < prefix_score.viterbi_score() + prob) {
   881	            next_score.v_ns = prefix_score.viterbi_score() + prob;
   882	            next_score.cur_token_prob = prob;
   883	            next_score.times_ns = prefix_score.times();
   884	            next_score.times_ns.emplace_back(abs_time_step_);
   885	          }
   886	          if (context_graph_ && !next_score.has_context) {
   887	            // Calculate the context score.
   888	            next_score.UpdateContext(context_graph_, prefix_score, id,
   889	                                     prefix.size());
   890	            next_score.has_context = true;
   891	          }
   892	        }
   893	      }
   894	    }
   895	
   896	    // 3. Second beam prune, only keep top n best paths
   897	    std::vector<std::pair<std::vector<int>, PrefixScore>> arr(next_hyps.begin(),
   898	                                                              next_hyps.end());
   899	    int second_beam_size =
   900	        std::min(static_cast<int>(arr.size()), opts_.second_beam_size);
   901	    std::nth_element(arr.begin(), arr.begin() + second_beam_size, arr.end(),
   902	                     PrefixScoreCompare);
   903	    arr.resize(second_beam_size);
   904	    std::sort(arr.begin(), arr.end(), PrefixScoreCompare);
   905	
   906	    // 4. Update cur_hyps_ and get new result
   907	    cur_hyps_.clear();
   908	    outputs_.clear();
   909	    hypotheses_.clear();
   910	    likelihood_.clear();
   911	    viterbi_likelihood_.clear();
   912	    times_.clear();
   913	    for (auto& item : arr) {
   914	      cur_hyps_[item.first] = item.second;
   915	      UpdateOutputs(item);
   916	      hypotheses_.emplace_back(std::move(item.first));
   917	      likelihood_.emplace_back(item.second.total_score());
   918	      viterbi_likelihood_.emplace_back(item.second.viterbi_score());
   919	      times_.emplace_back(item.second.times());
   920	    }
   921	  }
   922	}
   923	
   924	}  // namespace com.demo.wenet
   925	// Copyright 2020 Mobvoi Inc. All Rights Reserved.
   926	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
   927	
   928	#include "decoder/ctc_prefix_beam_search.h"
   929	
   930	#include <cmath>
   931	#include <vector>
   932	
   933	#include "gmock/gmock.h"
   934	#include "gtest/gtest.h"
   935	
   936	#include "utils/utils.h"
   937	
   938	TEST(CtcPrefixBeamSearchTest, CtcPrefixBeamSearchLogicTest) {
   939	  using ::testing::ElementsAre;
   940	  // See https://robin1001.github.io/2020/12/11/ctc-search for the
   941	  // graph demonstration of the data
   942	  std::vector<float> data = {0.25, 0.40, 0.35, 0.40, 0.35,
   943	                             0.25, 0.10, 0.50, 0.40};
   944	  torch::Tensor input = torch::from_blob(data.data(), {3, 3}, torch::kFloat);
   945	  EXPECT_EQ(input.size(0), 3);
   946	  EXPECT_EQ(input.size(1), 3);
   947	  input = torch::log(input);
   948	  wenet::CtcPrefixBeamSearchOptions option;
   949	  option.first_beam_size = 3;
   950	  option.second_beam_size = 3;
   951	  wenet::CtcPrefixBeamSearch prefix_beam_search(option);
   952	  prefix_beam_search.Search(input);
   953	  /* Test case info
   954	  | top k | result index | prefix score | viterbi score | timestamp |
   955	  |-------|--------------|--------------|---------------|-----------|
   956	  | top 1 | [2, 1]       | 0.2185       | 0.07          | [0, 2]    |
   957	  | top 2 | [1, 2]       | 0.1550       | 0.064         | [0, 2]    |
   958	  | top 3 | [1]          | 0.1525       | 0.07          | [2]       |
   959	  */
   960	  const std::vector<std::vector<int>>& result = prefix_beam_search.Outputs();
   961	  EXPECT_EQ(result.size(), 3);
   962	  ASSERT_THAT(result[0], ElementsAre(2, 1));
   963	  ASSERT_THAT(result[1], ElementsAre(1, 2));
   964	  ASSERT_THAT(result[2], ElementsAre(1));
   965	
   966	  const std::vector<float>& likelihood = prefix_beam_search.Likelihood();
   967	  EXPECT_EQ(likelihood.size(), 3);
   968	  EXPECT_FLOAT_EQ(std::exp(likelihood[0]), 0.2185);
   969	  EXPECT_FLOAT_EQ(std::exp(likelihood[1]), 0.1550);
   970	  EXPECT_FLOAT_EQ(std::exp(likelihood[2]), 0.1525);
   971	
   972	  const std::vector<float>& viterbi_likelihood =
   973	      prefix_beam_search.viterbi_likelihood();
   974	  EXPECT_EQ(viterbi_likelihood.size(), 3);
   975	  EXPECT_FLOAT_EQ(std::exp(viterbi_likelihood[0]), 0.07);
   976	  EXPECT_FLOAT_EQ(std::exp(viterbi_likelihood[1]), 0.064);
   977	  EXPECT_FLOAT_EQ(std::exp(viterbi_likelihood[2]), 0.07);
   978	
   979	  const std::vector<std::vector<int>>& times = prefix_beam_search.Times();
   980	  EXPECT_EQ(times.size(), 3);
   981	  ASSERT_THAT(times[0], ElementsAre(0, 2));
   982	  ASSERT_THAT(times[1], ElementsAre(0, 2));
   983	  ASSERT_THAT(times[2], ElementsAre(2));
   984	}
   985	// Copyright 2021 Mobvoi Inc. All Rights Reserved.
   986	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
   987	
   988	#include "decoder/ctc_wfst_beam_search.h"
   989	
   990	#include <utility>
   991	
   992	namespace wenet {
   993	
   994	void DecodableTensorScaled::Reset() {
   995	  num_frames_ready_ = 0;
   996	  done_ = false;
   997	  // Give an empty initialization, will throw error when
   998	  // AcceptLoglikes is not called
   999	  logp_ = torch::zeros({1});
  1000	}
  1001	
  1002	void DecodableTensorScaled::AcceptLoglikes(const torch::Tensor& logp) {
  1003	  CHECK_EQ(logp.dim(), 1);
  1004	  ++num_frames_ready_;
  1005	  // TODO(Binbin Zhang): Avoid copy here
  1006	  logp_ = logp;
  1007	  accessor_.reset(new torch::TensorAccessor<float, 1>(
  1008	      logp_.data_ptr<float>(), logp_.sizes().data(), logp_.strides().data()));
  1009	}
  1010	
  1011	float DecodableTensorScaled::LogLikelihood(int32 frame, int32 index) {
  1012	  CHECK(accessor_ != nullptr);
  1013	  CHECK_GT(index, 0);
  1014	  CHECK_LE(index, logp_.size(0));
  1015	  CHECK_LT(frame, num_frames_ready_);
  1016	  return scale_ * (*accessor_)[index - 1];
  1017	}
  1018	
  1019	bool DecodableTensorScaled::IsLastFrame(int32 frame) const {
  1020	  CHECK_LT(frame, num_frames_ready_);
  1021	  return done_ && (frame == num_frames_ready_ - 1);
  1022	}
  1023	
  1024	int32 DecodableTensorScaled::NumIndices() const {
  1025	  LOG(FATAL) << "Not implement";
  1026	  return 0;
  1027	}
  1028	
  1029	CtcWfstBeamSearch::CtcWfstBeamSearch(
  1030	    const fst::Fst<fst::StdArc>& fst, const CtcWfstBeamSearchOptions& opts,
  1031	    const std::shared_ptr<ContextGraph>& context_graph)
  1032	    : decodable_(opts.acoustic_scale),
  1033	      decoder_(fst, opts, context_graph),
  1034	      context_graph_(context_graph),
  1035	      opts_(opts) {
  1036	  Reset();
  1037	}
  1038	
  1039	void CtcWfstBeamSearch::Reset() {
  1040	  num_frames_ = 0;
  1041	  decoded_frames_mapping_.clear();
  1042	  is_last_frame_blank_ = false;
  1043	  last_best_ = 0;
  1044	  inputs_.clear();
  1045	  outputs_.clear();
  1046	  likelihood_.clear();
  1047	  times_.clear();
  1048	  decodable_.Reset();
  1049	  decoder_.InitDecoding();
  1050	}
  1051	
  1052	void CtcWfstBeamSearch::Search(const torch::Tensor& logp) {
  1053	  CHECK_EQ(logp.dtype(), torch::kFloat);
  1054	  CHECK_EQ(logp.dim(), 2);
  1055	  if (0 == logp.size(0)) {
  1056	    return;
  1057	  }
  1058	  // Every time we get the log posterior, we decode it all before return
  1059	  auto accessor = logp.accessor<float, 2>();
  1060	  for (int i = 0; i < logp.size(0); i++) {
  1061	    float blank_score = std::exp(accessor[i][0]);
  1062	    if (blank_score > opts_.blank_skip_thresh) {
  1063	      VLOG(3) << "skipping frame " << num_frames_ << " score " << blank_score;
  1064	      is_last_frame_blank_ = true;
  1065	      last_frame_prob_ = logp[i];
  1066	    } else {
  1067	      // Get the best symbol
  1068	      int cur_best = logp[i].argmax().item<int>();
  1069	      // Optional, adding one blank frame if we has skipped it in two same
  1070	      // symbols
  1071	      if (cur_best != 0 && is_last_frame_blank_ && cur_best == last_best_) {
  1072	        decodable_.AcceptLoglikes(last_frame_prob_);
  1073	        decoder_.AdvanceDecoding(&decodable_, 1);
  1074	        decoded_frames_mapping_.push_back(num_frames_ - 1);
  1075	        VLOG(2) << "Adding blank frame at symbol " << cur_best;
  1076	      }
  1077	      last_best_ = cur_best;
  1078	
  1079	      decodable_.AcceptLoglikes(logp[i]);
  1080	      decoder_.AdvanceDecoding(&decodable_, 1);
  1081	      decoded_frames_mapping_.push_back(num_frames_);
  1082	      is_last_frame_blank_ = false;
  1083	    }
  1084	    num_frames_++;
  1085	  }
  1086	  // Get the best path
  1087	  inputs_.clear();
  1088	  outputs_.clear();
  1089	  likelihood_.clear();
  1090	  if (decoded_frames_mapping_.size() > 0) {
  1091	    inputs_.resize(1);
  1092	    outputs_.resize(1);
  1093	    likelihood_.resize(1);
  1094	    kaldi::Lattice lat;
  1095	    decoder_.GetBestPath(&lat, false);
  1096	    std::vector<int> alignment;
  1097	    kaldi::LatticeWeight weight;
  1098	    fst::GetLinearSymbolSequence(lat, &alignment, &outputs_[0], &weight);
  1099	    ConvertToInputs(alignment, &inputs_[0]);
  1100	    RemoveContinuousTags(&outputs_[0]);
  1101	    VLOG(3) << weight.Value1() << " " << weight.Value2();
  1102	    likelihood_[0] = -weight.Value2();
  1103	  }
  1104	}
  1105	
  1106	void CtcWfstBeamSearch::FinalizeSearch() {
  1107	  decodable_.SetFinish();
  1108	  decoder_.FinalizeDecoding();
  1109	  inputs_.clear();
  1110	  outputs_.clear();
  1111	  likelihood_.clear();
  1112	  times_.clear();
  1113	  if (decoded_frames_mapping_.size() > 0) {
  1114	    std::vector<kaldi::Lattice> nbest_lats;
  1115	    if (opts_.nbest == 1) {
  1116	      kaldi::Lattice lat;
  1117	      decoder_.GetBestPath(&lat, true);
  1118	      nbest_lats.push_back(std::move(lat));
  1119	    } else {
  1120	      // Get N-best path by lattice(CompactLattice)
  1121	      kaldi::CompactLattice clat;
  1122	      decoder_.GetLattice(&clat, true);
  1123	      kaldi::Lattice lat, nbest_lat;
  1124	      fst::ConvertLattice(clat, &lat);
  1125	      // TODO(Binbin Zhang): it's n-best word lists here, not character n-best
  1126	      fst::ShortestPath(lat, &nbest_lat, opts_.nbest);
  1127	      fst::ConvertNbestToVector(nbest_lat, &nbest_lats);
  1128	    }
  1129	    int nbest = nbest_lats.size();
  1130	    inputs_.resize(nbest);
  1131	    outputs_.resize(nbest);
  1132	    likelihood_.resize(nbest);
  1133	    times_.resize(nbest);
  1134	    for (int i = 0; i < nbest; i++) {
  1135	      kaldi::LatticeWeight weight;
  1136	      std::vector<int> alignment;
  1137	      fst::GetLinearSymbolSequence(nbest_lats[i], &alignment, &outputs_[i],
  1138	                                   &weight);
  1139	      ConvertToInputs(alignment, &inputs_[i], &times_[i]);
  1140	      RemoveContinuousTags(&outputs_[i]);
  1141	      likelihood_[i] = -weight.Value2();
  1142	    }
  1143	  }
  1144	}
  1145	
  1146	void CtcWfstBeamSearch::ConvertToInputs(const std::vector<int>& alignment,
  1147	                                        std::vector<int>* input,
  1148	                                        std::vector<int>* time) {
  1149	  input->clear();
  1150	  if (time != nullptr) time->clear();
  1151	  for (int cur = 0; cur < alignment.size(); ++cur) {
  1152	    // ignore blank
  1153	    if (alignment[cur] - 1 == 0) continue;
  1154	    // merge continuous same label
  1155	    if (cur > 0 && alignment[cur] == alignment[cur - 1]) continue;
  1156	
  1157	    input->push_back(alignment[cur] - 1);
  1158	    if (time != nullptr) {
  1159	      time->push_back(decoded_frames_mapping_[cur]);
  1160	    }
  1161	  }
  1162	}
  1163	
  1164	void CtcWfstBeamSearch::RemoveContinuousTags(std::vector<int>* output) {
  1165	  if (context_graph_) {
  1166	    for (auto it = output->begin(); it != output->end();) {
  1167	      if (*it == context_graph_->start_tag_id() ||
  1168	          *it == context_graph_->end_tag_id()) {
  1169	        if (it + 1 != output->end() && *it == *(it + 1)) {
  1170	          it = output->erase(it);
  1171	          continue;
  1172	        }
  1173	      }
  1174	      ++it;
  1175	    }
  1176	  }
  1177	}
  1178	
  1179	}  // namespace com.demo.wenet
  1180	// Copyright 2020 Mobvoi Inc. All Rights Reserved.
  1181	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
  1182	//         di.wu@mobvoi.com (Di Wu)
  1183	
  1184	#include "decoder/torch_asr_decoder.h"
  1185	
  1186	#include <ctype.h>
  1187	
  1188	#include <algorithm>
  1189	#include <limits>
  1190	#include <utility>
  1191	
  1192	#include "decoder/ctc_endpoint.h"
  1193	#include "utils/timer.h"
  1194	
  1195	namespace wenet {
  1196	
  1197	TorchAsrDecoder::TorchAsrDecoder(
  1198	    std::shared_ptr<FeaturePipeline> feature_pipeline,
  1199	    std::shared_ptr<DecodeResource> resource, const DecodeOptions& opts)
  1200	    : feature_pipeline_(std::move(feature_pipeline)),
  1201	      model_(resource->model),
  1202	      post_processor_(resource->post_processor),
  1203	      symbol_table_(resource->symbol_table),
  1204	      fst_(resource->fst),
  1205	      unit_table_(resource->unit_table),
  1206	      opts_(opts),
  1207	      ctc_endpointer_(new CtcEndpoint(opts.ctc_endpoint_config)) {
  1208	  if (opts_.reverse_weight > 0) {
  1209	    // Check if model has a right to left decoder
  1210	    CHECK(model_->is_bidirectional_decoder());
  1211	  }
  1212	  if (nullptr == fst_) {
  1213	    searcher_.reset(new CtcPrefixBeamSearch(opts.ctc_prefix_search_opts,
  1214	                                            resource->context_graph));
  1215	  } else {
  1216	    searcher_.reset(new CtcWfstBeamSearch(*fst_, opts.ctc_wfst_search_opts,
  1217	                                          resource->context_graph));
  1218	  }
  1219	  ctc_endpointer_->frame_shift_in_ms(frame_shift_in_ms());
  1220	}
  1221	
  1222	void TorchAsrDecoder::Reset() {
  1223	  start_ = false;
  1224	  result_.clear();
  1225	  offset_ = 0;
  1226	  num_frames_ = 0;
  1227	  global_frame_offset_ = 0;
  1228	  num_frames_in_current_chunk_ = 0;
  1229	  subsampling_cache_ = std::move(torch::jit::IValue());
  1230	  elayers_output_cache_ = std::move(torch::jit::IValue());
  1231	  conformer_cnn_cache_ = std::move(torch::jit::IValue());
  1232	  encoder_outs_.clear();
  1233	  cached_feature_.clear();
  1234	  searcher_->Reset();
  1235	  feature_pipeline_->Reset();
  1236	  ctc_endpointer_->Reset();
  1237	}
  1238	
  1239	void TorchAsrDecoder::ResetContinuousDecoding() {
  1240	  global_frame_offset_ = num_frames_;
  1241	  start_ = false;
  1242	  result_.clear();
  1243	  offset_ = 0;
  1244	  num_frames_in_current_chunk_ = 0;
  1245	  subsampling_cache_ = std::move(torch::jit::IValue());
  1246	  elayers_output_cache_ = std::move(torch::jit::IValue());
  1247	  conformer_cnn_cache_ = std::move(torch::jit::IValue());
  1248	  encoder_outs_.clear();
  1249	  cached_feature_.clear();
  1250	  searcher_->Reset();
  1251	  ctc_endpointer_->Reset();
  1252	}
  1253	
  1254	DecodeState TorchAsrDecoder::Decode() { return this->AdvanceDecoding(); }
  1255	
  1256	void TorchAsrDecoder::Rescoring() {
  1257	  // Do attention rescoring
  1258	  Timer timer;
  1259	  AttentionRescoring();
  1260	  LOG(INFO) << "Rescoring cost latency: " << timer.Elapsed() << "ms.";
  1261	}
  1262	
  1263	DecodeState TorchAsrDecoder::AdvanceDecoding() {
  1264	  DecodeState state = DecodeState::kEndBatch;
  1265	  const int subsampling_rate = model_->subsampling_rate();
  1266	  const int right_context = model_->right_context();
  1267	  const int cached_feature_size = 1 + right_context - subsampling_rate;
  1268	  const int feature_dim = feature_pipeline_->feature_dim();
  1269	  int num_requried_frames = 0;
  1270	  // If opts_.chunk_size > 0, streaming case, read feature chunk by chunk
  1271	  // otherwise, none streaming case, read all feature at once
  1272	  if (opts_.chunk_size > 0) {
  1273	    if (!start_) {                      // First batch
  1274	      int context = right_context + 1;  // Add current frame
  1275	      num_requried_frames = (opts_.chunk_size - 1) * subsampling_rate + context;
  1276	    } else {
  1277	      num_requried_frames = opts_.chunk_size * subsampling_rate;
  1278	    }
  1279	  } else {
  1280	    num_requried_frames = std::numeric_limits<int>::max();
  1281	  }
  1282	  std::vector<std::vector<float>> chunk_feats;
  1283	  // If not okay, that means we reach the end of the input
  1284	  if (!feature_pipeline_->Read(num_requried_frames, &chunk_feats)) {
  1285	    state = DecodeState::kEndFeats;
  1286	  }
  1287	
  1288	  num_frames_in_current_chunk_ = chunk_feats.size();
  1289	  num_frames_ += chunk_feats.size();
  1290	//  LOG(INFO) << "Required " << num_requried_frames << " get "
  1291	//            << chunk_feats.size();
  1292	  int num_frames = cached_feature_.size() + chunk_feats.size();
  1293	  // The total frames should be big enough to get just one output
  1294	  if (num_frames >= right_context + 1) {
  1295	    // 1. Prepare libtorch required data, splice cached_feature_ and chunk_feats
  1296	    // The first dimension is for batchsize, which is 1.
  1297	    torch::Tensor feats =
  1298	        torch::zeros({1, num_frames, feature_dim}, torch::kFloat);
  1299	    for (size_t i = 0; i < cached_feature_.size(); ++i) {
  1300	      torch::Tensor row = torch::from_blob(cached_feature_[i].data(),
  1301	                                           {feature_dim}, torch::kFloat)
  1302	                              .clone();
  1303	      feats[0][i] = std::move(row);
  1304	    }
  1305	    for (size_t i = 0; i < chunk_feats.size(); ++i) {
  1306	      torch::Tensor row =
  1307	          torch::from_blob(chunk_feats[i].data(), {feature_dim}, torch::kFloat)
  1308	              .clone();
  1309	      feats[0][cached_feature_.size() + i] = std::move(row);
  1310	    }
  1311	
  1312	    Timer timer;
  1313	    // 2. Encoder chunk forward
  1314	    int requried_cache_size = opts_.chunk_size * opts_.num_left_chunks;
  1315	    torch::NoGradGuard no_grad;
  1316	    std::vector<torch::jit::IValue> inputs = {feats,
  1317	                                              offset_,
  1318	                                              requried_cache_size,
  1319	                                              subsampling_cache_,
  1320	                                              elayers_output_cache_,
  1321	                                              conformer_cnn_cache_};
  1322	    // Refer interfaces in com.demo.wenet/transformer/asr_model.py
  1323	    auto outputs = model_->torch_model()
  1324	                       ->get_method("forward_encoder_chunk")(inputs)
  1325	                       .toTuple()
  1326	                       ->elements();
  1327	    CHECK_EQ(outputs.size(), 4);
  1328	    torch::Tensor chunk_out = outputs[0].toTensor();
  1329	    subsampling_cache_ = outputs[1];
  1330	    elayers_output_cache_ = outputs[2];
  1331	    conformer_cnn_cache_ = outputs[3];
  1332	    offset_ += chunk_out.size(1);
  1333	
  1334	    // The first dimension of returned value is for batchsize, which is 1
  1335	    torch::Tensor ctc_log_probs = model_->torch_model()
  1336	                                      ->run_method("ctc_activation", chunk_out)
  1337	                                      .toTensor()[0];
  1338	    encoder_outs_.push_back(std::move(chunk_out));
  1339	    int forward_time = timer.Elapsed();
  1340	    timer.Reset();
  1341	    searcher_->Search(ctc_log_probs);
  1342	    int search_time = timer.Elapsed();
  1343	    VLOG(3) << "forward takes " << forward_time << " ms, search takes "
  1344	            << search_time << " ms";
  1345	    UpdateResult();
  1346	
  1347	    if (ctc_endpointer_->IsEndpoint(ctc_log_probs, DecodedSomething())) {
  1348	      LOG(INFO) << "Endpoint is detected at " << num_frames_;
  1349	      state = DecodeState::kEndpoint;
  1350	    }
  1351	
  1352	    // 3. Cache feature for next chunk
  1353	    if (state == DecodeState::kEndBatch) {
  1354	      // TODO(Binbin Zhang): Only deal the case when
  1355	      // chunk_feats.size() > cached_feature_size_ here, and it's consistent
  1356	      // with our current model, refine it later if we have new model or
  1357	      // new requirements
  1358	      CHECK(chunk_feats.size() >= cached_feature_size);
  1359	      cached_feature_.resize(cached_feature_size);
  1360	      for (int i = 0; i < cached_feature_size; ++i) {
  1361	        cached_feature_[i] = std::move(
  1362	            chunk_feats[chunk_feats.size() - cached_feature_size + i]);
  1363	      }
  1364	    }
  1365	  }
  1366	
  1367	  start_ = true;
  1368	  return state;
  1369	}
  1370	
  1371	void TorchAsrDecoder::UpdateResult(bool finish) {
  1372	  const auto& hypotheses = searcher_->Outputs();
  1373	  const auto& inputs = searcher_->Inputs();
  1374	  const auto& likelihood = searcher_->Likelihood();
  1375	  const auto& times = searcher_->Times();
  1376	  result_.clear();
  1377	
  1378	  CHECK_EQ(hypotheses.size(), likelihood.size());
  1379	  for (size_t i = 0; i < hypotheses.size(); i++) {
  1380	
  1381	    const std::vector<int>& hypothesis = hypotheses[i];
  1382	
  1383	    DecodeResult path;
  1384	    path.score = likelihood[i];
  1385	    int offset = global_frame_offset_ * feature_frame_shift_in_ms();
  1386	    for (size_t j = 0; j < hypothesis.size(); j++) {
  1387	      std::string word = symbol_table_->Find(hypothesis[j]);
  1388	      // A detailed explanation of this if-else branch can be found in
  1389	      // https://github.com/wenet-e2e/wenet/issues/583#issuecomment-907994058
  1390	      if (searcher_->Type() == kWfstBeamSearch) {
  1391	        path.sentence += (' ' + word);
  1392	      } else {
  1393	        path.sentence += (word);
  1394	      }
  1395	    }
  1396	
  1397	    // TimeStamp is only supported in final result
  1398	    // TimeStamp of the output of CtcWfstBeamSearch may be inaccurate due to
  1399	    // various FST operations when building the decoding graph. So here we use
  1400	    // time stamp of the input(e2e model unit), which is more accurate, and it
  1401	    // requires the symbol table of the e2e model used in training.
  1402	    if (unit_table_ != nullptr && finish) {
  1403	      const std::vector<int>& input = inputs[i];
  1404	      const std::vector<int>& time_stamp = times[i];
  1405	      CHECK_EQ(input.size(), time_stamp.size());
  1406	      for (size_t j = 0; j < input.size(); j++) {
  1407	        std::string word = unit_table_->Find(input[j]);
  1408	        int start = j > 0 ? ((time_stamp[j - 1] + time_stamp[j]) / 2 *
  1409	                             frame_shift_in_ms())
  1410	                          : 0;
  1411	        int end = j < input.size() - 1 ? ((time_stamp[j] + time_stamp[j + 1]) /
  1412	                                          2 * frame_shift_in_ms())
  1413	                                       : offset_ * frame_shift_in_ms();
  1414	        WordPiece word_piece(word, offset + start, offset + end);
  1415	        path.word_pieces.emplace_back(word_piece);
  1416	      }
  1417	    }
  1418	    path.sentence = post_processor_->Process(path.sentence, finish);
  1419	    result_.emplace_back(path);
  1420	  }
  1421	
  1422	  if (DecodedSomething()) {
  1423	    VLOG(1) << "Partial CTC result " << result_[0].sentence;
  1424	  }
  1425	}
  1426	
  1427	float TorchAsrDecoder::AttentionDecoderScore(const torch::Tensor& prob,
  1428	                                             const std::vector<int>& hyp,
  1429	                                             int eos) {
  1430	  float score = 0.0f;
  1431	  auto accessor = prob.accessor<float, 2>();
  1432	  for (size_t j = 0; j < hyp.size(); ++j) {
  1433	    score += accessor[j][hyp[j]];
  1434	  }
  1435	  score += accessor[hyp.size()][eos];
  1436	  return score;
  1437	}
  1438	
  1439	void TorchAsrDecoder::AttentionRescoring() {
  1440	  searcher_->FinalizeSearch();
  1441	  UpdateResult(true);
  1442	  // No need to do rescoring
  1443	  if (0.0 == opts_.rescoring_weight) {
  1444	    return;
  1445	  }
  1446	  // No encoder output
  1447	  if (encoder_outs_.size() == 0) {
  1448	    return;
  1449	  }
  1450	
  1451	  int sos = model_->sos();
  1452	  int eos = model_->eos();
  1453	  // Inputs() returns N-best input ids, which is the basic unit for rescoring
  1454	  // In CtcPrefixBeamSearch, inputs are the same to outputs
  1455	  const auto& hypotheses = searcher_->Inputs();
  1456	  int num_hyps = hypotheses.size();
  1457	  if (num_hyps <= 0) {
  1458	    return;
  1459	  }
  1460	
  1461	  torch::NoGradGuard no_grad;
  1462	  // Step 1: Prepare input for libtorch
  1463	  torch::Tensor hyps_length = torch::zeros({num_hyps}, torch::kLong);
  1464	  int max_hyps_len = 0;
  1465	  for (size_t i = 0; i < num_hyps; ++i) {
  1466	    int length = hypotheses[i].size() + 1;
  1467	    max_hyps_len = std::max(length, max_hyps_len);
  1468	    hyps_length[i] = static_cast<int64_t>(length);
  1469	  }
  1470	  torch::Tensor hyps_tensor =
  1471	      torch::zeros({num_hyps, max_hyps_len}, torch::kLong);
  1472	  for (size_t i = 0; i < num_hyps; ++i) {
  1473	    const std::vector<int>& hyp = hypotheses[i];
  1474	    hyps_tensor[i][0] = sos;
  1475	    for (size_t j = 0; j < hyp.size(); ++j) {
  1476	      hyps_tensor[i][j + 1] = hyp[j];
  1477	    }
  1478	  }
  1479	
  1480	  // Step 2: Forward attention decoder by hyps and corresponding encoder_outs_
  1481	  torch::Tensor encoder_out = torch::cat(encoder_outs_, 1);
  1482	  auto outputs =
  1483	      model_->torch_model()
  1484	          ->run_method("forward_attention_decoder", hyps_tensor, hyps_length,
  1485	                       encoder_out, opts_.reverse_weight)
  1486	          .toTuple()
  1487	          ->elements();
  1488	  auto probs = outputs[0].toTensor();
  1489	  auto r_probs = outputs[1].toTensor();
  1490	  CHECK_EQ(probs.size(0), num_hyps);
  1491	  CHECK_EQ(probs.size(1), max_hyps_len);
  1492	  // Step 3: Compute rescoring score
  1493	  for (size_t i = 0; i < num_hyps; ++i) {
  1494	    const std::vector<int>& hyp = hypotheses[i];
  1495	    float score = 0.0f;
  1496	    // left to right decoder score
  1497	    score = AttentionDecoderScore(probs[i], hyp, eos);
  1498	    // Optional: Used for right to left score
  1499	    float r_score = 0.0f;
  1500	    if (opts_.reverse_weight > 0) {
  1501	      // Right to left score
  1502	      CHECK_EQ(r_probs.size(0), num_hyps);
  1503	      CHECK_EQ(r_probs.size(1), max_hyps_len);
  1504	      std::vector<int> r_hyp(hyp.size());
  1505	      std::reverse_copy(hyp.begin(), hyp.end(), r_hyp.begin());
  1506	      // right to left decoder score
  1507	      r_score = AttentionDecoderScore(r_probs[i], r_hyp, eos);
  1508	    }
  1509	    // combined reverse attention score
  1510	    score =
  1511	        (score * (1 - opts_.reverse_weight)) + (r_score * opts_.reverse_weight);
  1512	    // combined ctc score
  1513	    result_[i].score =
  1514	        opts_.rescoring_weight * score + opts_.ctc_weight * result_[i].score;
  1515	  }
  1516	  std::sort(result_.begin(), result_.end(), DecodeResult::CompareFunc);
  1517	}
  1518	
  1519	}  // namespace com.demo.wenet
  1520	// Copyright 2020 Mobvoi Inc. All Rights Reserved.
  1521	// Author: binbinzhang@mobvoi.com (Binbin Zhang)
  1522	//         di.wu@mobvoi.com (Di Wu)
  1523	
  1524	#include "decoder/torch_asr_model.h"
  1525	
  1526	#include <memory>
  1527	#include <utility>
  1528	
  1529	#include "torch/script.h"
  1530	#include "torch/torch.h"
  1531	
  1532	namespace wenet {
  1533	
  1534	void TorchAsrModel::Read(const std::string& model_path, const int num_threads) {
  1535	  torch::jit::script::Module model = torch::jit::load(model_path);
  1536	  module_ = std::make_shared<TorchModule>(std::move(model));
  1537	  // For multi-thread performance
  1538	  at::set_num_threads(num_threads);
  1539	  torch::NoGradGuard no_grad;
  1540	  module_->eval();
  1541	  torch::jit::IValue o1 = module_->run_method("subsampling_rate");
  1542	  CHECK_EQ(o1.isInt(), true);
  1543	  subsampling_rate_ = o1.toInt();
  1544	  torch::jit::IValue o2 = module_->run_method("right_context");
  1545	  CHECK_EQ(o2.isInt(), true);
  1546	  right_context_ = o2.toInt();
  1547	  torch::jit::IValue o3 = module_->run_method("sos_symbol");
  1548	  CHECK_EQ(o3.isInt(), true);
  1549	  sos_ = o3.toInt();
  1550	  torch::jit::IValue o4 = module_->run_method("eos_symbol");
  1551	  CHECK_EQ(o4.isInt(), true);
  1552	  eos_ = o4.toInt();
  1553	  torch::jit::IValue o5 = module_->run_method("is_bidirectional_decoder");
  1554	  CHECK_EQ(o5.isBool(), true);
  1555	  is_bidirectional_decoder_ = o5.toBool();
  1556	
  1557	  LOG(INFO) << "torch model info subsampling_rate " << subsampling_rate_
  1558	            << " right context " << right_context_ << " sos " << sos_ << " eos "
  1559	            << eos_ << " is bidirectional decoder "
  1560	            << is_bidirectional_decoder_ << " num threads "
  1561	            << num_threads;
  1562	}
  1563	
  1564	}  // namespace com.demo.wenet
  1565	// Copyright (c) 2017 Personal (Binbin Zhang)
  1566	//
  1567	// Licensed under the Apache License, Version 2.0 (the "License");
  1568	// you may not use this file except in compliance with the License.
  1569	// You may obtain a copy of the License at
  1570	//
  1571	//   http://www.apache.org/licenses/LICENSE-2.0
  1572	//
  1573	// Unless required by applicable law or agreed to in writing, software
  1574	// distributed under the License is distributed on an "AS IS" BASIS,
  1575	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  1576	// See the License for the specific language governing permissions and
  1577	// limitations under the License.
  1578	
  1579	#include "frontend/feature_pipeline.h"
  1580	
  1581	#include <algorithm>
  1582	#include <utility>
  1583	
  1584	namespace wenet {
  1585	
  1586	FeaturePipeline::FeaturePipeline(const FeaturePipelineConfig& config)
  1587	    : config_(config),
  1588	      feature_dim_(config.num_bins),
  1589	      fbank_(config.num_bins, config.sample_rate, config.frame_length,
  1590	             config.frame_shift),
  1591	      num_frames_(0),
  1592	      input_finished_(false) {}
  1593	
  1594	void FeaturePipeline::AcceptWaveform(const std::vector<float>& wav) {
  1595	  std::vector<std::vector<float>> feats;
  1596	  std::vector<float> waves;
  1597	  waves.insert(waves.end(), remained_wav_.begin(), remained_wav_.end());
  1598	  waves.insert(waves.end(), wav.begin(), wav.end());
  1599	  int num_frames = fbank_.Compute(waves, &feats);
  1600	  for (size_t i = 0; i < feats.size(); ++i) {
  1601	    feature_queue_.Push(std::move(feats[i]));
  1602	  }
  1603	  num_frames_ += num_frames;
  1604	
  1605	  int left_samples = waves.size() - config_.frame_shift * num_frames;
  1606	  remained_wav_.resize(left_samples);
  1607	  std::copy(waves.begin() + config_.frame_shift * num_frames, waves.end(),
  1608	            remained_wav_.begin());
  1609	  // We are still adding wave, notify input is not finished
  1610	  finish_condition_.notify_one();
  1611	}
  1612	
  1613	void FeaturePipeline::set_input_finished() {
  1614	  CHECK(!input_finished_);
  1615	  {
  1616	    std::lock_guard<std::mutex> lock(mutex_);
  1617	    input_finished_ = true;
  1618	  }
  1619	  finish_condition_.notify_one();
  1620	}
  1621	
  1622	bool FeaturePipeline::ReadOne(std::vector<float>* feat) {
  1623	  if (!feature_queue_.Empty()) {
  1624	    *feat = std::move(feature_queue_.Pop());
  1625	    return true;
  1626	  } else {
  1627	    std::unique_lock<std::mutex> lock(mutex_);
  1628	    while (!input_finished_) {
  1629	      // This will release the lock and wait for notify_one()
  1630	      // from AcceptWaveform() or set_input_finished()
  1631	      finish_condition_.wait(lock);
  1632	      if (!feature_queue_.Empty()) {
  1633	        *feat = std::move(feature_queue_.Pop());
  1634	        return true;
  1635	      }
  1636	    }
  1637	    CHECK(input_finished_);
  1638	    CHECK(feature_queue_.Empty());
  1639	    return false;
  1640	  }
  1641	}
  1642	
  1643	bool FeaturePipeline::Read(int num_frames,
  1644	                           std::vector<std::vector<float>>* feats) {
  1645	  feats->clear();
  1646	  std::vector<float> feat;
  1647	  while (feats->size() < num_frames) {
  1648	    if (ReadOne(&feat)) {
  1649	      feats->push_back(std::move(feat));
  1650	    } else {
  1651	      return false;
  1652	    }
  1653	  }
  1654	  return true;
  1655	}
  1656	
  1657	void FeaturePipeline::Reset() {
  1658	  input_finished_ = false;
  1659	  num_frames_ = 0;
  1660	  remained_wav_.clear();
  1661	  feature_queue_.Clear();
  1662	}
  1663	
  1664	}  // namespace com.demo.wenet
  1665	// Copyright (c) 2016 HR
  1666	
  1667	#include <math.h>
  1668	#include <stdio.h>
  1669	#include <stdlib.h>
  1670	
  1671	#include "frontend/fft.h"
  1672	
  1673	namespace wenet {
  1674	
  1675	void make_sintbl(int n, float* sintbl) {
  1676	  int i, n2, n4, n8;
  1677	  float c, s, dc, ds, t;
  1678	
  1679	  n2 = n / 2;
  1680	  n4 = n / 4;
  1681	  n8 = n / 8;
  1682	  t = sin(M_PI / n);
  1683	  dc = 2 * t * t;
  1684	  ds = sqrt(dc * (2 - dc));
  1685	  t = 2 * dc;
  1686	  c = sintbl[n4] = 1;
  1687	  s = sintbl[0] = 0;
  1688	  for (i = 1; i < n8; ++i) {
  1689	    c -= dc;
  1690	    dc += t * c;
  1691	    s += ds;
  1692	    ds -= t * s;
  1693	    sintbl[i] = s;
  1694	    sintbl[n4 - i] = c;
  1695	  }
  1696	  if (n8 != 0) sintbl[n8] = sqrt(0.5);
  1697	  for (i = 0; i < n4; ++i) sintbl[n2 - i] = sintbl[i];
  1698	  for (i = 0; i < n2 + n4; ++i) sintbl[i + n2] = -sintbl[i];
  1699	}
  1700	
  1701	void make_bitrev(int n, int* bitrev) {
  1702	  int i, j, k, n2;
  1703	
  1704	  n2 = n / 2;
  1705	  i = j = 0;
  1706	  for (;;) {
  1707	    bitrev[i] = j;
  1708	    if (++i >= n) break;
  1709	    k = n2;
  1710	    while (k <= j) {
  1711	      j -= k;
  1712	      k /= 2;
  1713	    }
  1714	    j += k;
  1715	  }
  1716	}
  1717	
  1718	// bitrev: bit reversal table
  1719	// sintbl: trigonometric function table
  1720	// x:real part
  1721	// y:image part
  1722	// n: fft length
  1723	int fft(const int* bitrev, const float* sintbl, float* x, float* y, int n) {
  1724	  int i, j, k, ik, h, d, k2, n4, inverse;
  1725	  float t, s, c, dx, dy;
  1726	
  1727	  /* preparation */
  1728	  if (n < 0) {
  1729	    n = -n;
  1730	    inverse = 1; /* inverse transform */
  1731	  } else {
  1732	    inverse = 0;
  1733	  }
  1734	  n4 = n / 4;
  1735	  if (n == 0) {
  1736	    return 0;
  1737	  }
  1738	
  1739	  /* bit reversal */
  1740	  for (i = 0; i < n; ++i) {
  1741	    j = bitrev[i];
  1742	    if (i < j) {
  1743	      t = x[i];
  1744	      x[i] = x[j];
  1745	      x[j] = t;
  1746	      t = y[i];
  1747	      y[i] = y[j];
  1748	      y[j] = t;
  1749	    }
  1750	  }
  1751	
  1752	  /* transformation */
  1753	  for (k = 1; k < n; k = k2) {
  1754	    h = 0;
  1755	    k2 = k + k;
  1756	    d = n / k2;
  1757	    for (j = 0; j < k; ++j) {
  1758	      c = sintbl[h + n4];
  1759	      if (inverse)
  1760	        s = -sintbl[h];
  1761	      else
  1762	        s = sintbl[h];
  1763	      for (i = j; i < n; i += k2) {
  1764	        ik = i + k;
  1765	        dx = s * y[ik] + c * x[ik];
  1766	        dy = c * y[ik] - s * x[ik];
  1767	        x[ik] = x[i] - dx;
  1768	        x[i] += dx;
  1769	        y[ik] = y[i] - dy;
  1770	        y[i] += dy;
  1771	      }
  1772	      h += d;
  1773	    }
  1774	  }
  1775	  if (inverse) {
  1776	    /* divide by n in case of the inverse transformation */
  1777	    for (i = 0; i < n; ++i) {
  1778	      x[i] /= n;
  1779	      y[i] /= n;
  1780	    }
  1781	  }
  1782	  return 0; /* finished successfully */
  1783	}
  1784	
  1785	}  // namespace com.demo.wenet
  1786	// Copyright (c) 2021 Ximalaya Speech Team (Xiang Lyu)
  1787	//
  1788	// Licensed under the Apache License, Version 2.0 (the "License");
  1789	// you may not use this file except in compliance with the License.
  1790	// You may obtain a copy of the License at
  1791	//
  1792	//   http://www.apache.org/licenses/LICENSE-2.0
  1793	//
  1794	// Unless required by applicable law or agreed to in writing, software
  1795	// distributed under the License is distributed on an "AS IS" BASIS,
  1796	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  1797	// See the License for the specific language governing permissions and
  1798	// limitations under the License.
  1799	
  1800	#include "grpc/grpc_client.h"
  1801	
  1802	#include "utils/log.h"
  1803	
  1804	namespace wenet {
  1805	using grpc::Channel;
  1806	using grpc::ClientContext;
  1807	using grpc::ClientReaderWriter;
  1808	using grpc::Status;
  1809	using wenet::Request;
  1810	using wenet::Response;
  1811	
  1812	GrpcClient::GrpcClient(const std::string& host, int port, int nbest,
  1813	                       bool continuous_decoding)
  1814	    : host_(host),
  1815	      port_(port),
  1816	      nbest_(nbest),
  1817	      continuous_decoding_(continuous_decoding) {
  1818	  Connect();
  1819	  t_.reset(new std::thread(&GrpcClient::ReadLoopFunc, this));
  1820	}
  1821	
  1822	void GrpcClient::Connect() {
  1823	  channel_ = grpc::CreateChannel(host_ + ":" + std::to_string(port_),
  1824	                                 grpc::InsecureChannelCredentials());
  1825	  stub_ = ASR::NewStub(channel_);
  1826	  context_ = std::make_shared<ClientContext>();
  1827	  stream_ = stub_->Recognize(context_.get());
  1828	  request_ = std::make_shared<Request>();
  1829	  response_ = std::make_shared<Response>();
  1830	  request_->mutable_decode_config()->set_nbest_config(nbest_);
  1831	  request_->mutable_decode_config()->set_continuous_decoding_config(
  1832	      continuous_decoding_);
  1833	  stream_->Write(*request_);
  1834	}
  1835	
  1836	void GrpcClient::SendBinaryData(const void* data, size_t size) {
  1837	  const int16_t* pdata = reinterpret_cast<const int16_t*>(data);
  1838	  request_->set_audio_data(pdata, size);
  1839	  stream_->Write(*request_);
  1840	}
  1841	
  1842	void GrpcClient::ReadLoopFunc() {
  1843	  try {
  1844	    while (stream_->Read(response_.get())) {
  1845	      for (int i = 0; i < response_->nbest_size(); i++) {
  1846	        // you can also traverse wordpieces like demonstrated above
  1847	        LOG(INFO) << i + 1 << "best " << response_->nbest(i).sentence();
  1848	      }
  1849	      if (response_->status() != Response_Status_ok) {
  1850	        break;
  1851	      }
  1852	      if (response_->type() == Response_Type_speech_end) {
  1853	        done_ = true;
  1854	        break;
  1855	      }
  1856	    }
  1857	  } catch (std::exception const& e) {
  1858	    LOG(ERROR) << e.what();
  1859	  }
  1860	}
  1861	
  1862	void GrpcClient::Join() {
  1863	  stream_->WritesDone();
  1864	  t_->join();
  1865	  Status status = stream_->Finish();
  1866	  if (!status.ok()) {
  1867	    LOG(INFO) << "Recognize rpc failed.";
  1868	  }
  1869	}
  1870	}  // namespace com.demo.wenet
  1871	// Copyright (c) 2021 Ximalaya Speech Team (Xiang Lyu)
  1872	//
  1873	// Licensed under the Apache License, Version 2.0 (the "License");
  1874	// you may not use this file except in compliance with the License.
  1875	// You may obtain a copy of the License at
  1876	//
  1877	//   http://www.apache.org/licenses/LICENSE-2.0
  1878	//
  1879	// Unless required by applicable law or agreed to in writing, software
  1880	// distributed under the License is distributed on an "AS IS" BASIS,
  1881	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  1882	// See the License for the specific language governing permissions and
  1883	// limitations under the License.
  1884	
  1885	#include "grpc/grpc_server.h"
  1886	
  1887	namespace wenet {
  1888	
  1889	using grpc::ServerReaderWriter;
  1890	using wenet::Request;
  1891	using wenet::Response;
  1892	
  1893	GrpcConnectionHandler::GrpcConnectionHandler(
  1894	    ServerReaderWriter<Response, Request>* stream,
  1895	    std::shared_ptr<Request> request, std::shared_ptr<Response> response,
  1896	    std::shared_ptr<FeaturePipelineConfig> feature_config,
  1897	    std::shared_ptr<DecodeOptions> decode_config,
  1898	    std::shared_ptr<DecodeResource> decode_resource)
  1899	    : stream_(std::move(stream)),
  1900	      request_(std::move(request)),
  1901	      response_(std::move(response)),
  1902	      feature_config_(std::move(feature_config)),
  1903	      decode_config_(std::move(decode_config)),
  1904	      decode_resource_(std::move(decode_resource)) {}
  1905	
  1906	void GrpcConnectionHandler::OnSpeechStart() {
  1907	  LOG(INFO) << "Recieved speech start signal, start reading speech";
  1908	  got_start_tag_ = true;
  1909	  response_->set_status(Response::ok);
  1910	  response_->set_type(Response::server_ready);
  1911	  stream_->Write(*response_);
  1912	  feature_pipeline_ = std::make_shared<FeaturePipeline>(*feature_config_);
  1913	  decoder_ = std::make_shared<TorchAsrDecoder>(
  1914	      feature_pipeline_, decode_resource_, *decode_config_);
  1915	  // Start decoder thread
  1916	  decode_thread_ = std::make_shared<std::thread>(
  1917	      &GrpcConnectionHandler::DecodeThreadFunc, this);
  1918	}
  1919	
  1920	void GrpcConnectionHandler::OnSpeechEnd() {
  1921	  LOG(INFO) << "Recieved speech end signal";
  1922	  CHECK(feature_pipeline_ != nullptr);
  1923	  feature_pipeline_->set_input_finished();
  1924	  got_end_tag_ = true;
  1925	}
  1926	
  1927	void GrpcConnectionHandler::OnPartialResult() {
  1928	  LOG(INFO) << "Partial result";
  1929	  response_->set_status(Response::ok);
  1930	  response_->set_type(Response::partial_result);
  1931	  stream_->Write(*response_);
  1932	}
  1933	
  1934	void GrpcConnectionHandler::OnFinalResult() {
  1935	  LOG(INFO) << "Final result";
  1936	  response_->set_status(Response::ok);
  1937	  response_->set_type(Response::final_result);
  1938	  stream_->Write(*response_);
  1939	}
  1940	
  1941	void GrpcConnectionHandler::OnFinish() {
  1942	  // Send finish tag
  1943	  response_->set_status(Response::ok);
  1944	  response_->set_type(Response::speech_end);
  1945	  stream_->Write(*response_);
  1946	}
  1947	
  1948	void GrpcConnectionHandler::OnSpeechData() {
  1949	  // Read binary PCM data
  1950	  const int16_t* pdata =
  1951	      reinterpret_cast<const int16_t*>(request_->audio_data().c_str());
  1952	  int num_samples = request_->audio_data().length() / sizeof(int16_t);
  1953	  std::vector<float> pcm_data(num_samples);
  1954	  for (int i = 0; i < num_samples; i++) {
  1955	    pcm_data[i] = static_cast<float>(*pdata);
  1956	    pdata++;
  1957	  }
  1958	  VLOG(2) << "Recieved " << num_samples << " samples";
  1959	  CHECK(feature_pipeline_ != nullptr);
  1960	  CHECK(decoder_ != nullptr);
  1961	  feature_pipeline_->AcceptWaveform(pcm_data);
  1962	}
  1963	
  1964	void GrpcConnectionHandler::SerializeResult(bool finish) {
  1965	  for (const DecodeResult& path : decoder_->result()) {
  1966	    Response_OneBest* one_best_ = response_->add_nbest();
  1967	    one_best_->set_sentence(path.sentence);
  1968	    if (finish) {
  1969	      for (const WordPiece& word_piece : path.word_pieces) {
  1970	        Response_OnePiece* one_piece_ = one_best_->add_wordpieces();
  1971	        one_piece_->set_word(word_piece.word);
  1972	        one_piece_->set_start(word_piece.start);
  1973	        one_piece_->set_end(word_piece.end);
  1974	      }
  1975	    }
  1976	    if (response_->nbest_size() == nbest_) {
  1977	      break;
  1978	    }
  1979	  }
  1980	  return;
  1981	}
  1982	
  1983	void GrpcConnectionHandler::DecodeThreadFunc() {
  1984	  while (true) {
  1985	    DecodeState state = decoder_->Decode();
  1986	    response_->clear_status();
  1987	    response_->clear_type();
  1988	    response_->clear_nbest();
  1989	    if (state == DecodeState::kEndFeats) {
  1990	      decoder_->Rescoring();
  1991	      SerializeResult(true);
  1992	      OnFinalResult();
  1993	      OnFinish();
  1994	      stop_recognition_ = true;
  1995	      break;
  1996	    } else if (state == DecodeState::kEndpoint) {
  1997	      decoder_->Rescoring();
  1998	      SerializeResult(true);
  1999	      OnFinalResult();
  2000	      // If it's not continuous decoidng, continue to do next recognition
  2001	      // otherwise stop the recognition
  2002	      if (continuous_decoding_) {
  2003	        decoder_->ResetContinuousDecoding();
  2004	      } else {
  2005	        OnFinish();
  2006	        stop_recognition_ = true;
  2007	        break;
  2008	      }
  2009	    } else {
  2010	      if (decoder_->DecodedSomething()) {
  2011	        SerializeResult(false);
  2012	        OnPartialResult();
  2013	      }
  2014	    }
  2015	  }
  2016	}
  2017	
  2018	void GrpcConnectionHandler::operator()() {
  2019	  try {
  2020	    while (stream_->Read(request_.get())) {
  2021	      if (!got_start_tag_) {
  2022	        nbest_ = request_->decode_config().nbest_config();
  2023	        continuous_decoding_ =
  2024	            request_->decode_config().continuous_decoding_config();
  2025	        OnSpeechStart();
  2026	      } else {
  2027	        OnSpeechData();
  2028	      }
  2029	    }
  2030	    OnSpeechEnd();
  2031	    LOG(INFO) << "Read all pcm data, wait for decoding thread";
  2032	    if (decode_thread_ != nullptr) {
  2033	      decode_thread_->join();
  2034	    }
  2035	  } catch (std::exception const& e) {
  2036	    LOG(ERROR) << e.what();
  2037	  }
  2038	}
  2039	
  2040	Status GrpcServer::Recognize(ServerContext* context,
  2041	                             ServerReaderWriter<Response, Request>* stream) {
  2042	  LOG(INFO) << "Get Recognize request" << std::endl;
  2043	  auto request = std::make_shared<Request>();
  2044	  auto response = std::make_shared<Response>();
  2045	  GrpcConnectionHandler handler(stream, request, response, feature_config_,
  2046	                                decode_config_, decode_resource_);
  2047	  std::thread t(std::move(handler));
  2048	  t.join();
  2049	  return Status::OK;
  2050	}
  2051	}  // namespace com.demo.wenet
  2052	// base/io-funcs.cc
  2053	
  2054	// Copyright 2009-2011  Microsoft Corporation;  Saarland University
  2055	
  2056	// See ../../COPYING for clarification regarding multiple authors
  2057	//
  2058	// Licensed under the Apache License, Version 2.0 (the "License");
  2059	// you may not use this file except in compliance with the License.
  2060	// You may obtain a copy of the License at
  2061	
  2062	//  http://www.apache.org/licenses/LICENSE-2.0
  2063	
  2064	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  2065	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  2066	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  2067	// MERCHANTABLITY OR NON-INFRINGEMENT.
  2068	// See the Apache 2 License for the specific language governing permissions and
  2069	// limitations under the License.
  2070	
  2071	#include "base/io-funcs.h"
  2072	#include "base/kaldi-math.h"
  2073	
  2074	namespace kaldi {
  2075	
  2076	template <>
  2077	void WriteBasicType<bool>(std::ostream &os, bool binary, bool b) {
  2078	  os << (b ? "T" : "F");
  2079	  if (!binary) os << " ";
  2080	  if (os.fail()) KALDI_ERR << "Write failure in WriteBasicType<bool>";
  2081	}
  2082	
  2083	template <>
  2084	void ReadBasicType<bool>(std::istream &is, bool binary, bool *b) {
  2085	  KALDI_PARANOID_ASSERT(b != NULL);
  2086	  if (!binary) is >> std::ws;  // eat up whitespace.
  2087	  char c = is.peek();
  2088	  if (c == 'T') {
  2089	    *b = true;
  2090	    is.get();
  2091	  } else if (c == 'F') {
  2092	    *b = false;
  2093	    is.get();
  2094	  } else {
  2095	    KALDI_ERR << "Read failure in ReadBasicType<bool>, file position is "
  2096	              << is.tellg() << ", next char is " << CharToString(c);
  2097	  }
  2098	}
  2099	
  2100	template <>
  2101	void WriteBasicType<float>(std::ostream &os, bool binary, float f) {
  2102	  if (binary) {
  2103	    char c = sizeof(f);
  2104	    os.put(c);
  2105	    os.write(reinterpret_cast<const char *>(&f), sizeof(f));
  2106	  } else {
  2107	    os << f << " ";
  2108	  }
  2109	}
  2110	
  2111	template <>
  2112	void WriteBasicType<double>(std::ostream &os, bool binary, double f) {
  2113	  if (binary) {
  2114	    char c = sizeof(f);
  2115	    os.put(c);
  2116	    os.write(reinterpret_cast<const char *>(&f), sizeof(f));
  2117	  } else {
  2118	    os << f << " ";
  2119	  }
  2120	}
  2121	
  2122	template <>
  2123	void ReadBasicType<float>(std::istream &is, bool binary, float *f) {
  2124	  KALDI_PARANOID_ASSERT(f != NULL);
  2125	  if (binary) {
  2126	    double d;
  2127	    int c = is.peek();
  2128	    if (c == sizeof(*f)) {
  2129	      is.get();
  2130	      is.read(reinterpret_cast<char *>(f), sizeof(*f));
  2131	    } else if (c == sizeof(d)) {
  2132	      ReadBasicType(is, binary, &d);
  2133	      *f = d;
  2134	    } else {
  2135	      KALDI_ERR << "ReadBasicType: expected float, saw " << is.peek()
  2136	                << ", at file position " << is.tellg();
  2137	    }
  2138	  } else {
  2139	    is >> *f;
  2140	  }
  2141	  if (is.fail()) {
  2142	    KALDI_ERR << "ReadBasicType: failed to read, at file position "
  2143	              << is.tellg();
  2144	  }
  2145	}
  2146	
  2147	template <>
  2148	void ReadBasicType<double>(std::istream &is, bool binary, double *d) {
  2149	  KALDI_PARANOID_ASSERT(d != NULL);
  2150	  if (binary) {
  2151	    float f;
  2152	    int c = is.peek();
  2153	    if (c == sizeof(*d)) {
  2154	      is.get();
  2155	      is.read(reinterpret_cast<char *>(d), sizeof(*d));
  2156	    } else if (c == sizeof(f)) {
  2157	      ReadBasicType(is, binary, &f);
  2158	      *d = f;
  2159	    } else {
  2160	      KALDI_ERR << "ReadBasicType: expected float, saw " << is.peek()
  2161	                << ", at file position " << is.tellg();
  2162	    }
  2163	  } else {
  2164	    is >> *d;
  2165	  }
  2166	  if (is.fail()) {
  2167	    KALDI_ERR << "ReadBasicType: failed to read, at file position "
  2168	              << is.tellg();
  2169	  }
  2170	}
  2171	
  2172	void CheckToken(const char *token) {
  2173	  if (*token == '\0') KALDI_ERR << "Token is empty (not a valid token)";
  2174	  const char *orig_token = token;
  2175	  while (*token != '\0') {
  2176	    if (::isspace(*token))
  2177	      KALDI_ERR << "Token is not a valid token (contains space): '"
  2178	                << orig_token << "'";
  2179	    token++;
  2180	  }
  2181	}
  2182	
  2183	void WriteToken(std::ostream &os, bool binary, const char *token) {
  2184	  // binary mode is ignored;
  2185	  // we use space as termination character in either case.
  2186	  KALDI_ASSERT(token != NULL);
  2187	  CheckToken(token);  // make sure it's valid (can be read back)
  2188	  os << token << " ";
  2189	  if (os.fail()) {
  2190	    KALDI_ERR << "Write failure in WriteToken.";
  2191	  }
  2192	}
  2193	
  2194	int Peek(std::istream &is, bool binary) {
  2195	  if (!binary) is >> std::ws;  // eat up whitespace.
  2196	  return is.peek();
  2197	}
  2198	
  2199	void WriteToken(std::ostream &os, bool binary, const std::string &token) {
  2200	  WriteToken(os, binary, token.c_str());
  2201	}
  2202	
  2203	void ReadToken(std::istream &is, bool binary, std::string *str) {
  2204	  KALDI_ASSERT(str != NULL);
  2205	  if (!binary) is >> std::ws;  // consume whitespace.
  2206	  is >> *str;
  2207	  if (is.fail()) {
  2208	    KALDI_ERR << "ReadToken, failed to read token at file position "
  2209	              << is.tellg();
  2210	  }
  2211	  if (!isspace(is.peek())) {
  2212	    KALDI_ERR << "ReadToken, expected space after token, saw instead "
  2213	              << CharToString(static_cast<char>(is.peek()))
  2214	              << ", at file position " << is.tellg();
  2215	  }
  2216	  is.get();  // consume the space.
  2217	}
  2218	
  2219	int PeekToken(std::istream &is, bool binary) {
  2220	  if (!binary) is >> std::ws;  // consume whitespace.
  2221	  bool read_bracket;
  2222	  if (static_cast<char>(is.peek()) == '<') {
  2223	    read_bracket = true;
  2224	    is.get();
  2225	  } else {
  2226	    read_bracket = false;
  2227	  }
  2228	  int ans = is.peek();
  2229	  if (read_bracket) {
  2230	    if (!is.unget()) {
  2231	      // Clear the bad bit. This code can be (and is in fact) reached, since the
  2232	      // C++ standard does not guarantee that a call to unget() must succeed.
  2233	      is.clear();
  2234	    }
  2235	  }
  2236	  return ans;
  2237	}
  2238	
  2239	void ExpectToken(std::istream &is, bool binary, const char *token) {
  2240	  int pos_at_start = is.tellg();
  2241	  KALDI_ASSERT(token != NULL);
  2242	  CheckToken(token);           // make sure it's valid (can be read back)
  2243	  if (!binary) is >> std::ws;  // consume whitespace.
  2244	  std::string str;
  2245	  is >> str;
  2246	  is.get();  // consume the space.
  2247	  if (is.fail()) {
  2248	    KALDI_ERR << "Failed to read token [started at file position "
  2249	              << pos_at_start << "], expected " << token;
  2250	  }
  2251	  // The second half of the '&&' expression below is so that if we're expecting
  2252	  // "<Foo>", we will accept "Foo>" instead.  This is so that the model-reading
  2253	  // code will tolerate errors in PeekToken where is.unget() failed; search for
  2254	  // is.clear() in PeekToken() for an explanation.
  2255	  if (strcmp(str.c_str(), token) != 0 &&
  2256	      !(token[0] == '<' && strcmp(str.c_str(), token + 1) == 0)) {
  2257	    KALDI_ERR << "Expected token \"" << token << "\", got instead \"" << str
  2258	              << "\".";
  2259	  }
  2260	}
  2261	
  2262	void ExpectToken(std::istream &is, bool binary, const std::string &token) {
  2263	  ExpectToken(is, binary, token.c_str());
  2264	}
  2265	
  2266	}  // end namespace kaldi
  2267	// base/kaldi-error.cc
  2268	
  2269	// Copyright 2019 LAIX (Yi Sun)
  2270	// Copyright 2019 SmartAction LLC (kkm)
  2271	// Copyright 2016 Brno University of Technology (author: Karel Vesely)
  2272	// Copyright 2009-2011  Microsoft Corporation;  Lukas Burget;  Ondrej Glembek
  2273	
  2274	// See ../../COPYING for clarification regarding multiple authors
  2275	//
  2276	// Licensed under the Apache License, Version 2.0 (the "License");
  2277	// you may not use this file except in compliance with the License.
  2278	// You may obtain a copy of the License at
  2279	//
  2280	//  http://www.apache.org/licenses/LICENSE-2.0
  2281	//
  2282	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  2283	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  2284	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  2285	// MERCHANTABLITY OR NON-INFRINGEMENT.
  2286	// See the Apache 2 License for the specific language governing permissions and
  2287	// limitations under the License.
  2288	
  2289	#include "base/kaldi-error.h"
  2290	
  2291	#include <string>
  2292	
  2293	namespace kaldi {
  2294	
  2295	/***** GLOBAL VARIABLES FOR LOGGING *****/
  2296	
  2297	int32 g_kaldi_verbose_level = 0;
  2298	static std::string program_name;  // NOLINT
  2299	
  2300	void SetProgramName(const char *basename) {
  2301	  // Using the 'static std::string' for the program name is mostly harmless,
  2302	  // because (a) Kaldi logging is undefined before main(), and (b) no stdc++
  2303	  // string implementation has been found in the wild that would not be just
  2304	  // an empty string when zero-initialized but not yet constructed.
  2305	  program_name = basename;
  2306	}
  2307	
  2308	}  // namespace kaldi
  2309	// base/kaldi-math.cc
  2310	
  2311	// Copyright 2009-2011  Microsoft Corporation;  Yanmin Qian;
  2312	//                      Saarland University;  Jan Silovsky
  2313	
  2314	// See ../../COPYING for clarification regarding multiple authors
  2315	//
  2316	// Licensed under the Apache License, Version 2.0 (the "License");
  2317	// you may not use this file except in compliance with the License.
  2318	// You may obtain a copy of the License at
  2319	//
  2320	//  http://www.apache.org/licenses/LICENSE-2.0
  2321	//
  2322	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  2323	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  2324	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  2325	// MERCHANTABLITY OR NON-INFRINGEMENT.
  2326	// See the Apache 2 License for the specific language governing permissions and
  2327	// limitations under the License.
  2328	
  2329	#include "base/kaldi-math.h"
  2330	#ifndef _MSC_VER
  2331	#include <stdlib.h>
  2332	#include <unistd.h>
  2333	#endif
  2334	#include <string>
  2335	#include <mutex>
  2336	
  2337	namespace kaldi {
  2338	// These routines are tested in matrix/matrix-test.cc
  2339	
  2340	int32 RoundUpToNearestPowerOfTwo(int32 n) {
  2341	  KALDI_ASSERT(n > 0);
  2342	  n--;
  2343	  n |= n >> 1;
  2344	  n |= n >> 2;
  2345	  n |= n >> 4;
  2346	  n |= n >> 8;
  2347	  n |= n >> 16;
  2348	  return n+1;
  2349	}
  2350	
  2351	static std::mutex _RandMutex;
  2352	
  2353	int Rand(struct RandomState* state) {
  2354	#if !defined(_POSIX_THREAD_SAFE_FUNCTIONS)
  2355	  // On Windows and Cygwin, just call Rand()
  2356	  return rand();
  2357	#else
  2358	  if (state) {
  2359	    return rand_r(&(state->seed));
  2360	  } else {
  2361	    std::lock_guard<std::mutex> lock(_RandMutex);
  2362	    return rand();
  2363	  }
  2364	#endif
  2365	}
  2366	
  2367	RandomState::RandomState() {
  2368	  // we initialize it as Rand() + 27437 instead of just Rand(), because on some
  2369	  // systems, e.g. at the very least Mac OSX Yosemite and later, it seems to be
  2370	  // the case that rand_r when initialized with rand() will give you the exact
  2371	  // same sequence of numbers that rand() will give if you keep calling rand()
  2372	  // after that initial call.  This can cause problems with repeated sequences.
  2373	  // For example if you initialize two RandomState structs one after the other
  2374	  // without calling rand() in between, they would give you the same sequence
  2375	  // offset by one (if we didn't have the "+ 27437" in the code).  27437 is just
  2376	  // a randomly chosen prime number.
  2377	  seed = unsigned(Rand()) + 27437;
  2378	}
  2379	
  2380	bool WithProb(BaseFloat prob, struct RandomState* state) {
  2381	  KALDI_ASSERT(prob >= 0 && prob <= 1.1);  // prob should be <= 1.0,
  2382	  // but we allow slightly larger values that could arise from roundoff in
  2383	  // previous calculations.
  2384	  KALDI_COMPILE_TIME_ASSERT(RAND_MAX > 128 * 128);
  2385	  if (prob == 0) {
  2386	    return false;
  2387	  } else if (prob == 1.0) {
  2388	    return true;
  2389	  } else if (prob * RAND_MAX < 128.0) {
  2390	    // prob is very small but nonzero, and the "main algorithm"
  2391	    // wouldn't work that well.  So: with probability 1/128, we
  2392	    // return WithProb (prob * 128), else return false.
  2393	    if (Rand(state) < RAND_MAX / 128) {  // with probability 128...
  2394	      // Note: we know that prob * 128.0 < 1.0, because
  2395	      // we asserted RAND_MAX > 128 * 128.
  2396	      return WithProb(prob * 128.0);
  2397	    } else {
  2398	      return false;
  2399	    }
  2400	  } else {
  2401	    return (Rand(state) < ((RAND_MAX + static_cast<BaseFloat>(1.0)) * prob));
  2402	  }
  2403	}
  2404	
  2405	int32 RandInt(int32 min_val, int32 max_val, struct RandomState* state) {
  2406	  // This is not exact.
  2407	  KALDI_ASSERT(max_val >= min_val);
  2408	  if (max_val == min_val) return min_val;
  2409	
  2410	#ifdef _MSC_VER
  2411	  // RAND_MAX is quite small on Windows -> may need to handle larger numbers.
  2412	  if (RAND_MAX > (max_val-min_val)*8) {
  2413	        // *8 to avoid large inaccuracies in probability, from the modulus...
  2414	    return min_val +
  2415	      ((unsigned int)Rand(state) % (unsigned int)(max_val+1-min_val));
  2416	  } else {
  2417	    if ((unsigned int)(RAND_MAX*RAND_MAX) >
  2418	        (unsigned int)((max_val+1-min_val)*8)) {
  2419	        // *8 to avoid inaccuracies in probability, from the modulus...
  2420	      return min_val + ( (unsigned int)( (Rand(state)+RAND_MAX*Rand(state)))
  2421	                    % (unsigned int)(max_val+1-min_val));
  2422	    } else {
  2423	      KALDI_ERR << "rand_int failed because we do not support such large "
  2424	          "random numbers. (Extend this function).";
  2425	    }
  2426	  }
  2427	#else
  2428	  return min_val +
  2429	      (static_cast<int32>(Rand(state)) % static_cast<int32>(max_val+1-min_val));
  2430	#endif
  2431	}
  2432	
  2433	// Returns poisson-distributed random number.
  2434	// Take care: this takes time proportional
  2435	// to lambda.  Faster algorithms exist but are more complex.
  2436	int32 RandPoisson(float lambda, struct RandomState* state) {
  2437	  // Knuth's algorithm.
  2438	  KALDI_ASSERT(lambda >= 0);
  2439	  float L = expf(-lambda), p = 1.0;
  2440	  int32 k = 0;
  2441	  do {
  2442	    k++;
  2443	    float u = RandUniform(state);
  2444	    p *= u;
  2445	  } while (p > L);
  2446	  return k-1;
  2447	}
  2448	
  2449	void RandGauss2(float *a, float *b, RandomState *state) {
  2450	  KALDI_ASSERT(a);
  2451	  KALDI_ASSERT(b);
  2452	  float u1 = RandUniform(state);
  2453	  float u2 = RandUniform(state);
  2454	  u1 = sqrtf(-2.0f * logf(u1));
  2455	  u2 =  2.0f * M_PI * u2;
  2456	  *a = u1 * cosf(u2);
  2457	  *b = u1 * sinf(u2);
  2458	}
  2459	
  2460	void RandGauss2(double *a, double *b, RandomState *state) {
  2461	  KALDI_ASSERT(a);
  2462	  KALDI_ASSERT(b);
  2463	  float a_float, b_float;
  2464	  // Just because we're using doubles doesn't mean we need super-high-quality
  2465	  // random numbers, so we just use the floating-point version internally.
  2466	  RandGauss2(&a_float, &b_float, state);
  2467	  *a = a_float;
  2468	  *b = b_float;
  2469	}
  2470	
  2471	
  2472	}  // end namespace kaldi
  2473	// decoder/lattice-faster-decoder.cc
  2474	
  2475	// Copyright 2009-2012  Microsoft Corporation  Mirko Hannemann
  2476	//           2013-2018  Johns Hopkins University (Author: Daniel Povey)
  2477	//                2014  Guoguo Chen
  2478	//                2018  Zhehuai Chen
  2479	
  2480	// See ../../COPYING for clarification regarding multiple authors
  2481	//
  2482	// Licensed under the Apache License, Version 2.0 (the "License");
  2483	// you may not use this file except in compliance with the License.
  2484	// You may obtain a copy of the License at
  2485	//
  2486	//  http://www.apache.org/licenses/LICENSE-2.0
  2487	//
  2488	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  2489	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  2490	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  2491	// MERCHANTABLITY OR NON-INFRINGEMENT.
  2492	// See the Apache 2 License for the specific language governing permissions and
  2493	// limitations under the License.
  2494	
  2495	#include <algorithm>
  2496	#include <unordered_set>
  2497	
  2498	#include "decoder/lattice-faster-decoder.h"
  2499	// #include "lat/lattice-functions.h"
  2500	
  2501	namespace kaldi {
  2502	
  2503	// instantiate this class once for each thing you have to decode.
  2504	template <typename FST, typename Token>
  2505	LatticeFasterDecoderTpl<FST, Token>::LatticeFasterDecoderTpl(
  2506	    const FST &fst, const LatticeFasterDecoderConfig &config,
  2507	    const std::shared_ptr<wenet::ContextGraph> &context_graph)
  2508	    : fst_(&fst),
  2509	      delete_fst_(false),
  2510	      config_(config),
  2511	      num_toks_(0),
  2512	      context_graph_(context_graph) {
  2513	  config.Check();
  2514	  toks_.SetSize(
  2515	      1000);  // just so on the first frame we do something reasonable.
  2516	}
  2517	
  2518	template <typename FST, typename Token>
  2519	LatticeFasterDecoderTpl<FST, Token>::LatticeFasterDecoderTpl(
  2520	    const LatticeFasterDecoderConfig &config, FST *fst)
  2521	    : fst_(fst), delete_fst_(true), config_(config), num_toks_(0) {
  2522	  config.Check();
  2523	  toks_.SetSize(
  2524	      1000);  // just so on the first frame we do something reasonable.
  2525	}
  2526	
  2527	template <typename FST, typename Token>
  2528	LatticeFasterDecoderTpl<FST, Token>::~LatticeFasterDecoderTpl() {
  2529	  DeleteElems(toks_.Clear());
  2530	  ClearActiveTokens();
  2531	  if (delete_fst_) delete fst_;
  2532	}
  2533	
  2534	template <typename FST, typename Token>
  2535	void LatticeFasterDecoderTpl<FST, Token>::InitDecoding() {
  2536	  // clean up from last time:
  2537	  DeleteElems(toks_.Clear());
  2538	  cost_offsets_.clear();
  2539	  ClearActiveTokens();
  2540	  warned_ = false;
  2541	  num_toks_ = 0;
  2542	  decoding_finalized_ = false;
  2543	  final_costs_.clear();
  2544	  StateId start_state = fst_->Start();
  2545	  KALDI_ASSERT(start_state != fst::kNoStateId);
  2546	  active_toks_.resize(1);
  2547	  Token *start_tok = new Token(0.0, 0.0, NULL, NULL, NULL);
  2548	  active_toks_[0].toks = start_tok;
  2549	  toks_.Insert(start_state, start_tok);
  2550	  num_toks_++;
  2551	  ProcessNonemitting(config_.beam);
  2552	}
  2553	
  2554	// Returns true if any kind of traceback is available (not necessarily from
  2555	// a final state).  It should only very rarely return false; this indicates
  2556	// an unusual search error.
  2557	template <typename FST, typename Token>
  2558	bool LatticeFasterDecoderTpl<FST, Token>::Decode(
  2559	    DecodableInterface *decodable) {
  2560	  InitDecoding();
  2561	  // We use 1-based indexing for frames in this decoder (if you view it in
  2562	  // terms of features), but note that the decodable object uses zero-based
  2563	  // numbering, which we have to correct for when we call it.
  2564	  AdvanceDecoding(decodable);
  2565	  FinalizeDecoding();
  2566	
  2567	  // Returns true if we have any kind of traceback available (not necessarily
  2568	  // to the end state; query ReachedFinal() for that).
  2569	  return !active_toks_.empty() && active_toks_.back().toks != NULL;
  2570	}
  2571	
  2572	// Outputs an FST corresponding to the single best path through the lattice.
  2573	template <typename FST, typename Token>
  2574	bool LatticeFasterDecoderTpl<FST, Token>::GetBestPath(
  2575	    Lattice *olat, bool use_final_probs) const {
  2576	  Lattice raw_lat;
  2577	  GetRawLattice(&raw_lat, use_final_probs);
  2578	  ShortestPath(raw_lat, olat);
  2579	  return (olat->NumStates() != 0);
  2580	}
  2581	
  2582	// Outputs an FST corresponding to the raw, state-level lattice
  2583	template <typename FST, typename Token>
  2584	bool LatticeFasterDecoderTpl<FST, Token>::GetRawLattice(
  2585	    Lattice *ofst, bool use_final_probs) const {
  2586	  typedef LatticeArc Arc;
  2587	  typedef Arc::StateId StateId;
  2588	  typedef Arc::Weight Weight;
  2589	  typedef Arc::Label Label;
  2590	
  2591	  // Note: you can't use the old interface (Decode()) if you want to
  2592	  // get the lattice with use_final_probs = false.  You'd have to do
  2593	  // InitDecoding() and then AdvanceDecoding().
  2594	  if (decoding_finalized_ && !use_final_probs)
  2595	    KALDI_ERR << "You cannot call FinalizeDecoding() and then call "
  2596	              << "GetRawLattice() with use_final_probs == false";
  2597	
  2598	  unordered_map<Token *, BaseFloat> final_costs_local;
  2599	
  2600	  const unordered_map<Token *, BaseFloat> &final_costs =
  2601	      (decoding_finalized_ ? final_costs_ : final_costs_local);
  2602	  if (!decoding_finalized_ && use_final_probs)
  2603	    ComputeFinalCosts(&final_costs_local, NULL, NULL);
  2604	
  2605	  ofst->DeleteStates();
  2606	  // num-frames plus one (since frames are one-based, and we have
  2607	  // an extra frame for the start-state).
  2608	  int32 num_frames = active_toks_.size() - 1;
  2609	  KALDI_ASSERT(num_frames > 0);
  2610	  const int32 bucket_count = num_toks_ / 2 + 3;
  2611	  unordered_map<Token *, StateId> tok_map(bucket_count);
  2612	  // First create all states.
  2613	  std::vector<Token *> token_list;
  2614	  for (int32 f = 0; f <= num_frames; f++) {
  2615	    if (active_toks_[f].toks == NULL) {
  2616	      KALDI_WARN << "GetRawLattice: no tokens active on frame " << f
  2617	                 << ": not producing lattice.\n";
  2618	      return false;
  2619	    }
  2620	    TopSortTokens(active_toks_[f].toks, &token_list);
  2621	    for (size_t i = 0; i < token_list.size(); i++)
  2622	      if (token_list[i] != NULL) tok_map[token_list[i]] = ofst->AddState();
  2623	  }
  2624	  // The next statement sets the start state of the output FST.  Because we
  2625	  // topologically sorted the tokens, state zero must be the start-state.
  2626	  ofst->SetStart(0);
  2627	
  2628	  KALDI_VLOG(4) << "init:" << num_toks_ / 2 + 3
  2629	                << " buckets:" << tok_map.bucket_count()
  2630	                << " load:" << tok_map.load_factor()
  2631	                << " max:" << tok_map.max_load_factor();
  2632	  // Now create all arcs.
  2633	  for (int32 f = 0; f <= num_frames; f++) {
  2634	    for (Token *tok = active_toks_[f].toks; tok != NULL; tok = tok->next) {
  2635	      StateId cur_state = tok_map[tok];
  2636	      for (ForwardLinkT *l = tok->links; l != NULL; l = l->next) {
  2637	        typename unordered_map<Token *, StateId>::const_iterator iter =
  2638	            tok_map.find(l->next_tok);
  2639	        StateId nextstate = iter->second;
  2640	        KALDI_ASSERT(iter != tok_map.end());
  2641	        BaseFloat cost_offset = 0.0;
  2642	        if (l->ilabel != 0) {  // emitting..
  2643	          KALDI_ASSERT(f >= 0 && f < cost_offsets_.size());
  2644	          cost_offset = cost_offsets_[f];
  2645	        }
  2646	
  2647	        if (l->is_start_boundary) {
  2648	          StateId tmp = ofst->AddState();
  2649	          Arc arc(0, context_graph_->start_tag_id(), Weight(0, 0), tmp);
  2650	          ofst->AddArc(cur_state, arc);
  2651	          cur_state = tmp;
  2652	        }
  2653	        if (l->is_end_boundary) {
  2654	          StateId tmp = ofst->AddState();
  2655	          Arc arc(0, context_graph_->end_tag_id(), Weight(0, 0), nextstate);
  2656	          ofst->AddArc(tmp, arc);
  2657	          nextstate = tmp;
  2658	        }
  2659	
  2660	        Arc arc(l->ilabel, l->olabel,
  2661	                Weight(l->graph_cost, l->acoustic_cost - cost_offset),
  2662	                nextstate);
  2663	        ofst->AddArc(cur_state, arc);
  2664	      }
  2665	      if (f == num_frames) {
  2666	        if (use_final_probs && !final_costs.empty()) {
  2667	          typename unordered_map<Token *, BaseFloat>::const_iterator iter =
  2668	              final_costs.find(tok);
  2669	          if (iter != final_costs.end())
  2670	            ofst->SetFinal(cur_state, LatticeWeight(iter->second, 0));
  2671	        } else {
  2672	          ofst->SetFinal(cur_state, LatticeWeight::One());
  2673	        }
  2674	      }
  2675	    }
  2676	  }
  2677	
  2678	  fst::TopSort(ofst);
  2679	  return (ofst->NumStates() > 0);
  2680	}
  2681	
  2682	// This function is now deprecated, since now we do determinization from outside
  2683	// the LatticeFasterDecoder class.  Outputs an FST corresponding to the
  2684	// lattice-determinized lattice (one path per word sequence).
  2685	template <typename FST, typename Token>
  2686	bool LatticeFasterDecoderTpl<FST, Token>::GetLattice(
  2687	    CompactLattice *ofst, bool use_final_probs) const {
  2688	  Lattice raw_fst;
  2689	  GetRawLattice(&raw_fst, use_final_probs);
  2690	  Invert(&raw_fst);  // make it so word labels are on the input.
  2691	  // (in phase where we get backward-costs).
  2692	  fst::ILabelCompare<LatticeArc> ilabel_comp;
  2693	  ArcSort(&raw_fst, ilabel_comp);  // sort on ilabel; makes
  2694	  // lattice-determinization more efficient.
  2695	
  2696	  fst::DeterminizeLatticePrunedOptions lat_opts;
  2697	  lat_opts.max_mem = config_.det_opts.max_mem;
  2698	
  2699	  DeterminizeLatticePruned(raw_fst, config_.lattice_beam, ofst, lat_opts);
  2700	  raw_fst.DeleteStates();  // Free memory-- raw_fst no longer needed.
  2701	  Connect(ofst);           // Remove unreachable states... there might be
  2702	  // a small number of these, in some cases.
  2703	  // Note: if something went wrong and the raw lattice was empty,
  2704	  // we should still get to this point in the code without warnings or failures.
  2705	  return (ofst->NumStates() != 0);
  2706	}
  2707	
  2708	template <typename FST, typename Token>
  2709	void LatticeFasterDecoderTpl<FST, Token>::PossiblyResizeHash(size_t num_toks) {
  2710	  size_t new_sz = static_cast<size_t>(static_cast<BaseFloat>(num_toks) *
  2711	                                      config_.hash_ratio);
  2712	  if (new_sz > toks_.Size()) {
  2713	    toks_.SetSize(new_sz);
  2714	  }
  2715	}
  2716	
  2717	/*
  2718	  A note on the definition of extra_cost.
  2719	
  2720	  extra_cost is used in pruning tokens, to save memory.
  2721	
  2722	  extra_cost can be thought of as a beta (backward) cost assuming
  2723	  we had set the betas on currently-active tokens to all be the negative
  2724	  of the alphas for those tokens.  (So all currently active tokens would
  2725	  be on (tied) best paths).
  2726	
  2727	  We can use the extra_cost to accurately prune away tokens that we know will
  2728	  never appear in the lattice.  If the extra_cost is greater than the desired
  2729	  lattice beam, the token would provably never appear in the lattice, so we can
  2730	  prune away the token.
  2731	
  2732	  (Note: we don't update all the extra_costs every time we update a frame; we
  2733	  only do it every 'config_.prune_interval' frames).
  2734	 */
  2735	
  2736	// FindOrAddToken either locates a token in hash of toks_,
  2737	// or if necessary inserts a new, empty token (i.e. with no forward links)
  2738	// for the current frame.  [note: it's inserted if necessary into hash toks_
  2739	// and also into the singly linked list of tokens active on this frame
  2740	// (whose head is at active_toks_[frame]).
  2741	template <typename FST, typename Token>
  2742	inline typename LatticeFasterDecoderTpl<FST, Token>::Elem *
  2743	LatticeFasterDecoderTpl<FST, Token>::FindOrAddToken(StateId state,
  2744	                                                    int32 frame_plus_one,
  2745	                                                    BaseFloat tot_cost,
  2746	                                                    Token *backpointer,
  2747	                                                    bool *changed) {
  2748	  // Returns the Token pointer.  Sets "changed" (if non-NULL) to true
  2749	  // if the token was newly created or the cost changed.
  2750	  KALDI_ASSERT(frame_plus_one < active_toks_.size());
  2751	  Token *&toks = active_toks_[frame_plus_one].toks;
  2752	  Elem *e_found = toks_.Insert(state, NULL);
  2753	  if (e_found->val == NULL) {  // no such token presently.
  2754	    const BaseFloat extra_cost = 0.0;
  2755	    // tokens on the currently final frame have zero extra_cost
  2756	    // as any of them could end up
  2757	    // on the winning path.
  2758	    Token *new_tok = new Token(tot_cost, extra_cost, NULL, toks, backpointer);
  2759	    // NULL: no forward links yet
  2760	    toks = new_tok;
  2761	    num_toks_++;
  2762	    e_found->val = new_tok;
  2763	    if (changed) *changed = true;
  2764	    return e_found;
  2765	  } else {
  2766	    Token *tok = e_found->val;  // There is an existing Token for this state.
  2767	    if (tok->tot_cost > tot_cost) {  // replace old token
  2768	      tok->tot_cost = tot_cost;
  2769	      // SetBackpointer() just does tok->backpointer = backpointer in
  2770	      // the case where Token == BackpointerToken, else nothing.
  2771	      tok->SetBackpointer(backpointer);
  2772	      // we don't allocate a new token, the old stays linked in active_toks_
  2773	      // we only replace the tot_cost
  2774	      // in the current frame, there are no forward links (and no extra_cost)
  2775	      // only in ProcessNonemitting we have to delete forward links
  2776	      // in case we visit a state for the second time
  2777	      // those forward links, that lead to this replaced token before:
  2778	      // they remain and will hopefully be pruned later (PruneForwardLinks...)
  2779	      if (changed) *changed = true;
  2780	    } else {
  2781	      if (changed) *changed = false;
  2782	    }
  2783	    return e_found;
  2784	  }
  2785	}
  2786	
  2787	// prunes outgoing links for all tokens in active_toks_[frame]
  2788	// it's called by PruneActiveTokens
  2789	// all links, that have link_extra_cost > lattice_beam are pruned
  2790	template <typename FST, typename Token>
  2791	void LatticeFasterDecoderTpl<FST, Token>::PruneForwardLinks(
  2792	    int32 frame_plus_one, bool *extra_costs_changed, bool *links_pruned,
  2793	    BaseFloat delta) {
  2794	  // delta is the amount by which the extra_costs must change
  2795	  // If delta is larger,  we'll tend to go back less far
  2796	  //    toward the beginning of the file.
  2797	  // extra_costs_changed is set to true if extra_cost was changed for any token
  2798	  // links_pruned is set to true if any link in any token was pruned
  2799	
  2800	  *extra_costs_changed = false;
  2801	  *links_pruned = false;
  2802	  KALDI_ASSERT(frame_plus_one >= 0 && frame_plus_one < active_toks_.size());
  2803	  if (active_toks_[frame_plus_one].toks ==
  2804	      NULL) {  // empty list; should not happen.
  2805	    if (!warned_) {
  2806	      KALDI_WARN << "No tokens alive [doing pruning].. warning first "
  2807	                    "time only for each utterance\n";
  2808	      warned_ = true;
  2809	    }
  2810	  }
  2811	
  2812	  // We have to iterate until there is no more change, because the links
  2813	  // are not guaranteed to be in topological order.
  2814	  bool changed = true;  // difference new minus old extra cost >= delta ?
  2815	  while (changed) {
  2816	    changed = false;
  2817	    for (Token *tok = active_toks_[frame_plus_one].toks; tok != NULL;
  2818	         tok = tok->next) {
  2819	      ForwardLinkT *link, *prev_link = NULL;
  2820	      // will recompute tok_extra_cost for tok.
  2821	      BaseFloat tok_extra_cost = std::numeric_limits<BaseFloat>::infinity();
  2822	      // tok_extra_cost is the best (min) of link_extra_cost of outgoing links
  2823	      for (link = tok->links; link != NULL;) {
  2824	        // See if we need to excise this link...
  2825	        Token *next_tok = link->next_tok;
  2826	        BaseFloat link_extra_cost =
  2827	            next_tok->extra_cost +
  2828	            ((tok->tot_cost + link->acoustic_cost + link->graph_cost) -
  2829	             next_tok->tot_cost);  // difference in brackets is >= 0
  2830	        // link_exta_cost is the difference in score between the best paths
  2831	        // through link source state and through link destination state
  2832	        KALDI_ASSERT(link_extra_cost == link_extra_cost);  // check for NaN
  2833	        // the graph_cost contatins the context score
  2834	        // if it's the score of the backoff arc, it should be removed.
  2835	        if (link->context_score < 0) {
  2836	          link_extra_cost += link->context_score;
  2837	        }
  2838	        if (link_extra_cost > config_.lattice_beam) {      // excise link
  2839	          ForwardLinkT *next_link = link->next;
  2840	          if (prev_link != NULL)
  2841	            prev_link->next = next_link;
  2842	          else
  2843	            tok->links = next_link;
  2844	          delete link;
  2845	          link = next_link;  // advance link but leave prev_link the same.
  2846	          *links_pruned = true;
  2847	        } else {  // keep the link and update the tok_extra_cost if needed.
  2848	          if (link_extra_cost < 0.0) {  // this is just a precaution.
  2849	            // if (link_extra_cost < -0.01)
  2850	            //   KALDI_WARN << "Negative extra_cost: " << link_extra_cost;
  2851	            link_extra_cost = 0.0;
  2852	          }
  2853	          if (link_extra_cost < tok_extra_cost)
  2854	            tok_extra_cost = link_extra_cost;
  2855	          prev_link = link;  // move to next link
  2856	          link = link->next;
  2857	        }
  2858	      }  // for all outgoing links
  2859	      if (fabs(tok_extra_cost - tok->extra_cost) > delta)
  2860	        changed = true;  // difference new minus old is bigger than delta
  2861	      tok->extra_cost = tok_extra_cost;
  2862	      // will be +infinity or <= lattice_beam_.
  2863	      // infinity indicates, that no forward link survived pruning
  2864	    }  // for all Token on active_toks_[frame]
  2865	    if (changed) *extra_costs_changed = true;
  2866	
  2867	    // Note: it's theoretically possible that aggressive compiler
  2868	    // optimizations could cause an infinite loop here for small delta and
  2869	    // high-dynamic-range scores.
  2870	  }  // while changed
  2871	}
  2872	
  2873	// PruneForwardLinksFinal is a version of PruneForwardLinks that we call
  2874	// on the final frame.  If there are final tokens active, it uses
  2875	// the final-probs for pruning, otherwise it treats all tokens as final.
  2876	template <typename FST, typename Token>
  2877	void LatticeFasterDecoderTpl<FST, Token>::PruneForwardLinksFinal() {
  2878	  KALDI_ASSERT(!active_toks_.empty());
  2879	  int32 frame_plus_one = active_toks_.size() - 1;
  2880	
  2881	  if (active_toks_[frame_plus_one].toks ==
  2882	      NULL)  // empty list; should not happen.
  2883	    KALDI_WARN << "No tokens alive at end of file";
  2884	
  2885	  typedef typename unordered_map<Token *, BaseFloat>::const_iterator IterType;
  2886	  ComputeFinalCosts(&final_costs_, &final_relative_cost_, &final_best_cost_);
  2887	  decoding_finalized_ = true;
  2888	  // We call DeleteElems() as a nicety, not because it's really necessary;
  2889	  // otherwise there would be a time, after calling PruneTokensForFrame() on the
  2890	  // final frame, when toks_.GetList() or toks_.Clear() would contain pointers
  2891	  // to nonexistent tokens.
  2892	  DeleteElems(toks_.Clear());
  2893	
  2894	  // Now go through tokens on this frame, pruning forward links...  may have to
  2895	  // iterate a few times until there is no more change, because the list is not
  2896	  // in topological order.  This is a modified version of the code in
  2897	  // PruneForwardLinks, but here we also take account of the final-probs.
  2898	  bool changed = true;
  2899	  BaseFloat delta = 1.0e-05;
  2900	  while (changed) {
  2901	    changed = false;
  2902	    for (Token *tok = active_toks_[frame_plus_one].toks; tok != NULL;
  2903	         tok = tok->next) {
  2904	      ForwardLinkT *link, *prev_link = NULL;
  2905	      // will recompute tok_extra_cost.  It has a term in it that corresponds
  2906	      // to the "final-prob", so instead of initializing tok_extra_cost to
  2907	      // infinity below we set it to the difference between the
  2908	      // (score+final_prob) of this token, and the best such (score+final_prob).
  2909	      BaseFloat final_cost;
  2910	      if (final_costs_.empty()) {
  2911	        final_cost = 0.0;
  2912	      } else {
  2913	        IterType iter = final_costs_.find(tok);
  2914	        if (iter != final_costs_.end())
  2915	          final_cost = iter->second;
  2916	        else
  2917	          final_cost = std::numeric_limits<BaseFloat>::infinity();
  2918	      }
  2919	      BaseFloat tok_extra_cost = tok->tot_cost + final_cost - final_best_cost_;
  2920	      // tok_extra_cost will be a "min" over either directly being final, or
  2921	      // being indirectly final through other links, and the loop below may
  2922	      // decrease its value:
  2923	      for (link = tok->links; link != NULL;) {
  2924	        // See if we need to excise this link...
  2925	        Token *next_tok = link->next_tok;
  2926	        BaseFloat link_extra_cost =
  2927	            next_tok->extra_cost +
  2928	            ((tok->tot_cost + link->acoustic_cost + link->graph_cost) -
  2929	             next_tok->tot_cost);
  2930	        if (link_extra_cost > config_.lattice_beam) {  // excise link
  2931	          ForwardLinkT *next_link = link->next;
  2932	          if (prev_link != NULL)
  2933	            prev_link->next = next_link;
  2934	          else
  2935	            tok->links = next_link;
  2936	          delete link;
  2937	          link = next_link;  // advance link but leave prev_link the same.
  2938	        } else {  // keep the link and update the tok_extra_cost if needed.
  2939	          if (link_extra_cost < 0.0) {  // this is just a precaution.
  2940	            // if (link_extra_cost < -0.01)
  2941	            //   KALDI_WARN << "Negative extra_cost: " << link_extra_cost;
  2942	            link_extra_cost = 0.0;
  2943	          }
  2944	          if (link_extra_cost < tok_extra_cost)
  2945	            tok_extra_cost = link_extra_cost;
  2946	          prev_link = link;
  2947	          link = link->next;
  2948	        }
  2949	      }
  2950	      // prune away tokens worse than lattice_beam above best path.  This step
  2951	      // was not necessary in the non-final case because then, this case
  2952	      // showed up as having no forward links.  Here, the tok_extra_cost has
  2953	      // an extra component relating to the final-prob.
  2954	      if (tok_extra_cost > config_.lattice_beam)
  2955	        tok_extra_cost = std::numeric_limits<BaseFloat>::infinity();
  2956	      // to be pruned in PruneTokensForFrame
  2957	
  2958	      if (!ApproxEqual(tok->extra_cost, tok_extra_cost, delta)) changed = true;
  2959	      tok->extra_cost =
  2960	          tok_extra_cost;  // will be +infinity or <= lattice_beam_.
  2961	    }
  2962	  }  // while changed
  2963	}
  2964	
  2965	template <typename FST, typename Token>
  2966	BaseFloat LatticeFasterDecoderTpl<FST, Token>::FinalRelativeCost() const {
  2967	  if (!decoding_finalized_) {
  2968	    BaseFloat relative_cost;
  2969	    ComputeFinalCosts(NULL, &relative_cost, NULL);
  2970	    return relative_cost;
  2971	  } else {
  2972	    // we're not allowed to call that function if FinalizeDecoding() has
  2973	    // been called; return a cached value.
  2974	    return final_relative_cost_;
  2975	  }
  2976	}
  2977	
  2978	// Prune away any tokens on this frame that have no forward links.
  2979	// [we don't do this in PruneForwardLinks because it would give us
  2980	// a problem with dangling pointers].
  2981	// It's called by PruneActiveTokens if any forward links have been pruned
  2982	template <typename FST, typename Token>
  2983	void LatticeFasterDecoderTpl<FST, Token>::PruneTokensForFrame(
  2984	    int32 frame_plus_one) {
  2985	  KALDI_ASSERT(frame_plus_one >= 0 && frame_plus_one < active_toks_.size());
  2986	  Token *&toks = active_toks_[frame_plus_one].toks;
  2987	  if (toks == NULL) KALDI_WARN << "No tokens alive [doing pruning]";
  2988	  Token *tok, *next_tok, *prev_tok = NULL;
  2989	  for (tok = toks; tok != NULL; tok = next_tok) {
  2990	    next_tok = tok->next;
  2991	    if (tok->extra_cost == std::numeric_limits<BaseFloat>::infinity()) {
  2992	      // token is unreachable from end of graph; (no forward links survived)
  2993	      // excise tok from list and delete tok.
  2994	      if (prev_tok != NULL)
  2995	        prev_tok->next = tok->next;
  2996	      else
  2997	        toks = tok->next;
  2998	      delete tok;
  2999	      num_toks_--;
  3000	    } else {  // fetch next Token
  3001	      prev_tok = tok;
  3002	    }
  3003	  }
  3004	}
  3005	
  3006	// Go backwards through still-alive tokens, pruning them, starting not from
  3007	// the current frame (where we want to keep all tokens) but from the frame
  3008	// before that.  We go backwards through the frames and stop when we reach a
  3009	// point where the delta-costs are not changing (and the delta controls when we
  3010	// consider a cost to have "not changed").
  3011	template <typename FST, typename Token>
  3012	void LatticeFasterDecoderTpl<FST, Token>::PruneActiveTokens(BaseFloat delta) {
  3013	  int32 cur_frame_plus_one = NumFramesDecoded();
  3014	  int32 num_toks_begin = num_toks_;
  3015	  // The index "f" below represents a "frame plus one", i.e. you'd have to
  3016	  // subtract one to get the corresponding index for the decodable object.
  3017	  for (int32 f = cur_frame_plus_one - 1; f >= 0; f--) {
  3018	    // Reason why we need to prune forward links in this situation:
  3019	    // (1) we have never pruned them (new TokenList)
  3020	    // (2) we have not yet pruned the forward links to the next f,
  3021	    // after any of those tokens have changed their extra_cost.
  3022	    if (active_toks_[f].must_prune_forward_links) {
  3023	      bool extra_costs_changed = false, links_pruned = false;
  3024	      PruneForwardLinks(f, &extra_costs_changed, &links_pruned, delta);
  3025	      if (extra_costs_changed && f > 0)  // any token has changed extra_cost
  3026	        active_toks_[f - 1].must_prune_forward_links = true;
  3027	      if (links_pruned)  // any link was pruned
  3028	        active_toks_[f].must_prune_tokens = true;
  3029	      active_toks_[f].must_prune_forward_links = false;  // job done
  3030	    }
  3031	    if (f + 1 < cur_frame_plus_one &&  // except for last f (no forward links)
  3032	        active_toks_[f + 1].must_prune_tokens) {
  3033	      PruneTokensForFrame(f + 1);
  3034	      active_toks_[f + 1].must_prune_tokens = false;
  3035	    }
  3036	  }
  3037	  KALDI_VLOG(4) << "PruneActiveTokens: pruned tokens from " << num_toks_begin
  3038	                << " to " << num_toks_;
  3039	}
  3040	
  3041	template <typename FST, typename Token>
  3042	void LatticeFasterDecoderTpl<FST, Token>::ComputeFinalCosts(
  3043	    unordered_map<Token *, BaseFloat> *final_costs,
  3044	    BaseFloat *final_relative_cost, BaseFloat *final_best_cost) const {
  3045	  KALDI_ASSERT(!decoding_finalized_);
  3046	  if (final_costs != NULL) final_costs->clear();
  3047	  const Elem *final_toks = toks_.GetList();
  3048	  BaseFloat infinity = std::numeric_limits<BaseFloat>::infinity();
  3049	  BaseFloat best_cost = infinity, best_cost_with_final = infinity;
  3050	
  3051	  while (final_toks != NULL) {
  3052	    StateId state = final_toks->key;
  3053	    Token *tok = final_toks->val;
  3054	    const Elem *next = final_toks->tail;
  3055	    BaseFloat final_cost = fst_->Final(state).Value();
  3056	    BaseFloat cost = tok->tot_cost, cost_with_final = cost + final_cost;
  3057	    best_cost = std::min(cost, best_cost);
  3058	    best_cost_with_final = std::min(cost_with_final, best_cost_with_final);
  3059	    if (final_costs != NULL && final_cost != infinity)
  3060	      (*final_costs)[tok] = final_cost;
  3061	    final_toks = next;
  3062	  }
  3063	  if (final_relative_cost != NULL) {
  3064	    if (best_cost == infinity && best_cost_with_final == infinity) {
  3065	      // Likely this will only happen if there are no tokens surviving.
  3066	      // This seems the least bad way to handle it.
  3067	      *final_relative_cost = infinity;
  3068	    } else {
  3069	      *final_relative_cost = best_cost_with_final - best_cost;
  3070	    }
  3071	  }
  3072	  if (final_best_cost != NULL) {
  3073	    if (best_cost_with_final != infinity) {  // final-state exists.
  3074	      *final_best_cost = best_cost_with_final;
  3075	    } else {  // no final-state exists.
  3076	      *final_best_cost = best_cost;
  3077	    }
  3078	  }
  3079	}
  3080	
  3081	template <typename FST, typename Token>
  3082	void LatticeFasterDecoderTpl<FST, Token>::AdvanceDecoding(
  3083	    DecodableInterface *decodable, int32 max_num_frames) {
  3084	  if (std::is_same<FST, fst::Fst<fst::StdArc> >::value) {
  3085	    // if the type 'FST' is the FST base-class, then see if the FST type of fst_
  3086	    // is actually VectorFst or ConstFst.  If so, call the AdvanceDecoding()
  3087	    // function after casting *this to the more specific type.
  3088	    if (fst_->Type() == "const") {
  3089	      LatticeFasterDecoderTpl<fst::ConstFst<fst::StdArc>, Token> *this_cast =
  3090	          reinterpret_cast<
  3091	              LatticeFasterDecoderTpl<fst::ConstFst<fst::StdArc>, Token> *>(
  3092	              this);
  3093	      this_cast->AdvanceDecoding(decodable, max_num_frames);
  3094	      return;
  3095	    } else if (fst_->Type() == "vector") {
  3096	      LatticeFasterDecoderTpl<fst::VectorFst<fst::StdArc>, Token> *this_cast =
  3097	          reinterpret_cast<
  3098	              LatticeFasterDecoderTpl<fst::VectorFst<fst::StdArc>, Token> *>(
  3099	              this);
  3100	      this_cast->AdvanceDecoding(decodable, max_num_frames);
  3101	      return;
  3102	    }
  3103	  }
  3104	
  3105	  KALDI_ASSERT(!active_toks_.empty() && !decoding_finalized_ &&
  3106	               "You must call InitDecoding() before AdvanceDecoding");
  3107	  int32 num_frames_ready = decodable->NumFramesReady();
  3108	  // num_frames_ready must be >= num_frames_decoded, or else
  3109	  // the number of frames ready must have decreased (which doesn't
  3110	  // make sense) or the decodable object changed between calls
  3111	  // (which isn't allowed).
  3112	  KALDI_ASSERT(num_frames_ready >= NumFramesDecoded());
  3113	  int32 target_frames_decoded = num_frames_ready;
  3114	  if (max_num_frames >= 0)
  3115	    target_frames_decoded =
  3116	        std::min(target_frames_decoded, NumFramesDecoded() + max_num_frames);
  3117	  while (NumFramesDecoded() < target_frames_decoded) {
  3118	    if (NumFramesDecoded() % config_.prune_interval == 0) {
  3119	      PruneActiveTokens(config_.lattice_beam * config_.prune_scale);
  3120	    }
  3121	    BaseFloat cost_cutoff = ProcessEmitting(decodable);
  3122	    ProcessNonemitting(cost_cutoff);
  3123	  }
  3124	}
  3125	
  3126	// FinalizeDecoding() is a version of PruneActiveTokens that we call
  3127	// (optionally) on the final frame.  Takes into account the final-prob of
  3128	// tokens.  This function used to be called PruneActiveTokensFinal().
  3129	template <typename FST, typename Token>
  3130	void LatticeFasterDecoderTpl<FST, Token>::FinalizeDecoding() {
  3131	  int32 final_frame_plus_one = NumFramesDecoded();
  3132	  int32 num_toks_begin = num_toks_;
  3133	  // PruneForwardLinksFinal() prunes final frame (with final-probs), and
  3134	  // sets decoding_finalized_.
  3135	  PruneForwardLinksFinal();
  3136	  for (int32 f = final_frame_plus_one - 1; f >= 0; f--) {
  3137	    bool b1, b2;               // values not used.
  3138	    BaseFloat dontcare = 0.0;  // delta of zero means we must always update
  3139	    PruneForwardLinks(f, &b1, &b2, dontcare);
  3140	    PruneTokensForFrame(f + 1);
  3141	  }
  3142	  PruneTokensForFrame(0);
  3143	  KALDI_VLOG(4) << "pruned tokens from " << num_toks_begin << " to "
  3144	                << num_toks_;
  3145	}
  3146	
  3147	/// Gets the weight cutoff.  Also counts the active tokens.
  3148	template <typename FST, typename Token>
  3149	BaseFloat LatticeFasterDecoderTpl<FST, Token>::GetCutoff(
  3150	    Elem *list_head, size_t *tok_count, BaseFloat *adaptive_beam,
  3151	    Elem **best_elem) {
  3152	  BaseFloat best_weight = std::numeric_limits<BaseFloat>::infinity();
  3153	  // positive == high cost == bad.
  3154	  size_t count = 0;
  3155	  if (config_.max_active == std::numeric_limits<int32>::max() &&
  3156	      config_.min_active == 0) {
  3157	    for (Elem *e = list_head; e != NULL; e = e->tail, count++) {
  3158	      BaseFloat w = static_cast<BaseFloat>(e->val->tot_cost);
  3159	      if (w < best_weight) {
  3160	        best_weight = w;
  3161	        if (best_elem) *best_elem = e;
  3162	      }
  3163	    }
  3164	    if (tok_count != NULL) *tok_count = count;
  3165	    if (adaptive_beam != NULL) *adaptive_beam = config_.beam;
  3166	    return best_weight + config_.beam;
  3167	  } else {
  3168	    tmp_array_.clear();
  3169	    for (Elem *e = list_head; e != NULL; e = e->tail, count++) {
  3170	      BaseFloat w = e->val->tot_cost;
  3171	      tmp_array_.push_back(w);
  3172	      if (w < best_weight) {
  3173	        best_weight = w;
  3174	        if (best_elem) *best_elem = e;
  3175	      }
  3176	    }
  3177	    if (tok_count != NULL) *tok_count = count;
  3178	
  3179	    BaseFloat beam_cutoff = best_weight + config_.beam,
  3180	              min_active_cutoff = std::numeric_limits<BaseFloat>::infinity(),
  3181	              max_active_cutoff = std::numeric_limits<BaseFloat>::infinity();
  3182	
  3183	    KALDI_VLOG(6) << "Number of tokens active on frame " << NumFramesDecoded()
  3184	                  << " is " << tmp_array_.size();
  3185	
  3186	    if (tmp_array_.size() > static_cast<size_t>(config_.max_active)) {
  3187	      std::nth_element(tmp_array_.begin(),
  3188	                       tmp_array_.begin() + config_.max_active,
  3189	                       tmp_array_.end());
  3190	      max_active_cutoff = tmp_array_[config_.max_active];
  3191	    }
  3192	    if (max_active_cutoff < beam_cutoff) {  // max_active is tighter than beam.
  3193	      if (adaptive_beam)
  3194	        *adaptive_beam = max_active_cutoff - best_weight + config_.beam_delta;
  3195	      return max_active_cutoff;
  3196	    }
  3197	    if (tmp_array_.size() > static_cast<size_t>(config_.min_active)) {
  3198	      if (config_.min_active == 0) {
  3199	        min_active_cutoff = best_weight;
  3200	      } else {
  3201	        std::nth_element(
  3202	            tmp_array_.begin(), tmp_array_.begin() + config_.min_active,
  3203	            tmp_array_.size() > static_cast<size_t>(config_.max_active)
  3204	                ? tmp_array_.begin() + config_.max_active
  3205	                : tmp_array_.end());
  3206	        min_active_cutoff = tmp_array_[config_.min_active];
  3207	      }
  3208	    }
  3209	    if (min_active_cutoff > beam_cutoff) {  // min_active is looser than beam.
  3210	      if (adaptive_beam)
  3211	        *adaptive_beam = min_active_cutoff - best_weight + config_.beam_delta;
  3212	      return min_active_cutoff;
  3213	    } else {
  3214	      *adaptive_beam = config_.beam;
  3215	      return beam_cutoff;
  3216	    }
  3217	  }
  3218	}
  3219	
  3220	template <typename FST, typename Token>
  3221	BaseFloat LatticeFasterDecoderTpl<FST, Token>::ProcessEmitting(
  3222	    DecodableInterface *decodable) {
  3223	  KALDI_ASSERT(active_toks_.size() > 0);
  3224	  int32 frame =
  3225	      active_toks_.size() - 1;  // frame is the frame-index
  3226	                                // (zero-based) used to get likelihoods
  3227	                                // from the decodable object.
  3228	  active_toks_.resize(active_toks_.size() + 1);
  3229	
  3230	  Elem *final_toks =
  3231	      toks_.Clear();  // analogous to swapping prev_toks_ / cur_toks_
  3232	                      // in simple-decoder.h.   Removes the Elems from
  3233	                      // being indexed in the hash in toks_.
  3234	  Elem *best_elem = NULL;
  3235	  BaseFloat adaptive_beam;
  3236	  size_t tok_cnt;
  3237	  BaseFloat cur_cutoff =
  3238	      GetCutoff(final_toks, &tok_cnt, &adaptive_beam, &best_elem);
  3239	  KALDI_VLOG(6) << "Adaptive beam on frame " << NumFramesDecoded() << " is "
  3240	                << adaptive_beam;
  3241	
  3242	  PossiblyResizeHash(
  3243	      tok_cnt);  // This makes sure the hash is always big enough.
  3244	
  3245	  BaseFloat next_cutoff = std::numeric_limits<BaseFloat>::infinity();
  3246	  // pruning "online" before having seen all tokens
  3247	
  3248	  BaseFloat cost_offset = 0.0;  // Used to keep probabilities in a good
  3249	                                // dynamic range.
  3250	
  3251	  // First process the best token to get a hopefully
  3252	  // reasonably tight bound on the next cutoff.  The only
  3253	  // products of the next block are "next_cutoff" and "cost_offset".
  3254	  if (best_elem) {
  3255	    StateId state = best_elem->key;
  3256	    Token *tok = best_elem->val;
  3257	    cost_offset = -tok->tot_cost;
  3258	    for (fst::ArcIterator<FST> aiter(*fst_, state); !aiter.Done();
  3259	         aiter.Next()) {
  3260	      const Arc &arc = aiter.Value();
  3261	      if (arc.ilabel != 0) {  // propagate..
  3262	        BaseFloat new_weight = arc.weight.Value() + cost_offset -
  3263	                               decodable->LogLikelihood(frame, arc.ilabel) +
  3264	                               tok->tot_cost;
  3265	        if (new_weight + adaptive_beam < next_cutoff)
  3266	          next_cutoff = new_weight + adaptive_beam;
  3267	      }
  3268	    }
  3269	  }
  3270	
  3271	  // Store the offset on the acoustic likelihoods that we're applying.
  3272	  // Could just do cost_offsets_.push_back(cost_offset), but we
  3273	  // do it this way as it's more robust to future code changes.
  3274	  cost_offsets_.resize(frame + 1, 0.0);
  3275	  cost_offsets_[frame] = cost_offset;
  3276	
  3277	  // the tokens are now owned here, in final_toks, and the hash is empty.
  3278	  // 'owned' is a complex thing here; the point is we need to call DeleteElem
  3279	  // on each elem 'e' to let toks_ know we're done with them.
  3280	  for (Elem *e = final_toks, *e_tail; e != NULL; e = e_tail) {
  3281	    // loop this way because we delete "e" as we go.
  3282	    StateId state = e->key;
  3283	    Token *tok = e->val;
  3284	    if (tok->tot_cost <= cur_cutoff) {
  3285	      for (fst::ArcIterator<FST> aiter(*fst_, state); !aiter.Done();
  3286	           aiter.Next()) {
  3287	        const Arc &arc = aiter.Value();
  3288	        if (arc.ilabel != 0) {  // propagate..
  3289	          BaseFloat ac_cost = cost_offset -
  3290	                              decodable->LogLikelihood(frame, arc.ilabel),
  3291	                    graph_cost = arc.weight.Value(), cur_cost = tok->tot_cost,
  3292	                    tot_cost = cur_cost + ac_cost + graph_cost;
  3293	          if (tot_cost >= next_cutoff)
  3294	            continue;
  3295	          else if (tot_cost + adaptive_beam < next_cutoff)
  3296	            next_cutoff =
  3297	                tot_cost + adaptive_beam;  // prune by best current token
  3298	          // Note: the frame indexes into active_toks_ are one-based,
  3299	          // hence the + 1.
  3300	          Elem *e_next =
  3301	              FindOrAddToken(arc.nextstate, frame + 1, tot_cost, tok, NULL);
  3302	          // NULL: no change indicator needed
  3303	
  3304	          bool is_start_boundary = false;
  3305	          bool is_end_boundary = false;
  3306	          float context_score = 0;
  3307	          if (context_graph_) {
  3308	            if (arc.olabel == 0) {
  3309	              e_next->val->context_state = tok->context_state;
  3310	            } else {
  3311	              e_next->val->context_state = context_graph_->GetNextState(
  3312	                  tok->context_state, arc.olabel, &context_score,
  3313	                  &is_start_boundary, &is_end_boundary);
  3314	              graph_cost -= context_score;
  3315	            }
  3316	          }
  3317	          // Add ForwardLink from tok to next_tok (put on head of list
  3318	          // tok->links)
  3319	          tok->links = new ForwardLinkT(e_next->val, arc.ilabel, arc.olabel,
  3320	                                        graph_cost, ac_cost, is_start_boundary,
  3321	                                        is_end_boundary, tok->links);
  3322	          tok->links->context_score = context_score;
  3323	        }
  3324	      }  // for all arcs
  3325	    }
  3326	    e_tail = e->tail;
  3327	    toks_.Delete(e);  // delete Elem
  3328	  }
  3329	  return next_cutoff;
  3330	}
  3331	
  3332	// static inline
  3333	template <typename FST, typename Token>
  3334	void LatticeFasterDecoderTpl<FST, Token>::DeleteForwardLinks(Token *tok) {
  3335	  ForwardLinkT *l = tok->links, *m;
  3336	  while (l != NULL) {
  3337	    m = l->next;
  3338	    delete l;
  3339	    l = m;
  3340	  }
  3341	  tok->links = NULL;
  3342	}
  3343	
  3344	template <typename FST, typename Token>
  3345	void LatticeFasterDecoderTpl<FST, Token>::ProcessNonemitting(BaseFloat cutoff) {
  3346	  KALDI_ASSERT(!active_toks_.empty());
  3347	  int32 frame = static_cast<int32>(active_toks_.size()) - 2;
  3348	  // Note: "frame" is the time-index we just processed, or -1 if
  3349	  // we are processing the nonemitting transitions before the
  3350	  // first frame (called from InitDecoding()).
  3351	
  3352	  // Processes nonemitting arcs for one frame.  Propagates within toks_.
  3353	  // Note-- this queue structure is not very optimal as
  3354	  // it may cause us to process states unnecessarily (e.g. more than once),
  3355	  // but in the baseline code, turning this vector into a set to fix this
  3356	  // problem did not improve overall speed.
  3357	
  3358	  KALDI_ASSERT(queue_.empty());
  3359	
  3360	  if (toks_.GetList() == NULL) {
  3361	    if (!warned_) {
  3362	      KALDI_WARN << "Error, no surviving tokens: frame is " << frame;
  3363	      warned_ = true;
  3364	    }
  3365	  }
  3366	
  3367	  int before = 0, after = 0;
  3368	  for (const Elem *e = toks_.GetList(); e != NULL; e = e->tail) {
  3369	    StateId state = e->key;
  3370	    if (fst_->NumInputEpsilons(state) != 0) queue_.push_back(e);
  3371	    ++before;
  3372	  }
  3373	
  3374	  while (!queue_.empty()) {
  3375	    ++after;
  3376	    const Elem *e = queue_.back();
  3377	    queue_.pop_back();
  3378	
  3379	    StateId state = e->key;
  3380	    Token *tok =
  3381	        e->val;  // would segfault if e is a NULL pointer but this can't happen.
  3382	    BaseFloat cur_cost = tok->tot_cost;
  3383	    if (cur_cost >= cutoff)  // Don't bother processing successors.
  3384	      continue;
  3385	    // If "tok" has any existing forward links, delete them,
  3386	    // because we're about to regenerate them.  This is a kind
  3387	    // of non-optimality (remember, this is the simple decoder),
  3388	    // but since most states are emitting it's not a huge issue.
  3389	    DeleteForwardLinks(tok);  // necessary when re-visiting
  3390	    tok->links = NULL;
  3391	    for (fst::ArcIterator<FST> aiter(*fst_, state); !aiter.Done();
  3392	         aiter.Next()) {
  3393	      const Arc &arc = aiter.Value();
  3394	      if (arc.ilabel == 0) {  // propagate nonemitting only...
  3395	        BaseFloat graph_cost = arc.weight.Value(),
  3396	                  tot_cost = cur_cost + graph_cost;
  3397	        if (tot_cost < cutoff) {
  3398	          bool changed;
  3399	
  3400	          Elem *e_new =
  3401	              FindOrAddToken(arc.nextstate, frame + 1, tot_cost, tok, &changed);
  3402	
  3403	          bool is_start_boundary = false;
  3404	          bool is_end_boundary = false;
  3405	          float context_score = 0;
  3406	          if (context_graph_) {
  3407	            if (arc.olabel == 0) {
  3408	              e_new->val->context_state = tok->context_state;
  3409	            } else {
  3410	              e_new->val->context_state = context_graph_->GetNextState(
  3411	                  tok->context_state, arc.olabel, &context_score,
  3412	                  &is_start_boundary, &is_end_boundary);
  3413	              graph_cost -= context_score;
  3414	            }
  3415	          }
  3416	
  3417	          tok->links =
  3418	              new ForwardLinkT(e_new->val, 0, arc.olabel, graph_cost, 0,
  3419	                               is_start_boundary, is_end_boundary, tok->links);
  3420	          tok->links->context_score = context_score;
  3421	
  3422	          // "changed" tells us whether the new token has a different
  3423	          // cost from before, or is new [if so, add into queue].
  3424	          if (changed && fst_->NumInputEpsilons(arc.nextstate) != 0)
  3425	            queue_.push_back(e_new);
  3426	        }
  3427	      }
  3428	    }  // for all arcs
  3429	  }    // while queue not empty
  3430	  KALDI_VLOG(3) << "ProcessNonemitting " << before << " " << after;
  3431	}
  3432	
  3433	template <typename FST, typename Token>
  3434	void LatticeFasterDecoderTpl<FST, Token>::DeleteElems(Elem *list) {
  3435	  for (Elem *e = list, *e_tail; e != NULL; e = e_tail) {
  3436	    e_tail = e->tail;
  3437	    toks_.Delete(e);
  3438	  }
  3439	}
  3440	
  3441	template <typename FST, typename Token>
  3442	void LatticeFasterDecoderTpl<
  3443	    FST, Token>::ClearActiveTokens() {  // a cleanup routine, at utt end/begin
  3444	  for (size_t i = 0; i < active_toks_.size(); i++) {
  3445	    // Delete all tokens alive on this frame, and any forward
  3446	    // links they may have.
  3447	    for (Token *tok = active_toks_[i].toks; tok != NULL;) {
  3448	      DeleteForwardLinks(tok);
  3449	      Token *next_tok = tok->next;
  3450	      delete tok;
  3451	      num_toks_--;
  3452	      tok = next_tok;
  3453	    }
  3454	  }
  3455	  active_toks_.clear();
  3456	  KALDI_ASSERT(num_toks_ == 0);
  3457	}
  3458	
  3459	// static
  3460	template <typename FST, typename Token>
  3461	void LatticeFasterDecoderTpl<FST, Token>::TopSortTokens(
  3462	    Token *tok_list, std::vector<Token *> *topsorted_list) {
  3463	  unordered_map<Token *, int32> token2pos;
  3464	  using std::unordered_set;
  3465	  typedef typename unordered_map<Token *, int32>::iterator IterType;
  3466	  int32 num_toks = 0;
  3467	  for (Token *tok = tok_list; tok != NULL; tok = tok->next) num_toks++;
  3468	  int32 cur_pos = 0;
  3469	  // We assign the tokens numbers num_toks - 1, ... , 2, 1, 0.
  3470	  // This is likely to be in closer to topological order than
  3471	  // if we had given them ascending order, because of the way
  3472	  // new tokens are put at the front of the list.
  3473	  for (Token *tok = tok_list; tok != NULL; tok = tok->next)
  3474	    token2pos[tok] = num_toks - ++cur_pos;
  3475	
  3476	  unordered_set<Token *> reprocess;
  3477	
  3478	  for (IterType iter = token2pos.begin(); iter != token2pos.end(); ++iter) {
  3479	    Token *tok = iter->first;
  3480	    int32 pos = iter->second;
  3481	    for (ForwardLinkT *link = tok->links; link != NULL; link = link->next) {
  3482	      if (link->ilabel == 0) {
  3483	        // We only need to consider epsilon links, since non-epsilon links
  3484	        // transition between frames and this function only needs to sort a list
  3485	        // of tokens from a single frame.
  3486	        IterType following_iter = token2pos.find(link->next_tok);
  3487	        if (following_iter != token2pos.end()) {  // another token on this
  3488	                                                  // frame, so must consider it.
  3489	          int32 next_pos = following_iter->second;
  3490	          if (next_pos < pos) {  // reassign the position of the next Token.
  3491	            following_iter->second = cur_pos++;
  3492	            reprocess.insert(link->next_tok);
  3493	          }
  3494	        }
  3495	      }
  3496	    }
  3497	    // In case we had previously assigned this token to be reprocessed, we can
  3498	    // erase it from that set because it's "happy now" (we just processed it).
  3499	    reprocess.erase(tok);
  3500	  }
  3501	
  3502	  size_t max_loop = 1000000,
  3503	         loop_count;  // max_loop is to detect epsilon cycles.
  3504	  for (loop_count = 0; !reprocess.empty() && loop_count < max_loop;
  3505	       ++loop_count) {
  3506	    std::vector<Token *> reprocess_vec;
  3507	    for (typename unordered_set<Token *>::iterator iter = reprocess.begin();
  3508	         iter != reprocess.end(); ++iter)
  3509	      reprocess_vec.push_back(*iter);
  3510	    reprocess.clear();
  3511	    for (typename std::vector<Token *>::iterator iter = reprocess_vec.begin();
  3512	         iter != reprocess_vec.end(); ++iter) {
  3513	      Token *tok = *iter;
  3514	      int32 pos = token2pos[tok];
  3515	      // Repeat the processing we did above (for comments, see above).
  3516	      for (ForwardLinkT *link = tok->links; link != NULL; link = link->next) {
  3517	        if (link->ilabel == 0) {
  3518	          IterType following_iter = token2pos.find(link->next_tok);
  3519	          if (following_iter != token2pos.end()) {
  3520	            int32 next_pos = following_iter->second;
  3521	            if (next_pos < pos) {
  3522	              following_iter->second = cur_pos++;
  3523	              reprocess.insert(link->next_tok);
  3524	            }
  3525	          }
  3526	        }
  3527	      }
  3528	    }
  3529	  }
  3530	  KALDI_ASSERT(loop_count < max_loop &&
  3531	               "Epsilon loops exist in your decoding "
  3532	               "graph (this is not allowed!)");
  3533	
  3534	  topsorted_list->clear();
  3535	  topsorted_list->resize(cur_pos,
  3536	                         NULL);  // create a list with NULLs in between.
  3537	  for (IterType iter = token2pos.begin(); iter != token2pos.end(); ++iter)
  3538	    (*topsorted_list)[iter->second] = iter->first;
  3539	}
  3540	
  3541	// Instantiate the template for the combination of token types and FST types
  3542	// that we'll need.
  3543	template class LatticeFasterDecoderTpl<fst::Fst<fst::StdArc>,
  3544	                                       decoder::StdToken>;
  3545	template class LatticeFasterDecoderTpl<fst::VectorFst<fst::StdArc>,
  3546	                                       decoder::StdToken>;
  3547	template class LatticeFasterDecoderTpl<fst::ConstFst<fst::StdArc>,
  3548	                                       decoder::StdToken>;
  3549	
  3550	// template class LatticeFasterDecoderTpl<fst::ConstGrammarFst,
  3551	// decoder::StdToken>; template class
  3552	// LatticeFasterDecoderTpl<fst::VectorGrammarFst, decoder::StdToken>;
  3553	
  3554	template class LatticeFasterDecoderTpl<fst::Fst<fst::StdArc>,
  3555	                                       decoder::BackpointerToken>;
  3556	template class LatticeFasterDecoderTpl<fst::VectorFst<fst::StdArc>,
  3557	                                       decoder::BackpointerToken>;
  3558	template class LatticeFasterDecoderTpl<fst::ConstFst<fst::StdArc>,
  3559	                                       decoder::BackpointerToken>;
  3560	// template class LatticeFasterDecoderTpl<fst::ConstGrammarFst,
  3561	// decoder::BackpointerToken>; template class
  3562	// LatticeFasterDecoderTpl<fst::VectorGrammarFst, decoder::BackpointerToken>;
  3563	
  3564	}  // end namespace kaldi.
  3565	// decoder/lattice-faster-online-decoder.cc
  3566	
  3567	// Copyright 2009-2012  Microsoft Corporation  Mirko Hannemann
  3568	//           2013-2014  Johns Hopkins University (Author: Daniel Povey)
  3569	//                2014  Guoguo Chen
  3570	//                2014  IMSL, PKU-HKUST (author: Wei Shi)
  3571	//                2018  Zhehuai Chen
  3572	
  3573	// See ../../COPYING for clarification regarding multiple authors
  3574	//
  3575	// Licensed under the Apache License, Version 2.0 (the "License");
  3576	// you may not use this file except in compliance with the License.
  3577	// You may obtain a copy of the License at
  3578	//
  3579	//  http://www.apache.org/licenses/LICENSE-2.0
  3580	//
  3581	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  3582	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  3583	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  3584	// MERCHANTABLITY OR NON-INFRINGEMENT.
  3585	// See the Apache 2 License for the specific language governing permissions and
  3586	// limitations under the License.
  3587	
  3588	// see note at the top of lattice-faster-decoder.cc, about how to maintain this
  3589	// file in sync with lattice-faster-decoder.cc
  3590	
  3591	#include <limits>
  3592	#include <queue>
  3593	#include <unordered_map>
  3594	#include <utility>
  3595	
  3596	#include "decoder/lattice-faster-online-decoder.h"
  3597	
  3598	namespace kaldi {
  3599	
  3600	template <typename FST>
  3601	bool LatticeFasterOnlineDecoderTpl<FST>::TestGetBestPath(
  3602	    bool use_final_probs) const {
  3603	  Lattice lat1;
  3604	  {
  3605	    Lattice raw_lat;
  3606	    this->GetRawLattice(&raw_lat, use_final_probs);
  3607	    ShortestPath(raw_lat, &lat1);
  3608	  }
  3609	  Lattice lat2;
  3610	  GetBestPath(&lat2, use_final_probs);
  3611	  BaseFloat delta = 0.1;
  3612	  int32 num_paths = 1;
  3613	  if (!fst::RandEquivalent(lat1, lat2, num_paths, delta, rand())) {
  3614	    KALDI_WARN << "Best-path test failed";
  3615	    return false;
  3616	  } else {
  3617	    return true;
  3618	  }
  3619	}
  3620	
  3621	// Outputs an FST corresponding to the single best path through the lattice.
  3622	template <typename FST>
  3623	bool LatticeFasterOnlineDecoderTpl<FST>::GetBestPath(
  3624	    Lattice *olat, bool use_final_probs) const {
  3625	  olat->DeleteStates();
  3626	  BaseFloat final_graph_cost;
  3627	  BestPathIterator iter = BestPathEnd(use_final_probs, &final_graph_cost);
  3628	  if (iter.Done()) return false;  // would have printed warning.
  3629	  StateId state = olat->AddState();
  3630	  olat->SetFinal(state, LatticeWeight(final_graph_cost, 0.0));
  3631	  while (!iter.Done()) {
  3632	    LatticeArc arc;
  3633	    iter = TraceBackBestPath(iter, &arc);
  3634	    arc.nextstate = state;
  3635	    StateId new_state = olat->AddState();
  3636	    olat->AddArc(new_state, arc);
  3637	    state = new_state;
  3638	  }
  3639	  olat->SetStart(state);
  3640	  return true;
  3641	}
  3642	
  3643	template <typename FST>
  3644	typename LatticeFasterOnlineDecoderTpl<FST>::BestPathIterator
  3645	LatticeFasterOnlineDecoderTpl<FST>::BestPathEnd(
  3646	    bool use_final_probs, BaseFloat *final_cost_out) const {
  3647	  if (this->decoding_finalized_ && !use_final_probs)
  3648	    KALDI_ERR << "You cannot call FinalizeDecoding() and then call "
  3649	              << "BestPathEnd() with use_final_probs == false";
  3650	  KALDI_ASSERT(this->NumFramesDecoded() > 0 &&
  3651	               "You cannot call BestPathEnd if no frames were decoded.");
  3652	
  3653	  unordered_map<Token *, BaseFloat> final_costs_local;
  3654	
  3655	  const unordered_map<Token *, BaseFloat> &final_costs =
  3656	      (this->decoding_finalized_ ? this->final_costs_ : final_costs_local);
  3657	  if (!this->decoding_finalized_ && use_final_probs)
  3658	    this->ComputeFinalCosts(&final_costs_local, NULL, NULL);
  3659	
  3660	  // Singly linked list of tokens on last frame (access list through "next"
  3661	  // pointer).
  3662	  BaseFloat best_cost = std::numeric_limits<BaseFloat>::infinity();
  3663	  BaseFloat best_final_cost = 0;
  3664	  Token *best_tok = NULL;
  3665	  for (Token *tok = this->active_toks_.back().toks; tok != NULL;
  3666	       tok = tok->next) {
  3667	    BaseFloat cost = tok->tot_cost, final_cost = 0.0;
  3668	    if (use_final_probs && !final_costs.empty()) {
  3669	      // if we are instructed to use final-probs, and any final tokens were
  3670	      // active on final frame, include the final-prob in the cost of the token.
  3671	      typename unordered_map<Token *, BaseFloat>::const_iterator iter =
  3672	          final_costs.find(tok);
  3673	      if (iter != final_costs.end()) {
  3674	        final_cost = iter->second;
  3675	        cost += final_cost;
  3676	      } else {
  3677	        cost = std::numeric_limits<BaseFloat>::infinity();
  3678	      }
  3679	    }
  3680	    if (cost < best_cost) {
  3681	      best_cost = cost;
  3682	      best_tok = tok;
  3683	      best_final_cost = final_cost;
  3684	    }
  3685	  }
  3686	  if (best_tok ==
  3687	      NULL) {  // this should not happen, and is likely a code error or
  3688	    // caused by infinities in likelihoods, but I'm not making
  3689	    // it a fatal error for now.
  3690	    KALDI_WARN << "No final token found.";
  3691	  }
  3692	  if (final_cost_out) *final_cost_out = best_final_cost;
  3693	  return BestPathIterator(best_tok, this->NumFramesDecoded() - 1);
  3694	}
  3695	
  3696	template <typename FST>
  3697	typename LatticeFasterOnlineDecoderTpl<FST>::BestPathIterator
  3698	LatticeFasterOnlineDecoderTpl<FST>::TraceBackBestPath(BestPathIterator iter,
  3699	                                                      LatticeArc *oarc) const {
  3700	  KALDI_ASSERT(!iter.Done() && oarc != NULL);
  3701	  Token *tok = static_cast<Token *>(iter.tok);
  3702	  int32 cur_t = iter.frame, step_t = 0;
  3703	  if (tok->backpointer != NULL) {
  3704	    // retrieve the correct forward link(with the best link cost)
  3705	    BaseFloat best_cost = std::numeric_limits<BaseFloat>::infinity();
  3706	    ForwardLinkT *link;
  3707	    for (link = tok->backpointer->links; link != NULL; link = link->next) {
  3708	      if (link->next_tok == tok) {  // this is a link to "tok"
  3709	        BaseFloat graph_cost = link->graph_cost,
  3710	                  acoustic_cost = link->acoustic_cost;
  3711	        BaseFloat cost = graph_cost + acoustic_cost;
  3712	        if (cost < best_cost) {
  3713	          oarc->ilabel = link->ilabel;
  3714	          oarc->olabel = link->olabel;
  3715	          if (link->ilabel != 0) {
  3716	            KALDI_ASSERT(static_cast<size_t>(cur_t) <
  3717	                         this->cost_offsets_.size());
  3718	            acoustic_cost -= this->cost_offsets_[cur_t];
  3719	            step_t = -1;
  3720	          } else {
  3721	            step_t = 0;
  3722	          }
  3723	          oarc->weight = LatticeWeight(graph_cost, acoustic_cost);
  3724	          best_cost = cost;
  3725	        }
  3726	      }
  3727	    }
  3728	    if (link == NULL &&
  3729	        best_cost ==
  3730	            std::numeric_limits<BaseFloat>::infinity()) {  // Did not find
  3731	                                                           // correct link.
  3732	      KALDI_ERR << "Error tracing best-path back (likely "
  3733	                << "bug in token-pruning algorithm)";
  3734	    }
  3735	  } else {
  3736	    oarc->ilabel = 0;
  3737	    oarc->olabel = 0;
  3738	    oarc->weight = LatticeWeight::One();  // zero costs.
  3739	  }
  3740	  return BestPathIterator(tok->backpointer, cur_t + step_t);
  3741	}
  3742	
  3743	template <typename FST>
  3744	bool LatticeFasterOnlineDecoderTpl<FST>::GetRawLatticePruned(
  3745	    Lattice *ofst, bool use_final_probs, BaseFloat beam) const {
  3746	  typedef LatticeArc Arc;
  3747	  typedef Arc::StateId StateId;
  3748	  typedef Arc::Weight Weight;
  3749	  typedef Arc::Label Label;
  3750	
  3751	  // Note: you can't use the old interface (Decode()) if you want to
  3752	  // get the lattice with use_final_probs = false.  You'd have to do
  3753	  // InitDecoding() and then AdvanceDecoding().
  3754	  if (this->decoding_finalized_ && !use_final_probs)
  3755	    KALDI_ERR << "You cannot call FinalizeDecoding() and then call "
  3756	              << "GetRawLattice() with use_final_probs == false";
  3757	
  3758	  unordered_map<Token *, BaseFloat> final_costs_local;
  3759	
  3760	  const unordered_map<Token *, BaseFloat> &final_costs =
  3761	      (this->decoding_finalized_ ? this->final_costs_ : final_costs_local);
  3762	  if (!this->decoding_finalized_ && use_final_probs)
  3763	    this->ComputeFinalCosts(&final_costs_local, NULL, NULL);
  3764	
  3765	  ofst->DeleteStates();
  3766	  // num-frames plus one (since frames are one-based, and we have
  3767	  // an extra frame for the start-state).
  3768	  int32 num_frames = this->active_toks_.size() - 1;
  3769	  KALDI_ASSERT(num_frames > 0);
  3770	  for (int32 f = 0; f <= num_frames; f++) {
  3771	    if (this->active_toks_[f].toks == NULL) {
  3772	      KALDI_WARN << "No tokens active on frame " << f
  3773	                 << ": not producing lattice.\n";
  3774	      return false;
  3775	    }
  3776	  }
  3777	  unordered_map<Token *, StateId> tok_map;
  3778	  std::queue<std::pair<Token *, int32> > tok_queue;
  3779	  // First initialize the queue and states.  Put the initial state on the queue;
  3780	  // this is the last token in the list active_toks_[0].toks.
  3781	  for (Token *tok = this->active_toks_[0].toks; tok != NULL; tok = tok->next) {
  3782	    if (tok->next == NULL) {
  3783	      tok_map[tok] = ofst->AddState();
  3784	      ofst->SetStart(tok_map[tok]);
  3785	      std::pair<Token *, int32> tok_pair(tok, 0);  // #frame = 0
  3786	      tok_queue.push(tok_pair);
  3787	    }
  3788	  }
  3789	
  3790	  // Next create states for "good" tokens
  3791	  while (!tok_queue.empty()) {
  3792	    std::pair<Token *, int32> cur_tok_pair = tok_queue.front();
  3793	    tok_queue.pop();
  3794	    Token *cur_tok = cur_tok_pair.first;
  3795	    int32 cur_frame = cur_tok_pair.second;
  3796	    KALDI_ASSERT(cur_frame >= 0 && cur_frame <= this->cost_offsets_.size());
  3797	
  3798	    typename unordered_map<Token *, StateId>::const_iterator iter =
  3799	        tok_map.find(cur_tok);
  3800	    KALDI_ASSERT(iter != tok_map.end());
  3801	    StateId cur_state = iter->second;
  3802	
  3803	    for (ForwardLinkT *l = cur_tok->links; l != NULL; l = l->next) {
  3804	      Token *next_tok = l->next_tok;
  3805	      if (next_tok->extra_cost < beam) {
  3806	        // so both the current and the next token are good; create the arc
  3807	        int32 next_frame = l->ilabel == 0 ? cur_frame : cur_frame + 1;
  3808	        StateId nextstate;
  3809	        if (tok_map.find(next_tok) == tok_map.end()) {
  3810	          nextstate = tok_map[next_tok] = ofst->AddState();
  3811	          tok_queue.push(std::pair<Token *, int32>(next_tok, next_frame));
  3812	        } else {
  3813	          nextstate = tok_map[next_tok];
  3814	        }
  3815	        BaseFloat cost_offset =
  3816	            (l->ilabel != 0 ? this->cost_offsets_[cur_frame] : 0);
  3817	        Arc arc(l->ilabel, l->olabel,
  3818	                Weight(l->graph_cost, l->acoustic_cost - cost_offset),
  3819	                nextstate);
  3820	        ofst->AddArc(cur_state, arc);
  3821	      }
  3822	    }
  3823	    if (cur_frame == num_frames) {
  3824	      if (use_final_probs && !final_costs.empty()) {
  3825	        typename unordered_map<Token *, BaseFloat>::const_iterator iter =
  3826	            final_costs.find(cur_tok);
  3827	        if (iter != final_costs.end())
  3828	          ofst->SetFinal(cur_state, LatticeWeight(iter->second, 0));
  3829	      } else {
  3830	        ofst->SetFinal(cur_state, LatticeWeight::One());
  3831	      }
  3832	    }
  3833	  }
  3834	  return (ofst->NumStates() != 0);
  3835	}
  3836	
  3837	// Instantiate the template for the FST types that we'll need.
  3838	template class LatticeFasterOnlineDecoderTpl<fst::Fst<fst::StdArc> >;
  3839	template class LatticeFasterOnlineDecoderTpl<fst::VectorFst<fst::StdArc> >;
  3840	template class LatticeFasterOnlineDecoderTpl<fst::ConstFst<fst::StdArc> >;
  3841	
  3842	}  // end namespace kaldi.
  3843	// fstbin/fstaddselfloops.cc
  3844	
  3845	// Copyright 2009-2011  Microsoft Corporation
  3846	
  3847	// See ../../COPYING for clarification regarding multiple authors
  3848	//
  3849	// Licensed under the Apache License, Version 2.0 (the "License");
  3850	// you may not use this file except in compliance with the License.
  3851	// You may obtain a copy of the License at
  3852	//
  3853	//  http://www.apache.org/licenses/LICENSE-2.0
  3854	//
  3855	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  3856	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  3857	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  3858	// MERCHANTABLITY OR NON-INFRINGEMENT.
  3859	// See the Apache 2 License for the specific language governing permissions and
  3860	// limitations under the License.
  3861	
  3862	#include "base/kaldi-common.h"
  3863	#include "fst/fstlib.h"
  3864	#include "fstext/determinize-star.h"
  3865	#include "fstext/fstext-utils.h"
  3866	#include "fstext/kaldi-fst-io.h"
  3867	#include "util/parse-options.h"
  3868	#include "util/simple-io-funcs.h"
  3869	
  3870	/* some test examples:
  3871	  pushd ~/tmpdir
  3872	 ( echo 3; echo  4) > in.list
  3873	 ( echo 5; echo  6) > out.list
  3874	 ( echo "0 0 0 0"; echo "0 0" ) | fstcompile | fstaddselfloops in.list out.list
  3875	 | fstprint ( echo "0 1 0 1"; echo " 0 2 1 0"; echo "1 0"; echo "2 0"; ) |
  3876	 fstcompile | fstaddselfloops in.list out.list | fstprint
  3877	*/
  3878	
  3879	int main(int argc, char *argv[]) {
  3880	  try {
  3881	    using namespace kaldi;  // NOLINT
  3882	    using namespace fst;  // NOLINT
  3883	    using kaldi::int32;
  3884	
  3885	    const char *usage =
  3886	        "Adds self-loops to states of an FST to propagate disambiguation "
  3887	        "symbols through it\n"
  3888	        "They are added on each final state and each state with non-epsilon "
  3889	        "output symbols\n"
  3890	        "on at least one arc out of the state.  Useful in conjunction with "
  3891	        "predeterminize\n"
  3892	        "\n"
  3893	        "Usage:  fstaddselfloops in-disambig-list out-disambig-list  [in.fst "
  3894	        "[out.fst] ]\n"
  3895	        "E.g:  fstaddselfloops in.list out.list < in.fst > withloops.fst\n"
  3896	        "in.list and out.list are lists of integers, one per line, of the\n"
  3897	        "same length.\n";
  3898	
  3899	    ParseOptions po(usage);
  3900	    po.Read(argc, argv);
  3901	
  3902	    if (po.NumArgs() < 2 || po.NumArgs() > 4) {
  3903	      po.PrintUsage();
  3904	      exit(1);
  3905	    }
  3906	
  3907	    std::string disambig_in_rxfilename = po.GetArg(1),
  3908	                disambig_out_rxfilename = po.GetArg(2),
  3909	                fst_in_filename = po.GetOptArg(3),
  3910	                fst_out_filename = po.GetOptArg(4);
  3911	
  3912	    VectorFst<StdArc> *fst = ReadFstKaldi(fst_in_filename);
  3913	
  3914	    std::vector<int32> disambig_in;
  3915	    if (!ReadIntegerVectorSimple(disambig_in_rxfilename, &disambig_in))
  3916	      KALDI_ERR
  3917	          << "fstaddselfloops: Could not read disambiguation symbols from "
  3918	          << kaldi::PrintableRxfilename(disambig_in_rxfilename);
  3919	
  3920	    std::vector<int32> disambig_out;
  3921	    if (!ReadIntegerVectorSimple(disambig_out_rxfilename, &disambig_out))
  3922	      KALDI_ERR
  3923	          << "fstaddselfloops: Could not read disambiguation symbols from "
  3924	          << kaldi::PrintableRxfilename(disambig_out_rxfilename);
  3925	
  3926	    if (disambig_in.size() != disambig_out.size())
  3927	      KALDI_ERR
  3928	          << "fstaddselfloops: mismatch in size of disambiguation symbols";
  3929	
  3930	    AddSelfLoops(fst, disambig_in, disambig_out);
  3931	
  3932	    WriteFstKaldi(*fst, fst_out_filename);
  3933	
  3934	    delete fst;
  3935	
  3936	    return 0;
  3937	  } catch (const std::exception &e) {
  3938	    std::cerr << e.what();
  3939	    return -1;
  3940	  }
  3941	  return 0;
  3942	}
  3943	// fstbin/fstdeterminizestar.cc
  3944	
  3945	// Copyright 2009-2011  Microsoft Corporation
  3946	
  3947	// See ../../COPYING for clarification regarding multiple authors
  3948	//
  3949	// Licensed under the Apache License, Version 2.0 (the "License");
  3950	// you may not use this file except in compliance with the License.
  3951	// You may obtain a copy of the License at
  3952	//
  3953	//  http://www.apache.org/licenses/LICENSE-2.0
  3954	//
  3955	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  3956	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  3957	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  3958	// MERCHANTABLITY OR NON-INFRINGEMENT.
  3959	// See the Apache 2 License for the specific language governing permissions and
  3960	// limitations under the License.
  3961	
  3962	#include "base/kaldi-common.h"
  3963	#include "fst/fstlib.h"
  3964	#include "fstext/determinize-star.h"
  3965	#include "fstext/fstext-utils.h"
  3966	#include "fstext/kaldi-fst-io.h"
  3967	#include "util/parse-options.h"
  3968	#if !defined(_MSC_VER) && !defined(__APPLE__)
  3969	#include <signal.h>  // Comment this line and the call to signal below if
  3970	// it causes compilation problems.  It is only to enable a debugging procedure
  3971	// when determinization does not terminate.  We are disabling this code if
  3972	// compiling on Windows because signal.h is not available there, and on
  3973	// MacOS due to a problem with <signal.h> in the initial release of Sierra.
  3974	#endif
  3975	
  3976	/* some test  examples:
  3977	 ( echo "0 0 0 0"; echo "0 0" ) | fstcompile | fstdeterminizestar | fstprint
  3978	 ( echo "0 0 1 0"; echo "0 0" ) | fstcompile | fstdeterminizestar | fstprint
  3979	 ( echo "0 0 1 0"; echo "0 1 1 0"; echo "0 0" ) | fstcompile |
  3980	 fstdeterminizestar | fstprint # this last one fails [correctly]: ( echo "0 0 0
  3981	 1"; echo "0 0" ) | fstcompile | fstdeterminizestar | fstprint
  3982	
  3983	  cd ~/tmpdir
  3984	  while true; do
  3985	    fstrand > 1.fst
  3986	    fstpredeterminize out.lst 1.fst | fstdeterminizestar | fstrmsymbols out.lst
  3987	 > 2.fst fstequivalent --random=true 1.fst 2.fst || echo "Test failed" echo -n
  3988	 "." done
  3989	
  3990	 Test of debugging [with non-determinizable input]:
  3991	 ( echo " 0 0 1 0 1.0"; echo "0 1 1 0"; echo "1 1 1 0 0"; echo "0 2 2 0"; echo
  3992	 "2"; echo "1" ) | fstcompile | fstdeterminizestar kill -SIGUSR1 [the process-id
  3993	 of fstdeterminizestar] # prints out a bunch of debugging output showing the
  3994	 mess it got itself into.
  3995	*/
  3996	
  3997	bool debug_location = false;
  3998	void signal_handler(int) { debug_location = true; }
  3999	
  4000	int main(int argc, char *argv[]) {
  4001	  try {
  4002	    using namespace kaldi;  // NOLINT
  4003	    using namespace fst;  // NOLINT
  4004	    using kaldi::int32;
  4005	
  4006	    const char *usage =
  4007	        "Removes epsilons and determinizes in one step\n"
  4008	        "\n"
  4009	        "Usage:  fstdeterminizestar [in.fst [out.fst] ]\n"
  4010	        "\n"
  4011	        "See also: fstdeterminizelog, lattice-determinize\n";
  4012	
  4013	    float delta = kDelta;
  4014	    int max_states = -1;
  4015	    bool use_log = false;
  4016	    ParseOptions po(usage);
  4017	    po.Register("use-log", &use_log, "Determinize in log semiring.");
  4018	    po.Register("delta", &delta,
  4019	                "Delta value used to determine equivalence of weights.");
  4020	    po.Register(
  4021	        "max-states", &max_states,
  4022	        "Maximum number of states in determinized FST before it will abort.");
  4023	    po.Read(argc, argv);
  4024	
  4025	    if (po.NumArgs() > 2) {
  4026	      po.PrintUsage();
  4027	      exit(1);
  4028	    }
  4029	
  4030	    std::string fst_in_str = po.GetOptArg(1), fst_out_str = po.GetOptArg(2);
  4031	
  4032	    // This enables us to get traceback info from determinization that is
  4033	    // not seeming to terminate.
  4034	#if !defined(_MSC_VER) && !defined(__APPLE__)
  4035	    signal(SIGUSR1, signal_handler);
  4036	#endif
  4037	    // Normal case: just files.
  4038	    VectorFst<StdArc> *fst = ReadFstKaldi(fst_in_str);
  4039	
  4040	    ArcSort(fst, ILabelCompare<StdArc>());  // improves speed.
  4041	    if (use_log) {
  4042	      DeterminizeStarInLog(fst, delta, &debug_location, max_states);
  4043	    } else {
  4044	      VectorFst<StdArc> det_fst;
  4045	      DeterminizeStar(*fst, &det_fst, delta, &debug_location, max_states);
  4046	      *fst = det_fst;  // will do shallow copy and then det_fst goes
  4047	      // out of scope anyway.
  4048	    }
  4049	    WriteFstKaldi(*fst, fst_out_str);
  4050	    delete fst;
  4051	    return 0;
  4052	  } catch (const std::exception &e) {
  4053	    std::cerr << e.what();
  4054	    return -1;
  4055	  }
  4056	}
  4057	// fstbin/fstisstochastic.cc
  4058	
  4059	// Copyright 2009-2011  Microsoft Corporation
  4060	
  4061	// See ../../COPYING for clarification regarding multiple authors
  4062	//
  4063	// Licensed under the Apache License, Version 2.0 (the "License");
  4064	// you may not use this file except in compliance with the License.
  4065	// You may obtain a copy of the License at
  4066	//
  4067	//  http://www.apache.org/licenses/LICENSE-2.0
  4068	//
  4069	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  4070	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  4071	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  4072	// MERCHANTABLITY OR NON-INFRINGEMENT.
  4073	// See the Apache 2 License for the specific language governing permissions and
  4074	// limitations under the License.
  4075	
  4076	#include "base/kaldi-common.h"
  4077	#include "fst/fstlib.h"
  4078	#include "fstext/fstext-utils.h"
  4079	#include "fstext/kaldi-fst-io.h"
  4080	#include "util/kaldi-io.h"
  4081	#include "util/parse-options.h"
  4082	
  4083	// e.g. of test:
  4084	// echo " 0 0" | fstcompile | fstisstochastic
  4085	// should return 0 and print "0 0" [meaning, min and
  4086	// max weight are one = exp(0)]
  4087	// echo " 0 1" | fstcompile | fstisstochastic
  4088	// should  return 1, not stochastic, and print 1 1
  4089	// (echo "0 0 0 0 0.693147 "; echo "0 1 0 0 0.693147 "; echo "1 0" ) |
  4090	// fstcompile | fstisstochastic should return 0, stochastic; it prints "0
  4091	// -1.78e-07" for me (echo "0 0 0 0 0.693147 "; echo "0 1 0 0 0.693147 "; echo
  4092	// "1 0" ) | fstcompile | fstisstochastic --test-in-log=false should return 1,
  4093	// not stochastic in tropical; it prints "0 0.693147" for me (echo "0 0 0 0 0 ";
  4094	// echo "0 1 0 0 0 "; echo "1 0" ) | fstcompile | fstisstochastic
  4095	// --test-in-log=false should return 0, stochastic in tropical; it prints "0 0"
  4096	// for me (echo "0 0 0 0 0.693147 "; echo "0 1 0 0 0.693147 "; echo "1 0" ) |
  4097	// fstcompile | fstisstochastic --test-in-log=false --delta=1 returns 0 even
  4098	// though not stochastic because we gave it an absurdly large delta.
  4099	
  4100	int main(int argc, char *argv[]) {
  4101	  try {
  4102	    using namespace kaldi;  // NOLINT
  4103	    using namespace fst;  // NOLINT
  4104	    using kaldi::int32;
  4105	
  4106	    const char *usage =
  4107	        "Checks whether an FST is stochastic and exits with success if so.\n"
  4108	        "Prints out maximum error (in log units).\n"
  4109	        "\n"
  4110	        "Usage:  fstisstochastic [ in.fst ]\n";
  4111	
  4112	    float delta = 0.01;
  4113	    bool test_in_log = true;
  4114	
  4115	    ParseOptions po(usage);
  4116	    po.Register("delta", &delta, "Maximum error to accept.");
  4117	    po.Register("test-in-log", &test_in_log,
  4118	                "Test stochasticity in log semiring.");
  4119	    po.Read(argc, argv);
  4120	
  4121	    if (po.NumArgs() > 1) {
  4122	      po.PrintUsage();
  4123	      exit(1);
  4124	    }
  4125	
  4126	    std::string fst_in_filename = po.GetOptArg(1);
  4127	
  4128	    Fst<StdArc> *fst = ReadFstKaldiGeneric(fst_in_filename);
  4129	
  4130	    bool ans;
  4131	    StdArc::Weight min, max;
  4132	    if (test_in_log)
  4133	      ans = IsStochasticFstInLog(*fst, delta, &min, &max);
  4134	    else
  4135	      ans = IsStochasticFst(*fst, delta, &min, &max);
  4136	
  4137	    std::cout << min.Value() << " " << max.Value() << '\n';
  4138	    delete fst;
  4139	    if (ans)
  4140	      return 0;  // success;
  4141	    else
  4142	      return 1;
  4143	  } catch (const std::exception &e) {
  4144	    std::cerr << e.what();
  4145	    return -1;
  4146	  }
  4147	}
  4148	// fstbin/fstminimizeencoded.cc
  4149	
  4150	// Copyright 2009-2011  Microsoft Corporation
  4151	
  4152	// See ../../COPYING for clarification regarding multiple authors
  4153	//
  4154	// Licensed under the Apache License, Version 2.0 (the "License");
  4155	// you may not use this file except in compliance with the License.
  4156	// You may obtain a copy of the License at
  4157	//
  4158	//  http://www.apache.org/licenses/LICENSE-2.0
  4159	//
  4160	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  4161	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  4162	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  4163	// MERCHANTABLITY OR NON-INFRINGEMENT.
  4164	// See the Apache 2 License for the specific language governing permissions and
  4165	// limitations under the License.
  4166	
  4167	#include "base/kaldi-common.h"
  4168	#include "fst/fstlib.h"
  4169	#include "fstext/determinize-star.h"
  4170	#include "fstext/fstext-utils.h"
  4171	#include "fstext/kaldi-fst-io.h"
  4172	#include "util/kaldi-io.h"
  4173	#include "util/parse-options.h"
  4174	#include "util/text-utils.h"
  4175	
  4176	/* some test  examples:
  4177	 ( echo "0 0 0 0"; echo "0 0" ) | fstcompile | fstminimizeencoded | fstprint
  4178	 ( echo "0 1 0 0"; echo " 0 2 0 0"; echo "1 0"; echo "2 0"; ) | fstcompile |
  4179	 fstminimizeencoded | fstprint
  4180	*/
  4181	
  4182	int main(int argc, char *argv[]) {
  4183	  try {
  4184	    using namespace kaldi;  // NOLINT
  4185	    using namespace fst;  // NOLINT
  4186	    using kaldi::int32;
  4187	
  4188	    const char *usage =
  4189	        "Minimizes FST after encoding [similar to fstminimize, but no "
  4190	        "weight-pushing]\n"
  4191	        "\n"
  4192	        "Usage:  fstminimizeencoded [in.fst [out.fst] ]\n";
  4193	
  4194	    float delta = kDelta;
  4195	    ParseOptions po(usage);
  4196	    po.Register("delta", &delta,
  4197	                "Delta likelihood used for quantization of weights");
  4198	    po.Read(argc, argv);
  4199	
  4200	    if (po.NumArgs() > 2) {
  4201	      po.PrintUsage();
  4202	      exit(1);
  4203	    }
  4204	
  4205	    std::string fst_in_filename = po.GetOptArg(1),
  4206	                fst_out_filename = po.GetOptArg(2);
  4207	
  4208	    VectorFst<StdArc> *fst = ReadFstKaldi(fst_in_filename);
  4209	
  4210	    MinimizeEncoded(fst, delta);
  4211	
  4212	    WriteFstKaldi(*fst, fst_out_filename);
  4213	
  4214	    delete fst;
  4215	    return 0;
  4216	  } catch (const std::exception &e) {
  4217	    std::cerr << e.what();
  4218	    return -1;
  4219	  }
  4220	  return 0;
  4221	}
  4222	// fstbin/fsttablecompose.cc
  4223	
  4224	// Copyright 2009-2011  Microsoft Corporation
  4225	//                2013  Johns Hopkins University (author: Daniel Povey)
  4226	
  4227	// See ../../COPYING for clarification regarding multiple authors
  4228	//
  4229	// Licensed under the Apache License, Version 2.0 (the "License");
  4230	// you may not use this file except in compliance with the License.
  4231	// You may obtain a copy of the License at
  4232	//
  4233	//  http://www.apache.org/licenses/LICENSE-2.0
  4234	//
  4235	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  4236	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  4237	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  4238	// MERCHANTABLITY OR NON-INFRINGEMENT.
  4239	// See the Apache 2 License for the specific language governing permissions and
  4240	// limitations under the License.
  4241	
  4242	#include "base/kaldi-common.h"
  4243	#include "fst/fstlib.h"
  4244	#include "fstext/fstext-utils.h"
  4245	#include "fstext/kaldi-fst-io.h"
  4246	#include "fstext/table-matcher.h"
  4247	#include "util/parse-options.h"
  4248	
  4249	/*
  4250	  cd ~/tmpdir
  4251	  while true; do
  4252	    fstrand  | fstarcsort --sort_type=olabel > 1.fst; fstrand | fstarcsort
  4253	  > 2.fst fstcompose 1.fst 2.fst > 3a.fst fsttablecompose 1.fst 2.fst > 3b.fst
  4254	    fstequivalent --random=true 3a.fst 3b.fst || echo "Test failed"
  4255	    echo -n "."
  4256	  done
  4257	
  4258	*/
  4259	
  4260	int main(int argc, char *argv[]) {
  4261	  try {
  4262	    using namespace kaldi;  // NOLINT
  4263	    using namespace fst;  // NOLINT
  4264	    using kaldi::int32;
  4265	    /*
  4266	      fsttablecompose should always give equivalent results to compose,
  4267	      but it is more efficient for certain kinds of inputs.
  4268	      In particular, it is useful when, say, the left FST has states
  4269	      that typically either have epsilon olabels, or
  4270	      one transition out for each of the possible symbols (as the
  4271	      olabel).  The same with the input symbols of the right-hand FST
  4272	      is possible.
  4273	    */
  4274	
  4275	    const char *usage =
  4276	        "Composition algorithm [between two FSTs of standard type, in "
  4277	        "tropical\n"
  4278	        "semiring] that is more efficient for certain cases-- in particular,\n"
  4279	        "where one of the FSTs (the left one, if --match-side=left) has large\n"
  4280	        "out-degree\n"
  4281	        "\n"
  4282	        "Usage:  fsttablecompose (fst1-rxfilename|fst1-rspecifier) "
  4283	        "(fst2-rxfilename|fst2-rspecifier) [(out-rxfilename|out-rspecifier)]\n";
  4284	
  4285	    ParseOptions po(usage);
  4286	
  4287	    TableComposeOptions opts;
  4288	    std::string match_side = "left";
  4289	    std::string compose_filter = "sequence";
  4290	
  4291	    po.Register("connect", &opts.connect, "If true, trim FST before output.");
  4292	    po.Register("match-side", &match_side,
  4293	                "Side of composition to do table "
  4294	                "match, one of: \"left\" or \"right\".");
  4295	    po.Register("compose-filter", &compose_filter,
  4296	                "Composition filter to use, "
  4297	                "one of: \"alt_sequence\", \"auto\", \"match\", \"sequence\"");
  4298	
  4299	    po.Read(argc, argv);
  4300	
  4301	    if (match_side == "left") {
  4302	      opts.table_match_type = MATCH_OUTPUT;
  4303	    } else if (match_side == "right") {
  4304	      opts.table_match_type = MATCH_INPUT;
  4305	    } else {
  4306	      KALDI_ERR << "Invalid match-side option: " << match_side;
  4307	    }
  4308	
  4309	    if (compose_filter == "alt_sequence") {
  4310	      opts.filter_type = ALT_SEQUENCE_FILTER;
  4311	    } else if (compose_filter == "auto") {
  4312	      opts.filter_type = AUTO_FILTER;
  4313	    } else if (compose_filter == "match") {
  4314	      opts.filter_type = MATCH_FILTER;
  4315	    } else if (compose_filter == "sequence") {
  4316	      opts.filter_type = SEQUENCE_FILTER;
  4317	    } else {
  4318	      KALDI_ERR << "Invalid compose-filter option: " << compose_filter;
  4319	    }
  4320	
  4321	    if (po.NumArgs() < 2 || po.NumArgs() > 3) {
  4322	      po.PrintUsage();
  4323	      exit(1);
  4324	    }
  4325	
  4326	    std::string fst1_in_str = po.GetArg(1), fst2_in_str = po.GetArg(2),
  4327	                fst_out_str = po.GetOptArg(3);
  4328	
  4329	    VectorFst<StdArc> *fst1 = ReadFstKaldi(fst1_in_str);
  4330	
  4331	    VectorFst<StdArc> *fst2 = ReadFstKaldi(fst2_in_str);
  4332	
  4333	    // Checks if <fst1> is olabel sorted and <fst2> is ilabel sorted.
  4334	    if (fst1->Properties(fst::kOLabelSorted, true) == 0) {
  4335	      KALDI_WARN << "The first FST is not olabel sorted.";
  4336	    }
  4337	    if (fst2->Properties(fst::kILabelSorted, true) == 0) {
  4338	      KALDI_WARN << "The second FST is not ilabel sorted.";
  4339	    }
  4340	
  4341	    VectorFst<StdArc> composed_fst;
  4342	
  4343	    TableCompose(*fst1, *fst2, &composed_fst, opts);
  4344	
  4345	    delete fst1;
  4346	    delete fst2;
  4347	
  4348	    WriteFstKaldi(composed_fst, fst_out_str);
  4349	    return 0;
  4350	  } catch (const std::exception &e) {
  4351	    std::cerr << e.what();
  4352	    return -1;
  4353	  }
  4354	}
  4355	// fstext/kaldi-fst-io.cc
  4356	
  4357	// Copyright 2009-2011  Microsoft Corporation
  4358	//           2012-2015  Johns Hopkins University (Author: Daniel Povey)
  4359	//                2013  Guoguo Chen
  4360	
  4361	// See ../../COPYING for clarification regarding multiple authors
  4362	//
  4363	// Licensed under the Apache License, Version 2.0 (the "License");
  4364	// you may not use this file except in compliance with the License.
  4365	// You may obtain a copy of the License at
  4366	//
  4367	//  http://www.apache.org/licenses/LICENSE-2.0
  4368	//
  4369	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  4370	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  4371	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  4372	// MERCHANTABLITY OR NON-INFRINGEMENT.
  4373	// See the Apache 2 License for the specific language governing permissions and
  4374	// limitations under the License.
  4375	
  4376	#include "fstext/kaldi-fst-io.h"
  4377	
  4378	#include <string>
  4379	
  4380	#include "base/kaldi-error.h"
  4381	#include "base/kaldi-math.h"
  4382	#include "util/kaldi-io.h"
  4383	
  4384	namespace fst {
  4385	
  4386	VectorFst<StdArc> *ReadFstKaldi(std::string rxfilename) {
  4387	  if (rxfilename == "") rxfilename = "-";  // interpret "" as stdin,
  4388	  // for compatibility with OpenFst conventions.
  4389	  kaldi::Input ki(rxfilename);
  4390	  fst::FstHeader hdr;
  4391	  if (!hdr.Read(ki.Stream(), rxfilename))
  4392	    KALDI_ERR << "Reading FST: error reading FST header from "
  4393	              << kaldi::PrintableRxfilename(rxfilename);
  4394	  FstReadOptions ropts("<unspecified>", &hdr);
  4395	  VectorFst<StdArc> *fst = VectorFst<StdArc>::Read(ki.Stream(), ropts);
  4396	  if (!fst)
  4397	    KALDI_ERR << "Could not read fst from "
  4398	              << kaldi::PrintableRxfilename(rxfilename);
  4399	  return fst;
  4400	}
  4401	
  4402	// Register const fst to load it automatically. Other types like
  4403	// olabel_lookahead or ngram or compact_fst should be registered
  4404	// through OpenFst registration API.
  4405	static fst::FstRegisterer<VectorFst<StdArc>> VectorFst_StdArc_registerer;
  4406	static fst::FstRegisterer<ConstFst<StdArc>> ConstFst_StdArc_registerer;
  4407	
  4408	Fst<StdArc> *ReadFstKaldiGeneric(std::string rxfilename, bool throw_on_err) {
  4409	  if (rxfilename == "") rxfilename = "-";  // interpret "" as stdin,
  4410	  // for compatibility with OpenFst conventions.
  4411	  kaldi::Input ki(rxfilename);
  4412	  fst::FstHeader hdr;
  4413	  // Read FstHeader which contains the type of FST
  4414	  if (!hdr.Read(ki.Stream(), rxfilename)) {
  4415	    if (throw_on_err) {
  4416	      KALDI_ERR << "Reading FST: error reading FST header from "
  4417	                << kaldi::PrintableRxfilename(rxfilename);
  4418	    } else {
  4419	      KALDI_WARN << "We fail to read FST header from "
  4420	                 << kaldi::PrintableRxfilename(rxfilename)
  4421	                 << ". A NULL pointer is returned.";
  4422	      return NULL;
  4423	    }
  4424	  }
  4425	  // Check the type of Arc
  4426	  if (hdr.ArcType() != fst::StdArc::Type()) {
  4427	    if (throw_on_err) {
  4428	      KALDI_ERR << "FST with arc type " << hdr.ArcType()
  4429	                << " is not supported.";
  4430	    } else {
  4431	      KALDI_WARN << "Fst with arc type" << hdr.ArcType()
  4432	                 << " is not supported. A NULL pointer is returned.";
  4433	      return NULL;
  4434	    }
  4435	  }
  4436	  // Read the FST
  4437	  FstReadOptions ropts("<unspecified>", &hdr);
  4438	  Fst<StdArc> *fst = Fst<StdArc>::Read(ki.Stream(), ropts);
  4439	  if (!fst) {
  4440	    if (throw_on_err) {
  4441	      KALDI_ERR << "Could not read fst from "
  4442	                << kaldi::PrintableRxfilename(rxfilename);
  4443	    } else {
  4444	      KALDI_WARN << "Could not read fst from "
  4445	                 << kaldi::PrintableRxfilename(rxfilename)
  4446	                 << ". A NULL pointer is returned.";
  4447	      return NULL;
  4448	    }
  4449	  }
  4450	  return fst;
  4451	}
  4452	
  4453	VectorFst<StdArc> *CastOrConvertToVectorFst(Fst<StdArc> *fst) {
  4454	  // This version currently supports ConstFst<StdArc> or VectorFst<StdArc>
  4455	  std::string real_type = fst->Type();
  4456	  KALDI_ASSERT(real_type == "vector" || real_type == "const");
  4457	  if (real_type == "vector") {
  4458	    return dynamic_cast<VectorFst<StdArc> *>(fst);
  4459	  } else {
  4460	    // As the 'fst' can't cast to VectorFst, we create a new
  4461	    // VectorFst<StdArc> initialized by 'fst', and delete 'fst'.
  4462	    VectorFst<StdArc> *new_fst = new VectorFst<StdArc>(*fst);
  4463	    delete fst;
  4464	    return new_fst;
  4465	  }
  4466	}
  4467	
  4468	void ReadFstKaldi(std::string rxfilename, fst::StdVectorFst *ofst) {
  4469	  fst::StdVectorFst *fst = ReadFstKaldi(rxfilename);
  4470	  *ofst = *fst;
  4471	  delete fst;
  4472	}
  4473	
  4474	void WriteFstKaldi(const VectorFst<StdArc> &fst, std::string wxfilename) {
  4475	  if (wxfilename == "") wxfilename = "-";  // interpret "" as stdout,
  4476	  // for compatibility with OpenFst conventions.
  4477	  bool write_binary = true, write_header = false;
  4478	  kaldi::Output ko(wxfilename, write_binary, write_header);
  4479	  FstWriteOptions wopts(kaldi::PrintableWxfilename(wxfilename));
  4480	  fst.Write(ko.Stream(), wopts);
  4481	}
  4482	
  4483	fst::VectorFst<fst::StdArc> *ReadAndPrepareLmFst(std::string rxfilename) {
  4484	  // ReadFstKaldi() will die with exception on failure.
  4485	  fst::VectorFst<fst::StdArc> *ans = fst::ReadFstKaldi(rxfilename);
  4486	  if (ans->Properties(fst::kAcceptor, true) == 0) {
  4487	    // If it's not already an acceptor, project on the output, i.e. copy olabels
  4488	    // to ilabels.  Generally the G.fst's on disk will have the disambiguation
  4489	    // symbol #0 on the input symbols of the backoff arc, and projection will
  4490	    // replace them with epsilons which is what is on the output symbols of
  4491	    // those arcs.
  4492	    fst::Project(ans, fst::PROJECT_OUTPUT);
  4493	  }
  4494	  if (ans->Properties(fst::kILabelSorted, true) == 0) {
  4495	    // Make sure LM is sorted on ilabel.
  4496	    fst::ILabelCompare<fst::StdArc> ilabel_comp;
  4497	    fst::ArcSort(ans, ilabel_comp);
  4498	  }
  4499	  return ans;
  4500	}
  4501	
  4502	}  // end namespace fst
  4503	// lat/determinize-lattice-pruned.cc
  4504	
  4505	// Copyright 2009-2012  Microsoft Corporation
  4506	//           2012-2013  Johns Hopkins University (Author: Daniel Povey)
  4507	//                2014  Guoguo Chen
  4508	
  4509	// See ../../COPYING for clarification regarding multiple authors
  4510	//
  4511	// Licensed under the Apache License, Version 2.0 (the "License");
  4512	// you may not use this file except in compliance with the License.
  4513	// You may obtain a copy of the License at
  4514	//
  4515	//  http://www.apache.org/licenses/LICENSE-2.0
  4516	//
  4517	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  4518	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  4519	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  4520	// MERCHANTABLITY OR NON-INFRINGEMENT.
  4521	// See the Apache 2 License for the specific language governing permissions and
  4522	// limitations under the License.
  4523	
  4524	#include <vector>
  4525	#include <climits>
  4526	#include "fstext/determinize-lattice.h" // for LatticeStringRepository
  4527	#include "fstext/fstext-utils.h"
  4528	#include "lat/lattice-functions.h"  // for PruneLattice
  4529	// #include "lat/minimize-lattice.h"   // for minimization
  4530	// #include "lat/push-lattice.h"       // for minimization
  4531	#include "lat/determinize-lattice-pruned.h"
  4532	
  4533	namespace fst {
  4534	
  4535	using std::vector;
  4536	using std::pair;
  4537	using std::greater;
  4538	
  4539	// class LatticeDeterminizerPruned is templated on the same types that
  4540	// CompactLatticeWeight is templated on: the base weight (Weight), typically
  4541	// LatticeWeightTpl<float> etc. but could also be e.g. TropicalWeight, and the
  4542	// IntType, typically int32, used for the output symbols in the compact
  4543	// representation of strings [note: the output symbols would usually be
  4544	// p.d.f. id's in the anticipated use of this code] It has a special requirement
  4545	// on the Weight type: that there should be a Compare function on the weights
  4546	// such that Compare(w1, w2) returns -1 if w1 < w2, 0 if w1 == w2, and +1 if w1 >
  4547	// w2.  This requires that there be a total order on the weights.
  4548	
  4549	template<class Weight, class IntType> class LatticeDeterminizerPruned {
  4550	 public:
  4551	  // Output to Gallic acceptor (so the strings go on weights, and there is a 1-1 correspondence
  4552	  // between our states and the states in ofst.  If destroy == true, release memory as we go
  4553	  // (but we cannot output again).
  4554	
  4555	  typedef CompactLatticeWeightTpl<Weight, IntType> CompactWeight;
  4556	  typedef ArcTpl<CompactWeight> CompactArc; // arc in compact, acceptor form of lattice
  4557	  typedef ArcTpl<Weight> Arc; // arc in non-compact version of lattice
  4558	
  4559	  // Output to standard FST with CompactWeightTpl<Weight> as its weight type (the
  4560	  // weight stores the original output-symbol strings).  If destroy == true,
  4561	  // release memory as we go (but we cannot output again).
  4562	  void Output(MutableFst<CompactArc>  *ofst, bool destroy = true) {
  4563	    KALDI_ASSERT(determinized_);
  4564	    typedef typename Arc::StateId StateId;
  4565	    StateId nStates = static_cast<StateId>(output_states_.size());
  4566	    if (destroy)
  4567	      FreeMostMemory();
  4568	    ofst->DeleteStates();
  4569	    ofst->SetStart(kNoStateId);
  4570	    if (nStates == 0) {
  4571	      return;
  4572	    }
  4573	    for (StateId s = 0;s < nStates;s++) {
  4574	      OutputStateId news = ofst->AddState();
  4575	      KALDI_ASSERT(news == s);
  4576	    }
  4577	    ofst->SetStart(0);
  4578	    // now process transitions.
  4579	    for (StateId this_state_id = 0; this_state_id < nStates; this_state_id++) {
  4580	      OutputState &this_state = *(output_states_[this_state_id]);
  4581	      vector<TempArc> &this_vec(this_state.arcs);
  4582	      typename vector<TempArc>::const_iterator iter = this_vec.begin(), end = this_vec.end();
  4583	
  4584	      for (;iter != end; ++iter) {
  4585	        const TempArc &temp_arc(*iter);
  4586	        CompactArc new_arc;
  4587	        vector<Label> olabel_seq;
  4588	        repository_.ConvertToVector(temp_arc.string, &olabel_seq);
  4589	        CompactWeight weight(temp_arc.weight, olabel_seq);
  4590	        if (temp_arc.nextstate == kNoStateId) {  // is really final weight.
  4591	          ofst->SetFinal(this_state_id, weight);
  4592	        } else {  // is really an arc.
  4593	          new_arc.nextstate = temp_arc.nextstate;
  4594	          new_arc.ilabel = temp_arc.ilabel;
  4595	          new_arc.olabel = temp_arc.ilabel;  // acceptor.  input == output.
  4596	          new_arc.weight = weight;  // includes string and weight.
  4597	          ofst->AddArc(this_state_id, new_arc);
  4598	        }
  4599	      }
  4600	      // Free up memory.  Do this inside the loop as ofst is also allocating memory,
  4601	      // and we want to reduce the maximum amount ever allocated.
  4602	      if (destroy) { vector<TempArc> temp; temp.swap(this_vec); }
  4603	    }
  4604	    if (destroy) {
  4605	      FreeOutputStates();
  4606	      repository_.Destroy();
  4607	    }
  4608	  }
  4609	
  4610	  // Output to standard FST with Weight as its weight type.  We will create extra
  4611	  // states to handle sequences of symbols on the output.  If destroy == true,
  4612	  // release memory as we go (but we cannot output again).
  4613	  void  Output(MutableFst<Arc> *ofst, bool destroy = true) {
  4614	    // Outputs to standard fst.
  4615	    OutputStateId nStates = static_cast<OutputStateId>(output_states_.size());
  4616	    ofst->DeleteStates();
  4617	    if (nStates == 0) {
  4618	      ofst->SetStart(kNoStateId);
  4619	      return;
  4620	    }
  4621	    if (destroy)
  4622	      FreeMostMemory();
  4623	    // Add basic states-- but we will add extra ones to account for strings on output.
  4624	    for (OutputStateId s = 0; s< nStates;s++) {
  4625	      OutputStateId news = ofst->AddState();
  4626	      KALDI_ASSERT(news == s);
  4627	    }
  4628	    ofst->SetStart(0);
  4629	    for (OutputStateId this_state_id = 0; this_state_id < nStates; this_state_id++) {
  4630	      OutputState &this_state = *(output_states_[this_state_id]);
  4631	      vector<TempArc> &this_vec(this_state.arcs);
  4632	
  4633	      typename vector<TempArc>::const_iterator iter = this_vec.begin(), end = this_vec.end();
  4634	      for (; iter != end; ++iter) {
  4635	        const TempArc &temp_arc(*iter);
  4636	        vector<Label> seq;
  4637	        repository_.ConvertToVector(temp_arc.string, &seq);
  4638	
  4639	        if (temp_arc.nextstate == kNoStateId) {  // Really a final weight.
  4640	          // Make a sequence of states going to a final state, with the strings
  4641	          // as labels.  Put the weight on the first arc.
  4642	          OutputStateId cur_state = this_state_id;
  4643	          for (size_t i = 0; i < seq.size(); i++) {
  4644	            OutputStateId next_state = ofst->AddState();
  4645	            Arc arc;
  4646	            arc.nextstate = next_state;
  4647	            arc.weight = (i == 0 ? temp_arc.weight : Weight::One());
  4648	            arc.ilabel = 0;  // epsilon.
  4649	            arc.olabel = seq[i];
  4650	            ofst->AddArc(cur_state, arc);
  4651	            cur_state = next_state;
  4652	          }
  4653	          ofst->SetFinal(cur_state, (seq.size() == 0 ? temp_arc.weight : Weight::One()));
  4654	        } else {  // Really an arc.
  4655	          OutputStateId cur_state = this_state_id;
  4656	          // Have to be careful with this integer comparison (i+1 < seq.size()) because unsigned.
  4657	          // i < seq.size()-1 could fail for zero-length sequences.
  4658	          for (size_t i = 0; i+1 < seq.size();i++) {
  4659	            // for all but the last element of seq, create new state.
  4660	            OutputStateId next_state = ofst->AddState();
  4661	            Arc arc;
  4662	            arc.nextstate = next_state;
  4663	            arc.weight = (i == 0 ? temp_arc.weight : Weight::One());
  4664	            arc.ilabel = (i == 0 ? temp_arc.ilabel : 0);  // put ilabel on first element of seq.
  4665	            arc.olabel = seq[i];
  4666	            ofst->AddArc(cur_state, arc);
  4667	            cur_state = next_state;
  4668	          }
  4669	          // Add the final arc in the sequence.
  4670	          Arc arc;
  4671	          arc.nextstate = temp_arc.nextstate;
  4672	          arc.weight = (seq.size() <= 1 ? temp_arc.weight : Weight::One());
  4673	          arc.ilabel = (seq.size() <= 1 ? temp_arc.ilabel : 0);
  4674	          arc.olabel = (seq.size() > 0 ? seq.back() : 0);
  4675	          ofst->AddArc(cur_state, arc);
  4676	        }
  4677	      }
  4678	      // Free up memory.  Do this inside the loop as ofst is also allocating memory
  4679	      if (destroy) { vector<TempArc> temp; temp.swap(this_vec); }
  4680	    }
  4681	    if (destroy) {
  4682	      FreeOutputStates();
  4683	      repository_.Destroy();
  4684	    }
  4685	  }
  4686	
  4687	
  4688	  // Initializer.  After initializing the object you will typically
  4689	  // call Determinize() and then call one of the Output functions.
  4690	  // Note: ifst.Copy() will generally do a
  4691	  // shallow copy.  We do it like this for memory safety, rather than
  4692	  // keeping a reference or pointer to ifst_.
  4693	  LatticeDeterminizerPruned(const ExpandedFst<Arc> &ifst,
  4694	                            double beam,
  4695	                            DeterminizeLatticePrunedOptions opts):
  4696	      num_arcs_(0), num_elems_(0), ifst_(ifst.Copy()), beam_(beam), opts_(opts),
  4697	      equal_(opts_.delta), determinized_(false),
  4698	      minimal_hash_(3, hasher_, equal_), initial_hash_(3, hasher_, equal_) {
  4699	    KALDI_ASSERT(Weight::Properties() & kIdempotent); // this algorithm won't
  4700	    // work correctly otherwise.
  4701	  }
  4702	
  4703	  void FreeOutputStates() {
  4704	    for (size_t i = 0; i < output_states_.size(); i++)
  4705	      delete output_states_[i];
  4706	    vector<OutputState*> temp;
  4707	    temp.swap(output_states_);
  4708	  }
  4709	
  4710	  // frees all memory except the info (in output_states_[ ]->arcs)
  4711	  // that we need to output the FST.
  4712	  void FreeMostMemory() {
  4713	    if (ifst_) {
  4714	      delete ifst_;
  4715	      ifst_ = NULL;
  4716	    }
  4717	    { MinimalSubsetHash tmp; tmp.swap(minimal_hash_); }
  4718	
  4719	    for (size_t i = 0; i < output_states_.size(); i++) {
  4720	      vector<Element> empty_subset;
  4721	      empty_subset.swap(output_states_[i]->minimal_subset);
  4722	    }
  4723	
  4724	    for (typename InitialSubsetHash::iterator iter = initial_hash_.begin();
  4725	         iter != initial_hash_.end(); ++iter)
  4726	      delete iter->first;
  4727	    { InitialSubsetHash tmp; tmp.swap(initial_hash_); }
  4728	    for (size_t i = 0; i < output_states_.size(); i++) {
  4729	      vector<Element> tmp;
  4730	      tmp.swap(output_states_[i]->minimal_subset);
  4731	    }
  4732	    { vector<char> tmp;  tmp.swap(isymbol_or_final_); }
  4733	    { // Free up the queue.  I'm not sure how to make sure all
  4734	      // the memory is really freed (no swap() function)... doesn't really
  4735	      // matter much though.
  4736	      while (!queue_.empty()) {
  4737	        Task *t = queue_.top();
  4738	        delete t;
  4739	        queue_.pop();
  4740	      }
  4741	    }
  4742	    { vector<pair<Label, Element> > tmp; tmp.swap(all_elems_tmp_); }
  4743	  }
  4744	
  4745	  ~LatticeDeterminizerPruned() {
  4746	    FreeMostMemory();
  4747	    FreeOutputStates();
  4748	    // rest is deleted by destructors.
  4749	  }
  4750	
  4751	  void RebuildRepository() { // rebuild the string repository,
  4752	    // freeing stuff we don't need.. we call this when memory usage
  4753	    // passes a supplied threshold.  We need to accumulate all the
  4754	    // strings we need the repository to "remember", then tell it
  4755	    // to clean the repository.
  4756	    std::vector<StringId> needed_strings;
  4757	    for (size_t i = 0; i < output_states_.size(); i++) {
  4758	      AddStrings(output_states_[i]->minimal_subset, &needed_strings);
  4759	      for (size_t j = 0; j < output_states_[i]->arcs.size(); j++)
  4760	        needed_strings.push_back(output_states_[i]->arcs[j].string);
  4761	    }
  4762	
  4763	    { // the queue doesn't allow us access to the underlying vector,
  4764	      // so we have to resort to a temporary collection.
  4765	      std::vector<Task*> tasks;
  4766	      while (!queue_.empty()) {
  4767	        Task *task = queue_.top();
  4768	        queue_.pop();
  4769	        tasks.push_back(task);
  4770	        AddStrings(task->subset, &needed_strings);
  4771	      }
  4772	      for (size_t i = 0; i < tasks.size(); i++)
  4773	        queue_.push(tasks[i]);
  4774	    }
  4775	
  4776	    // the following loop covers strings present in initial_hash_.
  4777	    for (typename InitialSubsetHash::const_iterator
  4778	             iter = initial_hash_.begin();
  4779	         iter != initial_hash_.end(); ++iter) {
  4780	      const vector<Element> &vec = *(iter->first);
  4781	      Element elem = iter->second;
  4782	      AddStrings(vec, &needed_strings);
  4783	      needed_strings.push_back(elem.string);
  4784	    }
  4785	    std::sort(needed_strings.begin(), needed_strings.end());
  4786	    needed_strings.erase(std::unique(needed_strings.begin(),
  4787	                                     needed_strings.end()),
  4788	                         needed_strings.end()); // uniq the strings.
  4789	    KALDI_LOG << "Rebuilding repository.";
  4790	
  4791	    repository_.Rebuild(needed_strings);
  4792	  }
  4793	
  4794	  bool CheckMemoryUsage() {
  4795	    int32 repo_size = repository_.MemSize(),
  4796	        arcs_size = num_arcs_ * sizeof(TempArc),
  4797	        elems_size = num_elems_ * sizeof(Element),
  4798	        total_size = repo_size + arcs_size + elems_size;
  4799	    if (opts_.max_mem > 0 && total_size > opts_.max_mem) { // We passed the memory threshold.
  4800	      // This is usually due to the repository getting large, so we
  4801	      // clean this out.
  4802	      RebuildRepository();
  4803	      int32 new_repo_size = repository_.MemSize(),
  4804	          new_total_size = new_repo_size + arcs_size + elems_size;
  4805	
  4806	      KALDI_VLOG(2) << "Rebuilt repository in determinize-lattice: repository shrank from "
  4807	                    << repo_size << " to " << new_repo_size << " bytes (approximately)";
  4808	
  4809	      if (new_total_size > static_cast<int32>(opts_.max_mem * 0.8)) {
  4810	        // Rebuilding didn't help enough-- we need a margin to stop
  4811	        // having to rebuild too often.  We'll just return to the user at
  4812	        // this point, with a partial lattice that's pruned tighter than
  4813	        // the specified beam.  Here we figure out what the effective
  4814	        // beam was.
  4815	        double effective_beam = beam_;
  4816	        if (!queue_.empty()) { // Note: queue should probably not be empty; we're
  4817	          // just being paranoid here.
  4818	          Task *task = queue_.top();
  4819	          double total_weight = backward_costs_[ifst_->Start()]; // best weight of FST.
  4820	          effective_beam = task->priority_cost - total_weight;
  4821	        }
  4822	        KALDI_WARN << "Did not reach requested beam in determinize-lattice: "
  4823	                   << "size exceeds maximum " << opts_.max_mem
  4824	                   << " bytes; (repo,arcs,elems) = (" << repo_size << ","
  4825	                   << arcs_size << "," << elems_size
  4826	                   << "), after rebuilding, repo size was " << new_repo_size
  4827	                   << ", effective beam was " << effective_beam
  4828	                   << " vs. requested beam " << beam_;
  4829	        return false;
  4830	      }
  4831	    }
  4832	    return true;
  4833	  }
  4834	
  4835	  bool Determinize(double *effective_beam) {
  4836	    KALDI_ASSERT(!determinized_);
  4837	    // This determinizes the input fst but leaves it in the "special format"
  4838	    // in "output_arcs_".  Must be called after Initialize().  To get the
  4839	    // output, call one of the Output routines.
  4840	
  4841	    InitializeDeterminization(); // some start-up tasks.
  4842	    while (!queue_.empty()) {
  4843	      Task *task = queue_.top();
  4844	      // Note: the queue contains only tasks that are "within the beam".
  4845	      // We also have to check whether we have reached one of the user-specified
  4846	      // maximums, of estimated memory, arcs, or states.  The condition for
  4847	      // ending is:
  4848	      // num-states is more than user specified, OR
  4849	      // num-arcs is more than user specified, OR
  4850	      // memory passed a user-specified threshold and cleanup failed
  4851	      //  to get it below that threshold.
  4852	      size_t num_states = output_states_.size();
  4853	      if ((opts_.max_states > 0 && num_states > opts_.max_states) ||
  4854	          (opts_.max_arcs > 0 && num_arcs_ > opts_.max_arcs) ||
  4855	          (num_states % 10 == 0 && !CheckMemoryUsage())) { // note: at some point
  4856	        // it was num_states % 100, not num_states % 10, but I encountered an example
  4857	        // where memory was exhausted before we reached state #100.
  4858	        KALDI_VLOG(1) << "Lattice determinization terminated but not "
  4859	                      << " because of lattice-beam.  (#states, #arcs) is ( "
  4860	                      << output_states_.size() << ", " << num_arcs_
  4861	                      << " ), versus limits ( " << opts_.max_states << ", "
  4862	                      << opts_.max_arcs << " ) (else, may be memory limit).";
  4863	        break;
  4864	        // we terminate the determinization here-- whatever we already expanded is
  4865	        // what we'll return...  because we expanded stuff in order of total
  4866	        // (forward-backward) weight, the stuff we returned first is the most
  4867	        // important.
  4868	      }
  4869	      queue_.pop();
  4870	      ProcessTransition(task->state, task->label, &(task->subset));
  4871	      delete task;
  4872	    }
  4873	    determinized_ = true;
  4874	    if (effective_beam != NULL) {
  4875	      if (queue_.empty()) *effective_beam = beam_;
  4876	      else
  4877	        *effective_beam = queue_.top()->priority_cost -
  4878	            backward_costs_[ifst_->Start()];
  4879	    }
  4880	    return (queue_.empty()); // return success if queue was empty, i.e. we processed
  4881	    // all tasks and did not break out of the loop early due to reaching a memory,
  4882	    // arc or state limit.
  4883	  }
  4884	 private:
  4885	
  4886	  typedef typename Arc::Label Label;
  4887	  typedef typename Arc::StateId StateId;  // use this when we don't know if it's input or output.
  4888	  typedef typename Arc::StateId InputStateId;  // state in the input FST.
  4889	  typedef typename Arc::StateId OutputStateId;  // same as above but distinguish
  4890	                                                // states in output Fst.
  4891	
  4892	  typedef LatticeStringRepository<IntType> StringRepositoryType;
  4893	  typedef const typename StringRepositoryType::Entry* StringId;
  4894	
  4895	  // Element of a subset [of original states]
  4896	  struct Element {
  4897	    StateId state; // use StateId as this is usually InputStateId but in one case
  4898	                   // OutputStateId.
  4899	    StringId string;
  4900	    Weight weight;
  4901	    bool operator != (const Element &other) const {
  4902	      return (state != other.state || string != other.string ||
  4903	              weight != other.weight);
  4904	    }
  4905	    // This operator is only intended for the priority_queue in the function
  4906	    // EpsilonClosure().
  4907	    bool operator > (const Element &other) const {
  4908	      return state > other.state;
  4909	    }
  4910	    // This operator is only intended to support sorting in EpsilonClosure()
  4911	    bool operator < (const Element &other) const {
  4912	      return state < other.state;
  4913	    }
  4914	  };
  4915	
  4916	  // Arcs in the format we temporarily create in this class (a representation, essentially of
  4917	  // a Gallic Fst).
  4918	  struct TempArc {
  4919	    Label ilabel;
  4920	    StringId string;  // Look it up in the StringRepository, it's a sequence of Labels.
  4921	    OutputStateId nextstate;  // or kNoState for final weights.
  4922	    Weight weight;
  4923	  };
  4924	
  4925	  // Hashing function used in hash of subsets.
  4926	  // A subset is a pointer to vector<Element>.
  4927	  // The Elements are in sorted order on state id, and without repeated states.
  4928	  // Because the order of Elements is fixed, we can use a hashing function that is
  4929	  // order-dependent.  However the weights are not included in the hashing function--
  4930	  // we hash subsets that differ only in weight to the same key.  This is not optimal
  4931	  // in terms of the O(N) performance but typically if we have a lot of determinized
  4932	  // states that differ only in weight then the input probably was pathological in some way,
  4933	  // or even non-determinizable.
  4934	  //   We don't quantize the weights, in order to avoid inexactness in simple cases.
  4935	  // Instead we apply the delta when comparing subsets for equality, and allow a small
  4936	  // difference.
  4937	
  4938	  class SubsetKey {
  4939	   public:
  4940	    size_t operator ()(const vector<Element> * subset) const {  // hashes only the state and string.
  4941	      size_t hash = 0, factor = 1;
  4942	      for (typename vector<Element>::const_iterator iter= subset->begin(); iter != subset->end(); ++iter) {
  4943	        hash *= factor;
  4944	        hash += iter->state + reinterpret_cast<size_t>(iter->string);
  4945	        factor *= 23531;  // these numbers are primes.
  4946	      }
  4947	      return hash;
  4948	    }
  4949	  };
  4950	
  4951	  // This is the equality operator on subsets.  It checks for exact match on state-id
  4952	  // and string, and approximate match on weights.
  4953	  class SubsetEqual {
  4954	   public:
  4955	    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {
  4956	      size_t sz = s1->size();
  4957	      KALDI_ASSERT(sz>=0);
  4958	      if (sz != s2->size()) return false;
  4959	      typename vector<Element>::const_iterator iter1 = s1->begin(),
  4960	          iter1_end = s1->end(), iter2=s2->begin();
  4961	      for (; iter1 < iter1_end; ++iter1, ++iter2) {
  4962	        if (iter1->state != iter2->state ||
  4963	           iter1->string != iter2->string ||
  4964	            ! ApproxEqual(iter1->weight, iter2->weight, delta_)) return false;
  4965	      }
  4966	      return true;
  4967	    }
  4968	    float delta_;
  4969	    SubsetEqual(float delta): delta_(delta) {}
  4970	    SubsetEqual(): delta_(kDelta) {}
  4971	  };
  4972	
  4973	  // Operator that says whether two Elements have the same states.
  4974	  // Used only for debug.
  4975	  class SubsetEqualStates {
  4976	   public:
  4977	    bool operator ()(const vector<Element> * s1, const vector<Element> * s2) const {
  4978	      size_t sz = s1->size();
  4979	      KALDI_ASSERT(sz>=0);
  4980	      if (sz != s2->size()) return false;
  4981	      typename vector<Element>::const_iterator iter1 = s1->begin(),
  4982	          iter1_end = s1->end(), iter2=s2->begin();
  4983	      for (; iter1 < iter1_end; ++iter1, ++iter2) {
  4984	        if (iter1->state != iter2->state) return false;
  4985	      }
  4986	      return true;
  4987	    }
  4988	  };
  4989	
  4990	  // Define the hash type we use to map subsets (in minimal
  4991	  // representation) to OutputStateId.
  4992	  typedef unordered_map<const vector<Element>*, OutputStateId,
  4993	                        SubsetKey, SubsetEqual> MinimalSubsetHash;
  4994	
  4995	  // Define the hash type we use to map subsets (in initial
  4996	  // representation) to OutputStateId, together with an
  4997	  // extra weight. [note: we interpret the Element.state in here
  4998	  // as an OutputStateId even though it's declared as InputStateId;
  4999	  // these types are the same anyway].
  5000	  typedef unordered_map<const vector<Element>*, Element,
  5001	                        SubsetKey, SubsetEqual> InitialSubsetHash;
  5002	
  5003	
  5004	  // converts the representation of the subset from canonical (all states) to
  5005	  // minimal (only states with output symbols on arcs leaving them, and final
  5006	  // states).  Output is not necessarily normalized, even if input_subset was.
  5007	  void ConvertToMinimal(vector<Element> *subset) {
  5008	    KALDI_ASSERT(!subset->empty());
  5009	    typename vector<Element>::iterator cur_in = subset->begin(),
  5010	        cur_out = subset->begin(), end = subset->end();
  5011	    while (cur_in != end) {
  5012	      if(IsIsymbolOrFinal(cur_in->state)) {  // keep it...
  5013	        *cur_out = *cur_in;
  5014	        cur_out++;
  5015	      }
  5016	      cur_in++;
  5017	    }
  5018	    subset->resize(cur_out - subset->begin());
  5019	  }
  5020	
  5021	  // Takes a minimal, normalized subset, and converts it to an OutputStateId.
  5022	  // Involves a hash lookup, and possibly adding a new OutputStateId.
  5023	  // If it creates a new OutputStateId, it creates a new record for it, works
  5024	  // out its final-weight, and puts stuff on the queue relating to its
  5025	  // transitions.
  5026	  OutputStateId MinimalToStateId(const vector<Element> &subset,
  5027	                                 const double forward_cost) {
  5028	    typename MinimalSubsetHash::const_iterator iter
  5029	        = minimal_hash_.find(&subset);
  5030	    if (iter != minimal_hash_.end()) { // Found a matching subset.
  5031	      OutputStateId state_id = iter->second;
  5032	      const OutputState &state = *(output_states_[state_id]);
  5033	      // Below is just a check that the algorithm is working...
  5034	      if (forward_cost < state.forward_cost - 0.1) {
  5035	        // for large weights, this check could fail due to roundoff.
  5036	        KALDI_WARN << "New cost is less (check the difference is small) "
  5037	                   << forward_cost << ", "
  5038	                   << state.forward_cost;
  5039	      }
  5040	      return state_id;
  5041	    }
  5042	    OutputStateId state_id = static_cast<OutputStateId>(output_states_.size());
  5043	    OutputState *new_state = new OutputState(subset, forward_cost);
  5044	    minimal_hash_[&(new_state->minimal_subset)] = state_id;
  5045	    output_states_.push_back(new_state);
  5046	    num_elems_ += subset.size();
  5047	    // Note: in the previous algorithm, we pushed the new state-id onto the queue
  5048	    // at this point.  Here, the queue happens elsewhere, and we directly process
  5049	    // the state (which result in stuff getting added to the queue).
  5050	    ProcessFinal(state_id); // will work out the final-prob.
  5051	    ProcessTransitions(state_id); // will process transitions and add stuff to the queue.
  5052	    return state_id;
  5053	  }
  5054	
  5055	
  5056	  // Given a normalized initial subset of elements (i.e. before epsilon closure),
  5057	  // compute the corresponding output-state.
  5058	  OutputStateId InitialToStateId(const vector<Element> &subset_in,
  5059	                                 double forward_cost,
  5060	                                 Weight *remaining_weight,
  5061	                                 StringId *common_prefix) {
  5062	    typename InitialSubsetHash::const_iterator iter
  5063	        = initial_hash_.find(&subset_in);
  5064	    if (iter != initial_hash_.end()) { // Found a matching subset.
  5065	      const Element &elem = iter->second;
  5066	      *remaining_weight = elem.weight;
  5067	      *common_prefix = elem.string;
  5068	      if (elem.weight == Weight::Zero())
  5069	        KALDI_WARN << "Zero weight!";
  5070	      return elem.state;
  5071	    }
  5072	    // else no matching subset-- have to work it out.
  5073	    vector<Element> subset(subset_in);
  5074	    // Follow through epsilons.  Will add no duplicate states.  note: after
  5075	    // EpsilonClosure, it is the same as "canonical" subset, except not
  5076	    // normalized (actually we never compute the normalized canonical subset,
  5077	    // only the normalized minimal one).
  5078	    EpsilonClosure(&subset); // follow epsilons.
  5079	    ConvertToMinimal(&subset); // remove all but emitting and final states.
  5080	
  5081	    Element elem; // will be used to store remaining weight and string, and
  5082	                 // OutputStateId, in initial_hash_;
  5083	    NormalizeSubset(&subset, &elem.weight, &elem.string); // normalize subset; put
  5084	    // common string and weight in "elem".  The subset is now a minimal,
  5085	    // normalized subset.
  5086	
  5087	    forward_cost += ConvertToCost(elem.weight);
  5088	    OutputStateId ans = MinimalToStateId(subset, forward_cost);
  5089	    *remaining_weight = elem.weight;
  5090	    *common_prefix = elem.string;
  5091	    if (elem.weight == Weight::Zero())
  5092	      KALDI_WARN << "Zero weight!";
  5093	
  5094	    // Before returning "ans", add the initial subset to the hash,
  5095	    // so that we can bypass the epsilon-closure etc., next time
  5096	    // we process the same initial subset.
  5097	    vector<Element> *initial_subset_ptr = new vector<Element>(subset_in);
  5098	    elem.state = ans;
  5099	    initial_hash_[initial_subset_ptr] = elem;
  5100	    num_elems_ += initial_subset_ptr->size(); // keep track of memory usage.
  5101	    return ans;
  5102	  }
  5103	
  5104	  // returns the Compare value (-1 if a < b, 0 if a == b, 1 if a > b) according
  5105	  // to the ordering we defined on strings for the CompactLatticeWeightTpl.
  5106	  // see function
  5107	  // inline int Compare (const CompactLatticeWeightTpl<WeightType,IntType> &w1,
  5108	  //                     const CompactLatticeWeightTpl<WeightType,IntType> &w2)
  5109	  // in lattice-weight.h.
  5110	  // this is the same as that, but optimized for our data structures.
  5111	  inline int Compare(const Weight &a_w, StringId a_str,
  5112	                     const Weight &b_w, StringId b_str) const {
  5113	    int weight_comp = fst::Compare(a_w, b_w);
  5114	    if (weight_comp != 0) return weight_comp;
  5115	    // now comparing strings.
  5116	    if (a_str == b_str) return 0;
  5117	    vector<IntType> a_vec, b_vec;
  5118	    repository_.ConvertToVector(a_str, &a_vec);
  5119	    repository_.ConvertToVector(b_str, &b_vec);
  5120	    // First compare their lengths.
  5121	    int a_len = a_vec.size(), b_len = b_vec.size();
  5122	    // use opposite order on the string lengths (c.f. Compare in
  5123	    // lattice-weight.h)
  5124	    if (a_len > b_len) return -1;
  5125	    else if (a_len < b_len) return 1;
  5126	    for(int i = 0; i < a_len; i++) {
  5127	      if (a_vec[i] < b_vec[i]) return -1;
  5128	      else if (a_vec[i] > b_vec[i]) return 1;
  5129	    }
  5130	    KALDI_ASSERT(0); // because we checked if a_str == b_str above, shouldn't reach here
  5131	    return 0;
  5132	  }
  5133	
  5134	  // This function computes epsilon closure of subset of states by following epsilon links.
  5135	  // Called by InitialToStateId and Initialize.
  5136	  // Has no side effects except on the string repository.  The "output_subset" is not
  5137	  // necessarily normalized (in the sense of there being no common substring), unless
  5138	  // input_subset was.
  5139	  void EpsilonClosure(vector<Element> *subset) {
  5140	    // at input, subset must have only one example of each StateId.  [will still
  5141	    // be so at output].  This function follows input-epsilons, and augments the
  5142	    // subset accordingly.
  5143	
  5144	    std::priority_queue<Element, vector<Element>, greater<Element> > queue;
  5145	    unordered_map<InputStateId, Element> cur_subset;
  5146	    typedef typename unordered_map<InputStateId, Element>::iterator MapIter;
  5147	    typedef typename vector<Element>::const_iterator VecIter;
  5148	
  5149	    for (VecIter iter = subset->begin(); iter != subset->end(); ++iter) {
  5150	      queue.push(*iter);
  5151	      cur_subset[iter->state] = *iter;
  5152	    }
  5153	
  5154	    // find whether input fst is known to be sorted on input label.
  5155	    bool sorted = ((ifst_->Properties(kILabelSorted, false) & kILabelSorted) != 0);
  5156	    bool replaced_elems = false; // relates to an optimization, see below.
  5157	    int counter = 0; // stops infinite loops here for non-lattice-determinizable input
  5158	    // (e.g. input with negative-cost epsilon loops); useful in testing.
  5159	    while (queue.size() != 0) {
  5160	      Element elem = queue.top();
  5161	      queue.pop();
  5162	
  5163	      // The next if-statement is a kind of optimization.  It's to prevent us
  5164	      // unnecessarily repeating the processing of a state.  "cur_subset" always
  5165	      // contains only one Element with a particular state.  The issue is that
  5166	      // whenever we modify the Element corresponding to that state in "cur_subset",
  5167	      // both the new (optimal) and old (less-optimal) Element will still be in
  5168	      // "queue".  The next if-statement stops us from wasting compute by
  5169	      // processing the old Element.
  5170	      if (replaced_elems && cur_subset[elem.state] != elem)
  5171	        continue;
  5172	      if (opts_.max_loop > 0 && counter++ > opts_.max_loop) {
  5173	        KALDI_ERR << "Lattice determinization aborted since looped more than "
  5174	                  << opts_.max_loop << " times during epsilon closure.";
  5175	      }
  5176	      for (ArcIterator<ExpandedFst<Arc> > aiter(*ifst_, elem.state); !aiter.Done(); aiter.Next()) {
  5177	        const Arc &arc = aiter.Value();
  5178	        if (sorted && arc.ilabel != 0) break;  // Break from the loop: due to sorting there will be no
  5179	        // more transitions with epsilons as input labels.
  5180	        if (arc.ilabel == 0
  5181	            && arc.weight != Weight::Zero()) {  // Epsilon transition.
  5182	          Element next_elem;
  5183	          next_elem.state = arc.nextstate;
  5184	          next_elem.weight = Times(elem.weight, arc.weight);
  5185	          // next_elem.string is not set up yet... create it only
  5186	          // when we know we need it (this is an optimization)
  5187	
  5188	          MapIter iter = cur_subset.find(next_elem.state);
  5189	          if (iter == cur_subset.end()) {
  5190	            // was no such StateId: insert and add to queue.
  5191	            next_elem.string = (arc.olabel == 0 ? elem.string :
  5192	                                repository_.Successor(elem.string, arc.olabel));
  5193	            cur_subset[next_elem.state] = next_elem;
  5194	            queue.push(next_elem);
  5195	          } else {
  5196	            // was not inserted because one already there.  In normal
  5197	            // determinization we'd add the weights.  Here, we find which one
  5198	            // has the better weight, and keep its corresponding string.
  5199	            int comp = fst::Compare(next_elem.weight, iter->second.weight);
  5200	            if (comp == 0) { // A tie on weights.  This should be a rare case;
  5201	                             // we don't optimize for it.
  5202	              next_elem.string = (arc.olabel == 0 ? elem.string :
  5203	                                  repository_.Successor(elem.string,
  5204	                                                        arc.olabel));
  5205	              comp = Compare(next_elem.weight, next_elem.string,
  5206	                             iter->second.weight, iter->second.string);
  5207	            }
  5208	            if(comp == 1) { // next_elem is better, so use its (weight, string)
  5209	              next_elem.string = (arc.olabel == 0 ? elem.string :
  5210	                                  repository_.Successor(elem.string, arc.olabel));
  5211	              iter->second.string = next_elem.string;
  5212	              iter->second.weight = next_elem.weight;
  5213	              queue.push(next_elem);
  5214	              replaced_elems = true;
  5215	            }
  5216	            // else it is the same or worse, so use original one.
  5217	          }
  5218	        }
  5219	      }
  5220	    }
  5221	
  5222	    { // copy cur_subset to subset.
  5223	      subset->clear();
  5224	      subset->reserve(cur_subset.size());
  5225	      MapIter iter = cur_subset.begin(), end = cur_subset.end();
  5226	      for (; iter != end; ++iter) subset->push_back(iter->second);
  5227	      // sort by state ID, because the subset hash function is order-dependent(see SubsetKey)
  5228	      std::sort(subset->begin(), subset->end());
  5229	    }
  5230	  }
  5231	
  5232	
  5233	  // This function works out the final-weight of the determinized state.
  5234	  // called by ProcessSubset.
  5235	  // Has no side effects except on the variable repository_, and
  5236	  // output_states_[output_state_id].arcs
  5237	
  5238	  void ProcessFinal(OutputStateId output_state_id) {
  5239	    OutputState &state = *(output_states_[output_state_id]);
  5240	    const vector<Element> &minimal_subset = state.minimal_subset;
  5241	    // processes final-weights for this subset.  state.minimal_subset_ may be
  5242	    // empty if the graphs is not connected/trimmed, I think, do don't check
  5243	    // that it's nonempty.
  5244	    StringId final_string = repository_.EmptyString();  // set it to keep the
  5245	    // compiler happy; if it doesn't get set in the loop, we won't use the value anyway.
  5246	    Weight final_weight = Weight::Zero();
  5247	    bool is_final = false;
  5248	    typename vector<Element>::const_iterator iter = minimal_subset.begin(), end = minimal_subset.end();
  5249	    for (; iter != end; ++iter) {
  5250	      const Element &elem = *iter;
  5251	      Weight this_final_weight = Times(elem.weight, ifst_->Final(elem.state));
  5252	      StringId this_final_string = elem.string;
  5253	      if (this_final_weight != Weight::Zero() &&
  5254	         (!is_final || Compare(this_final_weight, this_final_string,
  5255	                               final_weight, final_string) == 1)) { // the new
  5256	        // (weight, string) pair is more in semiring than our current
  5257	        // one.
  5258	        is_final = true;
  5259	        final_weight = this_final_weight;
  5260	        final_string = this_final_string;
  5261	      }
  5262	    }
  5263	    if (is_final &&
  5264	        ConvertToCost(final_weight) + state.forward_cost <= cutoff_) {
  5265	      // store final weights in TempArc structure, just like a transition.
  5266	      // Note: we only store the final-weight if it's inside the pruning beam, hence
  5267	      // the stuff with Compare.
  5268	      TempArc temp_arc;
  5269	      temp_arc.ilabel = 0;
  5270	      temp_arc.nextstate = kNoStateId;  // special marker meaning "final weight".
  5271	      temp_arc.string = final_string;
  5272	      temp_arc.weight = final_weight;
  5273	      state.arcs.push_back(temp_arc);
  5274	      num_arcs_++;
  5275	    }
  5276	  }
  5277	
  5278	  // NormalizeSubset normalizes the subset "elems" by
  5279	  // removing any common string prefix (putting it in common_str),
  5280	  // and dividing by the total weight (putting it in tot_weight).
  5281	  void NormalizeSubset(vector<Element> *elems,
  5282	                       Weight *tot_weight,
  5283	                       StringId *common_str) {
  5284	    if(elems->empty()) { // just set common_str, tot_weight
  5285	      // to defaults and return...
  5286	      KALDI_WARN << "empty subset";
  5287	      *common_str = repository_.EmptyString();
  5288	      *tot_weight = Weight::Zero();
  5289	      return;
  5290	    }
  5291	    size_t size = elems->size();
  5292	    vector<IntType> common_prefix;
  5293	    repository_.ConvertToVector((*elems)[0].string, &common_prefix);
  5294	    Weight weight = (*elems)[0].weight;
  5295	    for(size_t i = 1; i < size; i++) {
  5296	      weight = Plus(weight, (*elems)[i].weight);
  5297	      repository_.ReduceToCommonPrefix((*elems)[i].string, &common_prefix);
  5298	    }
  5299	    KALDI_ASSERT(weight != Weight::Zero()); // we made sure to ignore arcs with zero
  5300	    // weights on them, so we shouldn't have zero here.
  5301	    size_t prefix_len = common_prefix.size();
  5302	    for(size_t i = 0; i < size; i++) {
  5303	      (*elems)[i].weight = Divide((*elems)[i].weight, weight, DIVIDE_LEFT);
  5304	      (*elems)[i].string =
  5305	          repository_.RemovePrefix((*elems)[i].string, prefix_len);
  5306	    }
  5307	    *common_str = repository_.ConvertFromVector(common_prefix);
  5308	    *tot_weight = weight;
  5309	  }
  5310	
  5311	  // Take a subset of Elements that is sorted on state, and
  5312	  // merge any Elements that have the same state (taking the best
  5313	  // (weight, string) pair in the semiring).
  5314	  void MakeSubsetUnique(vector<Element> *subset) {
  5315	    typedef typename vector<Element>::iterator IterType;
  5316	
  5317	    // This KALDI_ASSERT is designed to fail (usually) if the subset is not sorted on
  5318	    // state.
  5319	    KALDI_ASSERT(subset->size() < 2 || (*subset)[0].state <= (*subset)[1].state);
  5320	
  5321	    IterType cur_in = subset->begin(), cur_out = cur_in, end = subset->end();
  5322	    size_t num_out = 0;
  5323	    // Merge elements with same state-id
  5324	    while (cur_in != end) {  // while we have more elements to process.
  5325	      // At this point, cur_out points to location of next place we want to put an element,
  5326	      // cur_in points to location of next element we want to process.
  5327	      if (cur_in != cur_out) *cur_out = *cur_in;
  5328	      cur_in++;
  5329	      while (cur_in != end && cur_in->state == cur_out->state) {
  5330	        if (Compare(cur_in->weight, cur_in->string,
  5331	                   cur_out->weight, cur_out->string) == 1) {
  5332	          // if *cur_in > *cur_out in semiring, then take *cur_in.
  5333	          cur_out->string = cur_in->string;
  5334	          cur_out->weight = cur_in->weight;
  5335	        }
  5336	        cur_in++;
  5337	      }
  5338	      cur_out++;
  5339	      num_out++;
  5340	    }
  5341	    subset->resize(num_out);
  5342	  }
  5343	
  5344	  // ProcessTransition was called from "ProcessTransitions" in the non-pruned
  5345	  // code, but now we in effect put the calls to ProcessTransition on a priority
  5346	  // queue, and it now gets called directly from Determinize().  This function
  5347	  // processes a transition from state "ostate_id".  The set "subset" of Elements
  5348	  // represents a set of next-states with associated weights and strings, each
  5349	  // one arising from an arc from some state in a determinized-state; the
  5350	  // next-states are unique (there is only one Entry assocated with each)
  5351	  void ProcessTransition(OutputStateId ostate_id, Label ilabel, vector<Element> *subset) {
  5352	
  5353	    double forward_cost = output_states_[ostate_id]->forward_cost;
  5354	    StringId common_str;
  5355	    Weight tot_weight;
  5356	    NormalizeSubset(subset, &tot_weight, &common_str);
  5357	    forward_cost += ConvertToCost(tot_weight);
  5358	
  5359	    OutputStateId nextstate;
  5360	    {
  5361	      Weight next_tot_weight;
  5362	      StringId next_common_str;
  5363	      nextstate = InitialToStateId(*subset,
  5364	                                   forward_cost,
  5365	                                   &next_tot_weight,
  5366	                                   &next_common_str);
  5367	      common_str = repository_.Concatenate(common_str, next_common_str);
  5368	      tot_weight = Times(tot_weight, next_tot_weight);
  5369	    }
  5370	
  5371	    // Now add an arc to the next state (would have been created if necessary by
  5372	    // InitialToStateId).
  5373	    TempArc temp_arc;
  5374	    temp_arc.ilabel = ilabel;
  5375	    temp_arc.nextstate = nextstate;
  5376	    temp_arc.string = common_str;
  5377	    temp_arc.weight = tot_weight;
  5378	    output_states_[ostate_id]->arcs.push_back(temp_arc);  // record the arc.
  5379	    num_arcs_++;
  5380	  }
  5381	
  5382	
  5383	  // "less than" operator for pair<Label, Element>.   Used in ProcessTransitions.
  5384	  // Lexicographical order, which only compares the state when ordering the
  5385	  // "Element" member of the pair.
  5386	
  5387	  class PairComparator {
  5388	   public:
  5389	    inline bool operator () (const pair<Label, Element> &p1, const pair<Label, Element> &p2) {
  5390	      if (p1.first < p2.first) return true;
  5391	      else if (p1.first > p2.first) return false;
  5392	      else {
  5393	        return p1.second.state < p2.second.state;
  5394	      }
  5395	    }
  5396	  };
  5397	
  5398	
  5399	  // ProcessTransitions processes emitting transitions (transitions with
  5400	  // ilabels) out of this subset of states.  It actualy only creates records
  5401	  // ("Task") that get added to the queue.  The transitions will be processed in
  5402	  // priority order from Determinize().  This function soes not consider final
  5403	  // states.  Partitions the emitting transitions up by ilabel (by sorting on
  5404	  // ilabel), and for each unique ilabel, it creates a Task record that contains
  5405	  // the information we need to process the transition.
  5406	
  5407	  void ProcessTransitions(OutputStateId output_state_id) {
  5408	    const vector<Element> &minimal_subset = output_states_[output_state_id]->minimal_subset;
  5409	    // it's possible that minimal_subset could be empty if there are
  5410	    // unreachable parts of the graph, so don't check that it's nonempty.
  5411	    vector<pair<Label, Element> > &all_elems(all_elems_tmp_); // use class member
  5412	    // to avoid memory allocation/deallocation.
  5413	    {
  5414	      // Push back into "all_elems", elements corresponding to all
  5415	      // non-epsilon-input transitions out of all states in "minimal_subset".
  5416	      typename vector<Element>::const_iterator iter = minimal_subset.begin(), end = minimal_subset.end();
  5417	      for (;iter != end; ++iter) {
  5418	        const Element &elem = *iter;
  5419	        for (ArcIterator<ExpandedFst<Arc> > aiter(*ifst_, elem.state); ! aiter.Done(); aiter.Next()) {
  5420	          const Arc &arc = aiter.Value();
  5421	          if (arc.ilabel != 0
  5422	              && arc.weight != Weight::Zero()) {  // Non-epsilon transition -- ignore epsilons here.
  5423	            pair<Label, Element> this_pr;
  5424	            this_pr.first = arc.ilabel;
  5425	            Element &next_elem(this_pr.second);
  5426	            next_elem.state = arc.nextstate;
  5427	            next_elem.weight = Times(elem.weight, arc.weight);
  5428	            if (arc.olabel == 0) // output epsilon
  5429	              next_elem.string = elem.string;
  5430	            else
  5431	              next_elem.string = repository_.Successor(elem.string, arc.olabel);
  5432	            all_elems.push_back(this_pr);
  5433	          }
  5434	        }
  5435	      }
  5436	    }
  5437	    PairComparator pc;
  5438	    std::sort(all_elems.begin(), all_elems.end(), pc);
  5439	    // now sorted first on input label, then on state.
  5440	    typedef typename vector<pair<Label, Element> >::const_iterator PairIter;
  5441	    PairIter cur = all_elems.begin(), end = all_elems.end();
  5442	    while (cur != end) {
  5443	      // The old code (non-pruned) called ProcessTransition; here, instead,
  5444	      // we'll put the calls into a priority queue.
  5445	      Task *task = new Task;
  5446	      // Process ranges that share the same input symbol.
  5447	      Label ilabel = cur->first;
  5448	      task->state = output_state_id;
  5449	      task->priority_cost = std::numeric_limits<double>::infinity();
  5450	      task->label = ilabel;
  5451	      while (cur != end && cur->first == ilabel) {
  5452	        task->subset.push_back(cur->second);
  5453	        const Element &element = cur->second;
  5454	        // Note: we'll later include the term "forward_cost" in the
  5455	        // priority_cost.
  5456	        task->priority_cost = std::min(task->priority_cost,
  5457	                                       ConvertToCost(element.weight) +
  5458	                                       backward_costs_[element.state]);
  5459	        cur++;
  5460	      }
  5461	
  5462	      // After the command below, the "priority_cost" is a value comparable to
  5463	      // the total-weight of the input FST, like a total-path weight... of
  5464	      // course, it will typically be less (in the semiring) than that.
  5465	      // note: we represent it just as a double.
  5466	      task->priority_cost += output_states_[output_state_id]->forward_cost;
  5467	
  5468	      if (task->priority_cost > cutoff_) {
  5469	        // This task would never get done as it's past the pruning cutoff.
  5470	        delete task;
  5471	      } else {
  5472	        MakeSubsetUnique(&(task->subset)); // remove duplicate Elements with the same state.
  5473	        queue_.push(task); // Push the task onto the queue.  The queue keeps it
  5474	        // in prioritized order, so we always process the one with the "best"
  5475	        // weight (highest in the semiring).
  5476	
  5477	        { // this is a check.
  5478	          double best_cost = backward_costs_[ifst_->Start()],
  5479	              tolerance = 0.01 + 1.0e-04 * std::abs(best_cost);
  5480	          if (task->priority_cost < best_cost - tolerance) {
  5481	            KALDI_WARN << "Cost below best cost was encountered:"
  5482	                       << task->priority_cost << " < " << best_cost;
  5483	          }
  5484	        }
  5485	      }
  5486	    }
  5487	    all_elems.clear(); // as it's a reference to a class variable; we want it to stay
  5488	    // empty.
  5489	  }
  5490	
  5491	
  5492	  bool IsIsymbolOrFinal(InputStateId state) { // returns true if this state
  5493	    // of the input FST either is final or has an osymbol on an arc out of it.
  5494	    // Uses the vector isymbol_or_final_ as a cache for this info.
  5495	    KALDI_ASSERT(state >= 0);
  5496	    if (isymbol_or_final_.size() <= state)
  5497	      isymbol_or_final_.resize(state+1, static_cast<char>(OSF_UNKNOWN));
  5498	    if (isymbol_or_final_[state] == static_cast<char>(OSF_NO))
  5499	      return false;
  5500	    else if (isymbol_or_final_[state] == static_cast<char>(OSF_YES))
  5501	      return true;
  5502	    // else work it out...
  5503	    isymbol_or_final_[state] = static_cast<char>(OSF_NO);
  5504	    if (ifst_->Final(state) != Weight::Zero())
  5505	      isymbol_or_final_[state] = static_cast<char>(OSF_YES);
  5506	    for (ArcIterator<ExpandedFst<Arc> > aiter(*ifst_, state);
  5507	         !aiter.Done();
  5508	         aiter.Next()) {
  5509	      const Arc &arc = aiter.Value();
  5510	      if (arc.ilabel != 0 && arc.weight != Weight::Zero()) {
  5511	        isymbol_or_final_[state] = static_cast<char>(OSF_YES);
  5512	        return true;
  5513	      }
  5514	    }
  5515	    return IsIsymbolOrFinal(state); // will only recurse once.
  5516	  }
  5517	
  5518	  void ComputeBackwardWeight() {
  5519	    // Sets up the backward_costs_ array, and the cutoff_ variable.
  5520	    KALDI_ASSERT(beam_ > 0);
  5521	
  5522	    // Only handle the toplogically sorted case.
  5523	    backward_costs_.resize(ifst_->NumStates());
  5524	    for (StateId s = ifst_->NumStates() - 1; s >= 0; s--) {
  5525	      double &cost = backward_costs_[s];
  5526	      cost = ConvertToCost(ifst_->Final(s));
  5527	      for (ArcIterator<ExpandedFst<Arc> > aiter(*ifst_, s);
  5528	           !aiter.Done(); aiter.Next()) {
  5529	        const Arc &arc = aiter.Value();
  5530	        cost = std::min(cost,
  5531	                        ConvertToCost(arc.weight) + backward_costs_[arc.nextstate]);
  5532	      }
  5533	    }
  5534	
  5535	    if (ifst_->Start() == kNoStateId) return; // we'll be returning
  5536	    // an empty FST.
  5537	
  5538	    double best_cost = backward_costs_[ifst_->Start()];
  5539	    if (best_cost == std::numeric_limits<double>::infinity())
  5540	      KALDI_WARN << "Total weight of input lattice is zero.";
  5541	    cutoff_ = best_cost + beam_;
  5542	  }
  5543	
  5544	  void InitializeDeterminization() {
  5545	    // We insist that the input lattice be topologically sorted.  This is not a
  5546	    // fundamental limitation of the algorithm (which in principle should be
  5547	    // applicable to even cyclic FSTs), but it helps us more efficiently
  5548	    // compute the backward_costs_ array.  There may be some other reason we
  5549	    // require this, that escapes me at the moment.
  5550	    KALDI_ASSERT(ifst_->Properties(kTopSorted, true) != 0);
  5551	    ComputeBackwardWeight();
  5552	#if !(__GNUC__ == 4 && __GNUC_MINOR__ == 0)
  5553	    if(ifst_->Properties(kExpanded, false) != 0) { // if we know the number of
  5554	      // states in ifst_, it might be a bit more efficient
  5555	      // to pre-size the hashes so we're not constantly rebuilding them.
  5556	      StateId num_states =
  5557	          down_cast<const ExpandedFst<Arc>*, const Fst<Arc> >(ifst_)->NumStates();
  5558	      minimal_hash_.rehash(num_states/2 + 3);
  5559	      initial_hash_.rehash(num_states/2 + 3);
  5560	    }
  5561	#endif
  5562	    InputStateId start_id = ifst_->Start();
  5563	    if (start_id != kNoStateId) {
  5564	      /* Create determinized-state corresponding to the start state....
  5565	         Unlike all the other states, we don't "normalize" the representation
  5566	         of this determinized-state before we put it into minimal_hash_.  This is actually
  5567	         what we want, as otherwise we'd have problems dealing with any extra weight
  5568	         and string and might have to create a "super-initial" state which would make
  5569	         the output nondeterministic.  Normalization is only needed to make the
  5570	         determinized output more minimal anyway, it's not needed for correctness.
  5571	         Note, we don't put anything in the initial_hash_.  The initial_hash_ is only
  5572	         a lookaside buffer anyway, so this isn't a problem-- it will get populated
  5573	         later if it needs to be.
  5574	      */
  5575	      vector<Element> subset(1);
  5576	      subset[0].state = start_id;
  5577	      subset[0].weight = Weight::One();
  5578	      subset[0].string = repository_.EmptyString();  // Id of empty sequence.
  5579	      EpsilonClosure(&subset); // follow through epsilon-input links
  5580	      ConvertToMinimal(&subset); // remove all but final states and
  5581	      // states with input-labels on arcs out of them.
  5582	      // Weight::One() is the "forward-weight" of this determinized state...
  5583	      // i.e. the minimal cost from the start of the determinized FST to this
  5584	      // state [One() because it's the start state].
  5585	      OutputState *initial_state = new OutputState(subset, 0);
  5586	      KALDI_ASSERT(output_states_.empty());
  5587	      output_states_.push_back(initial_state);
  5588	      num_elems_ += subset.size();
  5589	      OutputStateId initial_state_id = 0;
  5590	      minimal_hash_[&(initial_state->minimal_subset)] = initial_state_id;
  5591	      ProcessFinal(initial_state_id);
  5592	      ProcessTransitions(initial_state_id); // this will add tasks to
  5593	      // the queue, which we'll start processing in Determinize().
  5594	    }
  5595	  }
  5596	
  5597	  KALDI_DISALLOW_COPY_AND_ASSIGN(LatticeDeterminizerPruned);
  5598	
  5599	  struct OutputState {
  5600	    vector<Element> minimal_subset;
  5601	    vector<TempArc> arcs; // arcs out of the state-- those that have been processed.
  5602	    // Note: the final-weight is included here with kNoStateId as the state id.  We
  5603	    // always process the final-weight regardless of the beam; when producing the
  5604	    // output we may have to ignore some of these.
  5605	    double forward_cost; // Represents minimal cost from start-state
  5606	    // to this state.  Used in prioritization of tasks, and pruning.
  5607	    // Note: we know this minimal cost from when we first create the OutputState;
  5608	    // this is because of the priority-queue we use, that ensures that the
  5609	    // "best" path into the state will be expanded first.
  5610	    OutputState(const vector<Element> &minimal_subset,
  5611	                double forward_cost): minimal_subset(minimal_subset),
  5612	                                      forward_cost(forward_cost) { }
  5613	  };
  5614	
  5615	  vector<OutputState*> output_states_; // All the info about the output states.
  5616	
  5617	  int num_arcs_; // keep track of memory usage: number of arcs in output_states_[ ]->arcs
  5618	  int num_elems_; // keep track of memory usage: number of elems in output_states_ and
  5619	  // the keys of initial_hash_
  5620	
  5621	  const ExpandedFst<Arc> *ifst_;
  5622	  std::vector<double> backward_costs_; // This vector stores, for every state in ifst_,
  5623	  // the minimal cost to the end-state (i.e. the sum of weights; they are guaranteed to
  5624	  // have "take-the-minimum" semantics).  We get the double from the ConvertToCost()
  5625	  // function on the lattice weights.
  5626	
  5627	  double beam_;
  5628	  double cutoff_; // beam plus total-weight of input (and note, the weight is
  5629	  // guaranteed to be "tropical-like" so the sum does represent a min-cost.
  5630	
  5631	  DeterminizeLatticePrunedOptions opts_;
  5632	  SubsetKey hasher_;  // object that computes keys-- has no data members.
  5633	  SubsetEqual equal_;  // object that compares subsets-- only data member is delta_.
  5634	  bool determinized_; // set to true when user called Determinize(); used to make
  5635	  // sure this object is used correctly.
  5636	  MinimalSubsetHash minimal_hash_;  // hash from Subset to OutputStateId.  Subset is "minimal
  5637	                                    // representation" (only include final and states and states with
  5638	                                    // nonzero ilabel on arc out of them.  Owns the pointers
  5639	                                    // in its keys.
  5640	  InitialSubsetHash initial_hash_;   // hash from Subset to Element, which
  5641	                                     // represents the OutputStateId together
  5642	                                     // with an extra weight and string.  Subset
  5643	                                     // is "initial representation".  The extra
  5644	                                     // weight and string is needed because after
  5645	                                     // we convert to minimal representation and
  5646	                                     // normalize, there may be an extra weight
  5647	                                     // and string.  Owns the pointers
  5648	                                     // in its keys.
  5649	
  5650	  struct Task {
  5651	    OutputStateId state; // State from which we're processing the transition.
  5652	    Label label; // Label on the transition we're processing out of this state.
  5653	    vector<Element> subset; // Weighted subset of states (with strings)-- not normalized.
  5654	    double priority_cost; // Cost used in deciding priority of tasks.  Note:
  5655	    // we assume there is a ConvertToCost() function that converts the semiring to double.
  5656	  };
  5657	
  5658	  struct TaskCompare {
  5659	    inline int operator() (const Task *t1, const Task *t2) {
  5660	      // view this like operator <, which is the default template parameter
  5661	      // to std::priority_queue.
  5662	      // returns true if t1 is worse than t2.
  5663	      return (t1->priority_cost > t2->priority_cost);
  5664	    }
  5665	  };
  5666	
  5667	  // This priority queue contains "Task"s to be processed; these correspond
  5668	  // to transitions out of determinized states.  We process these in priority
  5669	  // order according to the best weight of any path passing through these
  5670	  // determinized states... it's possible to work this out.
  5671	  std::priority_queue<Task*, vector<Task*>, TaskCompare> queue_;
  5672	
  5673	  vector<pair<Label, Element> > all_elems_tmp_; // temporary vector used in ProcessTransitions.
  5674	
  5675	  enum IsymbolOrFinal { OSF_UNKNOWN = 0, OSF_NO = 1, OSF_YES = 2 };
  5676	
  5677	  vector<char> isymbol_or_final_; // A kind of cache; it says whether
  5678	  // each state is (emitting or final) where emitting means it has at least one
  5679	  // non-epsilon output arc.  Only accessed by IsIsymbolOrFinal()
  5680	
  5681	  LatticeStringRepository<IntType> repository_;  // defines a compact and fast way of
  5682	  // storing sequences of labels.
  5683	
  5684	  void AddStrings(const vector<Element> &vec,
  5685	                  vector<StringId> *needed_strings) {
  5686	    for (typename std::vector<Element>::const_iterator iter = vec.begin();
  5687	         iter != vec.end(); ++iter)
  5688	      needed_strings->push_back(iter->string);
  5689	  }
  5690	};
  5691	
  5692	
  5693	// normally Weight would be LatticeWeight<float> (which has two floats),
  5694	// or possibly TropicalWeightTpl<float>, and IntType would be int32.
  5695	// Caution: there are two versions of the function DeterminizeLatticePruned,
  5696	// with identical code but different output FST types.
  5697	template<class Weight, class IntType>
  5698	bool DeterminizeLatticePruned(
  5699	    const ExpandedFst<ArcTpl<Weight> >&ifst,
  5700	    double beam,
  5701	    MutableFst<ArcTpl<CompactLatticeWeightTpl<Weight, IntType> > >*ofst,
  5702	    DeterminizeLatticePrunedOptions opts) {
  5703	  ofst->SetInputSymbols(ifst.InputSymbols());
  5704	  ofst->SetOutputSymbols(ifst.OutputSymbols());
  5705	  if (ifst.NumStates() == 0) {
  5706	    ofst->DeleteStates();
  5707	    return true;
  5708	  }
  5709	  KALDI_ASSERT(opts.retry_cutoff >= 0.0 && opts.retry_cutoff < 1.0);
  5710	  int32 max_num_iters = 10;  // avoid the potential for infinite loops if
  5711	                             // retrying.
  5712	  VectorFst<ArcTpl<Weight> > temp_fst;
  5713	
  5714	  for (int32 iter = 0; iter < max_num_iters; iter++) {
  5715	    LatticeDeterminizerPruned<Weight, IntType> det(iter == 0 ? ifst : temp_fst,
  5716	                                                   beam, opts);
  5717	    double effective_beam;
  5718	    bool ans = det.Determinize(&effective_beam);
  5719	    // if it returns false it will typically still produce reasonable output,
  5720	    // just with a narrower beam than "beam".  If the user specifies an infinite
  5721	    // beam we don't do this beam-narrowing.
  5722	    if (effective_beam >= beam * opts.retry_cutoff ||
  5723	        beam == std::numeric_limits<double>::infinity() ||
  5724	        iter + 1 == max_num_iters) {
  5725	      det.Output(ofst);
  5726	      return ans;
  5727	    } else {
  5728	      // The code below to set "beam" is a heuristic.
  5729	      // If effective_beam is very small, we want to reduce by a lot.
  5730	      // But never change the beam by more than a factor of two.
  5731	      if (effective_beam < 0.0) effective_beam = 0.0;
  5732	      double new_beam = beam * sqrt(effective_beam / beam);
  5733	      if (new_beam < 0.5 * beam) new_beam = 0.5 * beam;
  5734	      beam = new_beam;
  5735	      if (iter == 0) temp_fst = ifst;
  5736	      kaldi::PruneLattice(beam, &temp_fst);
  5737	      KALDI_LOG << "Pruned state-level lattice with beam " << beam
  5738	                << " and retrying determinization with that beam.";
  5739	    }
  5740	  }
  5741	  return false; // Suppress compiler warning; this code is unreachable.
  5742	}
  5743	
  5744	
  5745	// normally Weight would be LatticeWeight<float> (which has two floats),
  5746	// or possibly TropicalWeightTpl<float>, and IntType would be int32.
  5747	// Caution: there are two versions of the function DeterminizeLatticePruned,
  5748	// with identical code but different output FST types.
  5749	template<class Weight>
  5750	bool DeterminizeLatticePruned(const ExpandedFst<ArcTpl<Weight> > &ifst,
  5751	                              double beam,
  5752	                              MutableFst<ArcTpl<Weight> > *ofst,
  5753	                              DeterminizeLatticePrunedOptions opts) {
  5754	  typedef int32 IntType;
  5755	  ofst->SetInputSymbols(ifst.InputSymbols());
  5756	  ofst->SetOutputSymbols(ifst.OutputSymbols());
  5757	  KALDI_ASSERT(opts.retry_cutoff >= 0.0 && opts.retry_cutoff < 1.0);
  5758	  if (ifst.NumStates() == 0) {
  5759	    ofst->DeleteStates();
  5760	    return true;
  5761	  }
  5762	  int32 max_num_iters = 10;  // avoid the potential for infinite loops if
  5763	                             // retrying.
  5764	  VectorFst<ArcTpl<Weight> > temp_fst;
  5765	
  5766	  for (int32 iter = 0; iter < max_num_iters; iter++) {
  5767	    LatticeDeterminizerPruned<Weight, IntType> det(iter == 0 ? ifst : temp_fst,
  5768	                                                   beam, opts);
  5769	    double effective_beam;
  5770	    bool ans = det.Determinize(&effective_beam);
  5771	    // if it returns false it will typically still
  5772	    // produce reasonable output, just with a
  5773	    // narrower beam than "beam".
  5774	    if (effective_beam >= beam * opts.retry_cutoff ||
  5775	        iter + 1 == max_num_iters) {
  5776	      det.Output(ofst);
  5777	      return ans;
  5778	    } else {
  5779	      // The code below to set "beam" is a heuristic.
  5780	      // If effective_beam is very small, we want to reduce by a lot.
  5781	      // But never change the beam by more than a factor of two.
  5782	      if (effective_beam < 0)
  5783	        effective_beam = 0;
  5784	      double new_beam = beam * sqrt(effective_beam / beam);
  5785	      if (new_beam < 0.5 * beam) new_beam = 0.5 * beam;
  5786	      KALDI_WARN << "Effective beam " << effective_beam << " was less than beam "
  5787	                 << beam << " * cutoff " << opts.retry_cutoff << ", pruning raw "
  5788	                 << "lattice with new beam " << new_beam << " and retrying.";
  5789	      beam = new_beam;
  5790	      if (iter == 0) temp_fst = ifst;
  5791	      kaldi::PruneLattice(beam, &temp_fst);
  5792	    }
  5793	  }
  5794	  return false; // Suppress compiler warning; this code is unreachable.
  5795	}
  5796	
  5797	// template<class Weight>
  5798	// typename ArcTpl<Weight>::Label DeterminizeLatticeInsertPhones(
  5799	//     const kaldi::TransitionModel &trans_model,
  5800	//     MutableFst<ArcTpl<Weight> > *fst) {
  5801	//   // Define some types.
  5802	//   typedef ArcTpl<Weight> Arc;
  5803	//   typedef typename Arc::StateId StateId;
  5804	//   typedef typename Arc::Label Label;
  5805	//
  5806	//   // Work out the first phone symbol. This is more related to the phone
  5807	//   // insertion function, so we put it here and make it the returning value of
  5808	//   // DeterminizeLatticeInsertPhones().
  5809	//   Label first_phone_label = HighestNumberedInputSymbol(*fst) + 1;
  5810	//
  5811	//   // Insert phones here.
  5812	//   for (StateIterator<MutableFst<Arc> > siter(*fst);
  5813	//        !siter.Done(); siter.Next()) {
  5814	//     StateId state = siter.Value();
  5815	//     if (state == fst->Start())
  5816	//       continue;
  5817	//     for (MutableArcIterator<MutableFst<Arc> > aiter(fst, state);
  5818	//          !aiter.Done(); aiter.Next()) {
  5819	//       Arc arc = aiter.Value();
  5820	//
  5821	//       // Note: the words are on the input symbol side and transition-id's are on
  5822	//       // the output symbol side.
  5823	//       if ((arc.olabel != 0)
  5824	//           && (trans_model.TransitionIdToHmmState(arc.olabel) == 0)
  5825	//           && (!trans_model.IsSelfLoop(arc.olabel))) {
  5826	//         Label phone =
  5827	//             static_cast<Label>(trans_model.TransitionIdToPhone(arc.olabel));
  5828	//
  5829	//         // Skips <eps>.
  5830	//         KALDI_ASSERT(phone != 0);
  5831	//
  5832	//         if (arc.ilabel == 0) {
  5833	//           // If there is no word on the arc, insert the phone directly.
  5834	//           arc.ilabel = first_phone_label + phone;
  5835	//         } else {
  5836	//           // Otherwise, add an additional arc.
  5837	//           StateId additional_state = fst->AddState();
  5838	//           StateId next_state = arc.nextstate;
  5839	//           arc.nextstate = additional_state;
  5840	//           fst->AddArc(additional_state,
  5841	//                       Arc(first_phone_label + phone, 0,
  5842	//                           Weight::One(), next_state));
  5843	//         }
  5844	//       }
  5845	//
  5846	//       aiter.SetValue(arc);
  5847	//     }
  5848	//   }
  5849	//
  5850	//   return first_phone_label;
  5851	// }
  5852	//
  5853	// template<class Weight>
  5854	// void DeterminizeLatticeDeletePhones(
  5855	//     typename ArcTpl<Weight>::Label first_phone_label,
  5856	//     MutableFst<ArcTpl<Weight> > *fst) {
  5857	//   // Define some types.
  5858	//   typedef ArcTpl<Weight> Arc;
  5859	//   typedef typename Arc::StateId StateId;
  5860	//   typedef typename Arc::Label Label;
  5861	//
  5862	//   // Delete phones here.
  5863	//   for (StateIterator<MutableFst<Arc> > siter(*fst);
  5864	//        !siter.Done(); siter.Next()) {
  5865	//     StateId state = siter.Value();
  5866	//     for (MutableArcIterator<MutableFst<Arc> > aiter(fst, state);
  5867	//          !aiter.Done(); aiter.Next()) {
  5868	//       Arc arc = aiter.Value();
  5869	//
  5870	//       if (arc.ilabel >= first_phone_label)
  5871	//         arc.ilabel = 0;
  5872	//
  5873	//       aiter.SetValue(arc);
  5874	//     }
  5875	//   }
  5876	// }
  5877	// instantiate for type LatticeWeight
  5878	// template
  5879	// void DeterminizeLatticeDeletePhones(
  5880	//     ArcTpl<kaldi::LatticeWeight>::Label first_phone_label,
  5881	//     MutableFst<ArcTpl<kaldi::LatticeWeight> > *fst);
  5882	//
  5883	// /** This function does a first pass determinization with phone symbols inserted
  5884	//     at phone boundary. It uses a transition model to work out the transition-id
  5885	//     to phone map. First, phones will be inserted into the word level lattice.
  5886	//     Second, determinization will be applied on top of the phone + word lattice.
  5887	//     Finally, the inserted phones will be removed, converting the lattice back to
  5888	//     a word level lattice. The output lattice of this pass is not deterministic,
  5889	//     since we remove the phone symbols as a last step. It is supposed to be
  5890	//     followed by another pass of determinization at the word level. It could also
  5891	//     be useful for some other applications such as fMLLR estimation, confidence
  5892	//     estimation, discriminative training, etc.
  5893	// */
  5894	// template<class Weight, class IntType>
  5895	// bool DeterminizeLatticePhonePrunedFirstPass(
  5896	//     const kaldi::TransitionModel &trans_model,
  5897	//     double beam,
  5898	//     MutableFst<ArcTpl<Weight> > *fst,
  5899	//     const DeterminizeLatticePrunedOptions &opts) {
  5900	//   // First, insert the phones.
  5901	//   typename ArcTpl<Weight>::Label first_phone_label =
  5902	//       DeterminizeLatticeInsertPhones(trans_model, fst);
  5903	//   TopSort(fst);
  5904	//
  5905	//   // Second, do determinization with phone inserted.
  5906	//   bool ans = DeterminizeLatticePruned<Weight>(*fst, beam, fst, opts);
  5907	//
  5908	//   // Finally, remove the inserted phones.
  5909	//   DeterminizeLatticeDeletePhones(first_phone_label, fst);
  5910	//   TopSort(fst);
  5911	//
  5912	//   return ans;
  5913	// }
  5914	//
  5915	// // "Destructive" version of DeterminizeLatticePhonePruned() where the input
  5916	// // lattice might be modified.
  5917	// template<class Weight, class IntType>
  5918	// bool DeterminizeLatticePhonePruned(
  5919	//     const kaldi::TransitionModel &trans_model,
  5920	//     MutableFst<ArcTpl<Weight> > *ifst,
  5921	//     double beam,
  5922	//     MutableFst<ArcTpl<CompactLatticeWeightTpl<Weight, IntType> > > *ofst,
  5923	//     DeterminizeLatticePhonePrunedOptions opts) {
  5924	//   // Returning status.
  5925	//   bool ans = true;
  5926	//
  5927	//   // Make sure at least one of opts.phone_determinize and opts.word_determinize
  5928	//   // is not false, otherwise calling this function doesn't make any sense.
  5929	//   if ((opts.phone_determinize || opts.word_determinize) == false) {
  5930	//     KALDI_WARN << "Both --phone-determinize and --word-determinize are set to "
  5931	//                << "false, copying lattice without determinization.";
  5932	//     // We are expecting the words on the input side.
  5933	//     ConvertLattice<Weight, IntType>(*ifst, ofst, false);
  5934	//     return ans;
  5935	//   }
  5936	//
  5937	//   // Determinization options.
  5938	//   DeterminizeLatticePrunedOptions det_opts;
  5939	//   det_opts.delta = opts.delta;
  5940	//   det_opts.max_mem = opts.max_mem;
  5941	//
  5942	//   // If --phone-determinize is true, do the determinization on phone + word
  5943	//   // lattices.
  5944	//   if (opts.phone_determinize) {
  5945	//     KALDI_VLOG(3) << "Doing first pass of determinization on phone + word "
  5946	//                   << "lattices.";
  5947	//     ans = DeterminizeLatticePhonePrunedFirstPass<Weight, IntType>(
  5948	//         trans_model, beam, ifst, det_opts) && ans;
  5949	//
  5950	//     // If --word-determinize is false, we've finished the job and return here.
  5951	//     if (!opts.word_determinize) {
  5952	//       // We are expecting the words on the input side.
  5953	//       ConvertLattice<Weight, IntType>(*ifst, ofst, false);
  5954	//       return ans;
  5955	//     }
  5956	//   }
  5957	//
  5958	//   // If --word-determinize is true, do the determinization on word lattices.
  5959	//   if (opts.word_determinize) {
  5960	//     KALDI_VLOG(3) << "Doing second pass of determinization on word lattices.";
  5961	//     ans = DeterminizeLatticePruned<Weight, IntType>(
  5962	//         *ifst, beam, ofst, det_opts) && ans;
  5963	//   }
  5964	//
  5965	//   // If --minimize is true, push and minimize after determinization.
  5966	//   if (opts.minimize) {
  5967	//     KALDI_VLOG(3) << "Pushing and minimizing on word lattices.";
  5968	//     ans = PushCompactLatticeStrings<Weight, IntType>(ofst) && ans;
  5969	//     ans = PushCompactLatticeWeights<Weight, IntType>(ofst) && ans;
  5970	//     ans = MinimizeCompactLattice<Weight, IntType>(ofst) && ans;
  5971	//   }
  5972	//
  5973	//   return ans;
  5974	// }
  5975	//
  5976	// // Normal verson of DeterminizeLatticePhonePruned(), where the input lattice
  5977	// // will be kept as unchanged.
  5978	// template<class Weight, class IntType>
  5979	// bool DeterminizeLatticePhonePruned(
  5980	//     const kaldi::TransitionModel &trans_model,
  5981	//     const ExpandedFst<ArcTpl<Weight> > &ifst,
  5982	//     double beam,
  5983	//     MutableFst<ArcTpl<CompactLatticeWeightTpl<Weight, IntType> > > *ofst,
  5984	//     DeterminizeLatticePhonePrunedOptions opts) {
  5985	//   VectorFst<ArcTpl<Weight> > temp_fst(ifst);
  5986	//   return DeterminizeLatticePhonePruned(trans_model, &temp_fst,
  5987	//                                        beam, ofst, opts);
  5988	// }
  5989	//
  5990	// bool DeterminizeLatticePhonePrunedWrapper(
  5991	//     const kaldi::TransitionModel &trans_model,
  5992	//     MutableFst<kaldi::LatticeArc> *ifst,
  5993	//     double beam,
  5994	//     MutableFst<kaldi::CompactLatticeArc> *ofst,
  5995	//     DeterminizeLatticePhonePrunedOptions opts) {
  5996	//   bool ans = true;
  5997	//   Invert(ifst);
  5998	//   if (ifst->Properties(fst::kTopSorted, true) == 0) {
  5999	//     if (!TopSort(ifst)) {
  6000	//       // Cannot topologically sort the lattice -- determinization will fail.
  6001	//       KALDI_ERR << "Topological sorting of state-level lattice failed (probably"
  6002	//                 << " your lexicon has empty words or your LM has epsilon cycles"
  6003	//                 << ").";
  6004	//     }
  6005	//   }
  6006	//   ILabelCompare<kaldi::LatticeArc> ilabel_comp;
  6007	//   ArcSort(ifst, ilabel_comp);
  6008	//   ans = DeterminizeLatticePhonePruned<kaldi::LatticeWeight, kaldi::int32>(
  6009	//       trans_model, ifst, beam, ofst, opts);
  6010	//   Connect(ofst);
  6011	//   return ans;
  6012	// }
  6013	
  6014	// Instantiate the templates for the types we might need.
  6015	// Note: there are actually four templates, each of which
  6016	// we instantiate for a single type.
  6017	template
  6018	bool DeterminizeLatticePruned<kaldi::LatticeWeight>(
  6019	    const ExpandedFst<kaldi::LatticeArc> &ifst,
  6020	    double prune,
  6021	    MutableFst<kaldi::CompactLatticeArc> *ofst,
  6022	    DeterminizeLatticePrunedOptions opts);
  6023	
  6024	template
  6025	bool DeterminizeLatticePruned<kaldi::LatticeWeight>(
  6026	    const ExpandedFst<kaldi::LatticeArc> &ifst,
  6027	    double prune,
  6028	    MutableFst<kaldi::LatticeArc> *ofst,
  6029	    DeterminizeLatticePrunedOptions opts);
  6030	
  6031	// template
  6032	// bool DeterminizeLatticePhonePruned<kaldi::LatticeWeight, kaldi::int32>(
  6033	//     const kaldi::TransitionModel &trans_model,
  6034	//     const ExpandedFst<kaldi::LatticeArc> &ifst,
  6035	//     double prune,
  6036	//     MutableFst<kaldi::CompactLatticeArc> *ofst,
  6037	//     DeterminizeLatticePhonePrunedOptions opts);
  6038	//
  6039	// template
  6040	// bool DeterminizeLatticePhonePruned<kaldi::LatticeWeight, kaldi::int32>(
  6041	//     const kaldi::TransitionModel &trans_model,
  6042	//     MutableFst<kaldi::LatticeArc> *ifst,
  6043	//     double prune,
  6044	//     MutableFst<kaldi::CompactLatticeArc> *ofst,
  6045	//     DeterminizeLatticePhonePrunedOptions opts);
  6046	
  6047	}
  6048	// lat/kaldi-lattice.cc
  6049	
  6050	// Copyright 2009-2011     Microsoft Corporation
  6051	//                2013     Johns Hopkins University (author: Daniel Povey)
  6052	
  6053	// See ../../COPYING for clarification regarding multiple authors
  6054	//
  6055	// Licensed under the Apache License, Version 2.0 (the "License");
  6056	// you may not use this file except in compliance with the License.
  6057	// You may obtain a copy of the License at
  6058	//
  6059	//  http://www.apache.org/licenses/LICENSE-2.0
  6060	//
  6061	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  6062	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  6063	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  6064	// MERCHANTABLITY OR NON-INFRINGEMENT.
  6065	// See the Apache 2 License for the specific language governing permissions and
  6066	// limitations under the License.
  6067	
  6068	
  6069	#include "lat/kaldi-lattice.h"
  6070	#include "fst/script/print-impl.h"
  6071	
  6072	namespace kaldi {
  6073	
  6074	/// Converts lattice types if necessary, deleting its input.
  6075	template<class OrigWeightType>
  6076	CompactLattice* ConvertToCompactLattice(fst::VectorFst<OrigWeightType> *ifst) {
  6077	  if (!ifst) return NULL;
  6078	  CompactLattice *ofst = new CompactLattice();
  6079	  ConvertLattice(*ifst, ofst);
  6080	  delete ifst;
  6081	  return ofst;
  6082	}
  6083	
  6084	// This overrides the template if there is no type conversion going on
  6085	// (for efficiency).
  6086	template<>
  6087	CompactLattice* ConvertToCompactLattice(CompactLattice *ifst) {
  6088	  return ifst;
  6089	}
  6090	
  6091	/// Converts lattice types if necessary, deleting its input.
  6092	template<class OrigWeightType>
  6093	Lattice* ConvertToLattice(fst::VectorFst<OrigWeightType> *ifst) {
  6094	  if (!ifst) return NULL;
  6095	  Lattice *ofst = new Lattice();
  6096	  ConvertLattice(*ifst, ofst);
  6097	  delete ifst;
  6098	  return ofst;
  6099	}
  6100	
  6101	// This overrides the template if there is no type conversion going on
  6102	// (for efficiency).
  6103	template<>
  6104	Lattice* ConvertToLattice(Lattice *ifst) {
  6105	  return ifst;
  6106	}
  6107	
  6108	
  6109	bool WriteCompactLattice(std::ostream &os, bool binary,
  6110	                         const CompactLattice &t) {
  6111	  if (binary) {
  6112	    fst::FstWriteOptions opts;
  6113	    // Leave all the options default.  Normally these lattices wouldn't have any
  6114	    // osymbols/isymbols so no point directing it not to write them (who knows what
  6115	    // we'd want to if we had them).
  6116	    return t.Write(os, opts);
  6117	  } else {
  6118	    // Text-mode output.  Note: we expect that t.InputSymbols() and
  6119	    // t.OutputSymbols() would always return NULL.  The corresponding input
  6120	    // routine would not work if the FST actually had symbols attached.
  6121	    // Write a newline after the key, so the first line of the FST appears
  6122	    // on its own line.
  6123	    os << '\n';
  6124	    bool acceptor = true, write_one = false;
  6125	    fst::FstPrinter<CompactLatticeArc> printer(t, t.InputSymbols(),
  6126	                                               t.OutputSymbols(),
  6127	                                               NULL, acceptor, write_one, "\t");
  6128	    printer.Print(&os, "<unknown>");
  6129	    if (os.fail())
  6130	      KALDI_WARN << "Stream failure detected.";
  6131	    // Write another newline as a terminating character.  The read routine will
  6132	    // detect this [this is a Kaldi mechanism, not somethig in the original
  6133	    // OpenFst code].
  6134	    os << '\n';
  6135	    return os.good();
  6136	  }
  6137	}
  6138	
  6139	/// LatticeReader provides (static) functions for reading both Lattice
  6140	/// and CompactLattice, in text form.
  6141	class LatticeReader {
  6142	  typedef LatticeArc Arc;
  6143	  typedef LatticeWeight Weight;
  6144	  typedef CompactLatticeArc CArc;
  6145	  typedef CompactLatticeWeight CWeight;
  6146	  typedef Arc::Label Label;
  6147	  typedef Arc::StateId StateId;
  6148	 public:
  6149	  // everything is static in this class.
  6150	
  6151	  /** This function reads from the FST text format; it does not know in advance
  6152	      whether it's a Lattice or CompactLattice in the stream so it tries to
  6153	      read both formats until it becomes clear which is the correct one.
  6154	  */
  6155	  static std::pair<Lattice*, CompactLattice*> ReadText(
  6156	      std::istream &is) {
  6157	    typedef std::pair<Lattice*, CompactLattice*> PairT;
  6158	    using std::string;
  6159	    using std::vector;
  6160	    Lattice *fst = new Lattice();
  6161	    CompactLattice *cfst = new CompactLattice();
  6162	    string line;
  6163	    size_t nline = 0;
  6164	    string separator = FLAGS_fst_field_separator + "\r\n";
  6165	    while (std::getline(is, line)) {
  6166	      nline++;
  6167	      vector<string> col;
  6168	      // on Windows we'll write in text and read in binary mode.
  6169	      SplitStringToVector(line, separator.c_str(), true, &col);
  6170	      if (col.size() == 0) break; // Empty line is a signal to stop, in our
  6171	      // archive format.
  6172	      if (col.size() > 5) {
  6173	        KALDI_WARN << "Reading lattice: bad line in FST: " << line;
  6174	        delete fst;
  6175	        delete cfst;
  6176	        return PairT(static_cast<Lattice*>(NULL),
  6177	                     static_cast<CompactLattice*>(NULL));
  6178	      }
  6179	      StateId s;
  6180	      if (!ConvertStringToInteger(col[0], &s)) {
  6181	        KALDI_WARN << "FstCompiler: bad line in FST: " << line;
  6182	        delete fst;
  6183	        delete cfst;
  6184	        return PairT(static_cast<Lattice*>(NULL),
  6185	                     static_cast<CompactLattice*>(NULL));
  6186	      }
  6187	      if (fst)
  6188	        while (s >= fst->NumStates())
  6189	          fst->AddState();
  6190	      if (cfst)
  6191	        while (s >= cfst->NumStates())
  6192	          cfst->AddState();
  6193	      if (nline == 1) {
  6194	        if (fst) fst->SetStart(s);
  6195	        if (cfst) cfst->SetStart(s);
  6196	      }
  6197	
  6198	      if (fst) { // we still have fst; try to read that arc.
  6199	        bool ok = true;
  6200	        Arc arc;
  6201	        Weight w;
  6202	        StateId d = s;
  6203	        switch (col.size()) {
  6204	          case 1 :
  6205	            fst->SetFinal(s, Weight::One());
  6206	            break;
  6207	          case 2:
  6208	            if (!StrToWeight(col[1], true, &w)) ok = false;
  6209	            else fst->SetFinal(s, w);
  6210	            break;
  6211	          case 3: // 3 columns not ok for Lattice format; it's not an acceptor.
  6212	            ok = false;
  6213	            break;
  6214	          case 4:
  6215	            ok = ConvertStringToInteger(col[1], &arc.nextstate) &&
  6216	                ConvertStringToInteger(col[2], &arc.ilabel) &&
  6217	                ConvertStringToInteger(col[3], &arc.olabel);
  6218	            if (ok) {
  6219	              d = arc.nextstate;
  6220	              arc.weight = Weight::One();
  6221	              fst->AddArc(s, arc);
  6222	            }
  6223	            break;
  6224	          case 5:
  6225	            ok = ConvertStringToInteger(col[1], &arc.nextstate) &&
  6226	                ConvertStringToInteger(col[2], &arc.ilabel) &&
  6227	                ConvertStringToInteger(col[3], &arc.olabel) &&
  6228	                StrToWeight(col[4], false, &arc.weight);
  6229	            if (ok) {
  6230	              d = arc.nextstate;
  6231	              fst->AddArc(s, arc);
  6232	            }
  6233	            break;
  6234	          default:
  6235	            ok = false;
  6236	        }
  6237	        while (d >= fst->NumStates())
  6238	          fst->AddState();
  6239	        if (!ok) {
  6240	          delete fst;
  6241	          fst = NULL;
  6242	        }
  6243	      }
  6244	      if (cfst) {
  6245	        bool ok = true;
  6246	        CArc arc;
  6247	        CWeight w;
  6248	        StateId d = s;
  6249	        switch (col.size()) {
  6250	          case 1 :
  6251	            cfst->SetFinal(s, CWeight::One());
  6252	            break;
  6253	          case 2:
  6254	            if (!StrToCWeight(col[1], true, &w)) ok = false;
  6255	            else cfst->SetFinal(s, w);
  6256	            break;
  6257	          case 3: // compact-lattice is acceptor format: state, next-state, label.
  6258	            ok = ConvertStringToInteger(col[1], &arc.nextstate) &&
  6259	                ConvertStringToInteger(col[2], &arc.ilabel);
  6260	            if (ok) {
  6261	              d = arc.nextstate;
  6262	              arc.olabel = arc.ilabel;
  6263	              arc.weight = CWeight::One();
  6264	              cfst->AddArc(s, arc);
  6265	            }
  6266	            break;
  6267	          case 4:
  6268	            ok = ConvertStringToInteger(col[1], &arc.nextstate) &&
  6269	                ConvertStringToInteger(col[2], &arc.ilabel) &&
  6270	                StrToCWeight(col[3], false, &arc.weight);
  6271	            if (ok) {
  6272	              d = arc.nextstate;
  6273	              arc.olabel = arc.ilabel;
  6274	              cfst->AddArc(s, arc);
  6275	            }
  6276	            break;
  6277	          case 5: default:
  6278	            ok = false;
  6279	        }
  6280	        while (d >= cfst->NumStates())
  6281	          cfst->AddState();
  6282	        if (!ok) {
  6283	          delete cfst;
  6284	          cfst = NULL;
  6285	        }
  6286	      }
  6287	      if (!fst && !cfst) {
  6288	        KALDI_WARN << "Bad line in lattice text format: " << line;
  6289	        // read until we get an empty line, so at least we
  6290	        // have a chance to read the next one (although this might
  6291	        // be a bit futile since the calling code will get unhappy
  6292	        // about failing to read this one.
  6293	        while (std::getline(is, line)) {
  6294	          SplitStringToVector(line, separator.c_str(), true, &col);
  6295	          if (col.empty()) break;
  6296	        }
  6297	        return PairT(static_cast<Lattice*>(NULL),
  6298	                     static_cast<CompactLattice*>(NULL));
  6299	      }
  6300	    }
  6301	    return PairT(fst, cfst);
  6302	  }
  6303	
  6304	  static bool StrToWeight(const std::string &s, bool allow_zero, Weight *w) {
  6305	    std::istringstream strm(s);
  6306	    strm >> *w;
  6307	    if (!strm || (!allow_zero && *w == Weight::Zero())) {
  6308	      return false;
  6309	    }
  6310	    return true;
  6311	  }
  6312	
  6313	  static  bool StrToCWeight(const std::string &s, bool allow_zero, CWeight *w) {
  6314	    std::istringstream strm(s);
  6315	    strm >> *w;
  6316	    if (!strm || (!allow_zero && *w == CWeight::Zero())) {
  6317	      return false;
  6318	    }
  6319	    return true;
  6320	  }
  6321	};
  6322	
  6323	
  6324	CompactLattice *ReadCompactLatticeText(std::istream &is) {
  6325	  std::pair<Lattice*, CompactLattice*> lat_pair = LatticeReader::ReadText(is);
  6326	  if (lat_pair.second != NULL) {
  6327	    delete lat_pair.first;
  6328	    return lat_pair.second;
  6329	  } else if (lat_pair.first != NULL) {
  6330	    // note: ConvertToCompactLattice frees its input.
  6331	    return ConvertToCompactLattice(lat_pair.first);
  6332	  } else {
  6333	    return NULL;
  6334	  }
  6335	}
  6336	
  6337	
  6338	Lattice *ReadLatticeText(std::istream &is) {
  6339	  std::pair<Lattice*, CompactLattice*> lat_pair = LatticeReader::ReadText(is);
  6340	  if (lat_pair.first != NULL) {
  6341	    delete lat_pair.second;
  6342	    return lat_pair.first;
  6343	  } else if (lat_pair.second != NULL) {
  6344	    // note: ConvertToLattice frees its input.
  6345	    return ConvertToLattice(lat_pair.second);
  6346	  } else {
  6347	    return NULL;
  6348	  }
  6349	}
  6350	
  6351	bool ReadCompactLattice(std::istream &is, bool binary,
  6352	                        CompactLattice **clat) {
  6353	  KALDI_ASSERT(*clat == NULL);
  6354	  if (binary) {
  6355	    fst::FstHeader hdr;
  6356	    if (!hdr.Read(is, "<unknown>")) {
  6357	      KALDI_WARN << "Reading compact lattice: error reading FST header.";
  6358	      return false;
  6359	    }
  6360	    if (hdr.FstType() != "vector") {
  6361	      KALDI_WARN << "Reading compact lattice: unsupported FST type: "
  6362	                 << hdr.FstType();
  6363	      return false;
  6364	    }
  6365	    fst::FstReadOptions ropts("<unspecified>",
  6366	                              &hdr);
  6367	
  6368	    typedef fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int32> T1;
  6369	    typedef fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<double>, int32> T2;
  6370	    typedef fst::LatticeWeightTpl<float> T3;
  6371	    typedef fst::LatticeWeightTpl<double> T4;
  6372	    typedef fst::VectorFst<fst::ArcTpl<T1> > F1;
  6373	    typedef fst::VectorFst<fst::ArcTpl<T2> > F2;
  6374	    typedef fst::VectorFst<fst::ArcTpl<T3> > F3;
  6375	    typedef fst::VectorFst<fst::ArcTpl<T4> > F4;
  6376	
  6377	    CompactLattice *ans = NULL;
  6378	    if (hdr.ArcType() == T1::Type()) {
  6379	      ans = ConvertToCompactLattice(F1::Read(is, ropts));
  6380	    } else if (hdr.ArcType() == T2::Type()) {
  6381	      ans = ConvertToCompactLattice(F2::Read(is, ropts));
  6382	    } else if (hdr.ArcType() == T3::Type()) {
  6383	      ans = ConvertToCompactLattice(F3::Read(is, ropts));
  6384	    } else if (hdr.ArcType() == T4::Type()) {
  6385	      ans = ConvertToCompactLattice(F4::Read(is, ropts));
  6386	    } else {
  6387	      KALDI_WARN << "FST with arc type " << hdr.ArcType()
  6388	                 << " cannot be converted to CompactLattice.\n";
  6389	      return false;
  6390	    }
  6391	    if (ans == NULL) {
  6392	      KALDI_WARN << "Error reading compact lattice (after reading header).";
  6393	      return false;
  6394	    }
  6395	    *clat = ans;
  6396	    return true;
  6397	  } else {
  6398	    // The next line would normally consume the \r on Windows, plus any
  6399	    // extra spaces that might have got in there somehow.
  6400	    while (std::isspace(is.peek()) && is.peek() != '\n') is.get();
  6401	    if (is.peek() == '\n') is.get(); // consume the newline.
  6402	    else { // saw spaces but no newline.. this is not expected.
  6403	      KALDI_WARN << "Reading compact lattice: unexpected sequence of spaces "
  6404	                 << " at file position " << is.tellg();
  6405	      return false;
  6406	    }
  6407	    *clat = ReadCompactLatticeText(is); // that routine will warn on error.
  6408	    return (*clat != NULL);
  6409	  }
  6410	}
  6411	
  6412	
  6413	bool CompactLatticeHolder::Read(std::istream &is) {
  6414	  Clear(); // in case anything currently stored.
  6415	  int c = is.peek();
  6416	  if (c == -1) {
  6417	    KALDI_WARN << "End of stream detected reading CompactLattice.";
  6418	    return false;
  6419	  } else if (isspace(c)) { // The text form of the lattice begins
  6420	    // with space (normally, '\n'), so this means it's text (the binary form
  6421	    // cannot begin with space because it starts with the FST Type() which is not
  6422	    // space).
  6423	    return ReadCompactLattice(is, false, &t_);
  6424	  } else if (c != 214) { // 214 is first char of FST magic number,
  6425	    // on little-endian machines which is all we support (\326 octal)
  6426	    KALDI_WARN << "Reading compact lattice: does not appear to be an FST "
  6427	               << " [non-space but no magic number detected], file pos is "
  6428	               << is.tellg();
  6429	    return false;
  6430	  } else {
  6431	    return ReadCompactLattice(is, true, &t_);
  6432	  }
  6433	}
  6434	
  6435	bool WriteLattice(std::ostream &os, bool binary, const Lattice &t) {
  6436	  if (binary) {
  6437	    fst::FstWriteOptions opts;
  6438	    // Leave all the options default.  Normally these lattices wouldn't have any
  6439	    // osymbols/isymbols so no point directing it not to write them (who knows what
  6440	    // we'd want to do if we had them).
  6441	    return t.Write(os, opts);
  6442	  } else {
  6443	    // Text-mode output.  Note: we expect that t.InputSymbols() and
  6444	    // t.OutputSymbols() would always return NULL.  The corresponding input
  6445	    // routine would not work if the FST actually had symbols attached.
  6446	    // Write a newline after the key, so the first line of the FST appears
  6447	    // on its own line.
  6448	    os << '\n';
  6449	    bool acceptor = false, write_one = false;
  6450	    fst::FstPrinter<LatticeArc> printer(t, t.InputSymbols(),
  6451	                                        t.OutputSymbols(),
  6452	                                        NULL, acceptor, write_one, "\t");
  6453	    printer.Print(&os, "<unknown>");
  6454	    if (os.fail())
  6455	      KALDI_WARN << "Stream failure detected.";
  6456	    // Write another newline as a terminating character.  The read routine will
  6457	    // detect this [this is a Kaldi mechanism, not somethig in the original
  6458	    // OpenFst code].
  6459	    os << '\n';
  6460	    return os.good();
  6461	  }
  6462	}
  6463	
  6464	bool ReadLattice(std::istream &is, bool binary,
  6465	                 Lattice **lat) {
  6466	  KALDI_ASSERT(*lat == NULL);
  6467	  if (binary) {
  6468	    fst::FstHeader hdr;
  6469	    if (!hdr.Read(is, "<unknown>")) {
  6470	      KALDI_WARN << "Reading lattice: error reading FST header.";
  6471	      return false;
  6472	    }
  6473	    if (hdr.FstType() != "vector") {
  6474	      KALDI_WARN << "Reading lattice: unsupported FST type: "
  6475	                 << hdr.FstType();
  6476	      return false;
  6477	    }
  6478	    fst::FstReadOptions ropts("<unspecified>",
  6479	                              &hdr);
  6480	
  6481	    typedef fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int32> T1;
  6482	    typedef fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<double>, int32> T2;
  6483	    typedef fst::LatticeWeightTpl<float> T3;
  6484	    typedef fst::LatticeWeightTpl<double> T4;
  6485	    typedef fst::VectorFst<fst::ArcTpl<T1> > F1;
  6486	    typedef fst::VectorFst<fst::ArcTpl<T2> > F2;
  6487	    typedef fst::VectorFst<fst::ArcTpl<T3> > F3;
  6488	    typedef fst::VectorFst<fst::ArcTpl<T4> > F4;
  6489	
  6490	    Lattice *ans = NULL;
  6491	    if (hdr.ArcType() == T1::Type()) {
  6492	      ans = ConvertToLattice(F1::Read(is, ropts));
  6493	    } else if (hdr.ArcType() == T2::Type()) {
  6494	      ans = ConvertToLattice(F2::Read(is, ropts));
  6495	    } else if (hdr.ArcType() == T3::Type()) {
  6496	      ans = ConvertToLattice(F3::Read(is, ropts));
  6497	    } else if (hdr.ArcType() == T4::Type()) {
  6498	      ans = ConvertToLattice(F4::Read(is, ropts));
  6499	    } else {
  6500	      KALDI_WARN << "FST with arc type " << hdr.ArcType()
  6501	                 << " cannot be converted to Lattice.\n";
  6502	      return false;
  6503	    }
  6504	    if (ans == NULL) {
  6505	      KALDI_WARN << "Error reading lattice (after reading header).";
  6506	      return false;
  6507	    }
  6508	    *lat = ans;
  6509	    return true;
  6510	  } else {
  6511	    // The next line would normally consume the \r on Windows, plus any
  6512	    // extra spaces that might have got in there somehow.
  6513	    while (std::isspace(is.peek()) && is.peek() != '\n') is.get();
  6514	    if (is.peek() == '\n') is.get(); // consume the newline.
  6515	    else { // saw spaces but no newline.. this is not expected.
  6516	      KALDI_WARN << "Reading compact lattice: unexpected sequence of spaces "
  6517	                 << " at file position " << is.tellg();
  6518	      return false;
  6519	    }
  6520	    *lat = ReadLatticeText(is); // that routine will warn on error.
  6521	    return (*lat != NULL);
  6522	  }
  6523	}
  6524	
  6525	
  6526	/* Since we don't write the binary headers for this type of holder,
  6527	   we use a different method to work out whether we're in binary mode.
  6528	 */
  6529	bool LatticeHolder::Read(std::istream &is) {
  6530	  Clear(); // in case anything currently stored.
  6531	  int c = is.peek();
  6532	  if (c == -1) {
  6533	    KALDI_WARN << "End of stream detected reading Lattice.";
  6534	    return false;
  6535	  } else if (isspace(c)) { // The text form of the lattice begins
  6536	    // with space (normally, '\n'), so this means it's text (the binary form
  6537	    // cannot begin with space because it starts with the FST Type() which is not
  6538	    // space).
  6539	    return ReadLattice(is, false, &t_);
  6540	  } else if (c != 214) { // 214 is first char of FST magic number,
  6541	    // on little-endian machines which is all we support (\326 octal)
  6542	    KALDI_WARN << "Reading compact lattice: does not appear to be an FST "
  6543	               << " [non-space but no magic number detected], file pos is "
  6544	               << is.tellg();
  6545	    return false;
  6546	  } else {
  6547	    return ReadLattice(is, true, &t_);
  6548	  }
  6549	}
  6550	
  6551	
  6552	
  6553	} // end namespace kaldi
  6554	// lat/lattice-functions.cc
  6555	
  6556	// Copyright 2009-2011  Saarland University (Author: Arnab Ghoshal)
  6557	//           2012-2013  Johns Hopkins University (Author: Daniel Povey);  Chao Weng;
  6558	//                      Bagher BabaAli
  6559	//                2013  Cisco Systems (author: Neha Agrawal) [code modified
  6560	//                      from original code in ../gmmbin/gmm-rescore-lattice.cc]
  6561	//                2014  Guoguo Chen
  6562	
  6563	// See ../../COPYING for clarification regarding multiple authors
  6564	//
  6565	// Licensed under the Apache License, Version 2.0 (the "License");
  6566	// you may not use this file except in compliance with the License.
  6567	// You may obtain a copy of the License at
  6568	//
  6569	//  http://www.apache.org/licenses/LICENSE-2.0
  6570	//
  6571	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  6572	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  6573	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  6574	// MERCHANTABLITY OR NON-INFRINGEMENT.
  6575	// See the Apache 2 License for the specific language governing permissions and
  6576	// limitations under the License.
  6577	
  6578	
  6579	#include "lat/lattice-functions.h"
  6580	// #include "hmm/transition-model.h"
  6581	// #include "util/stl-utils.h"
  6582	#include "base/kaldi-math.h"
  6583	// #include "hmm/hmm-utils.h"
  6584	
  6585	namespace kaldi {
  6586	using std::map;
  6587	using std::vector;
  6588	
  6589	// void GetPerFrameAcousticCosts(const Lattice &nbest,
  6590	//                               Vector<BaseFloat> *per_frame_loglikes) {
  6591	//   using namespace fst;
  6592	//   typedef Lattice::Arc::Weight Weight;
  6593	//   vector<BaseFloat> loglikes;
  6594	//
  6595	//   int32 cur_state = nbest.Start();
  6596	//   int32 prev_frame = -1;
  6597	//   BaseFloat eps_acwt = 0.0;
  6598	//   while(1) {
  6599	//     Weight w = nbest.Final(cur_state);
  6600	//     if (w != Weight::Zero()) {
  6601	//       KALDI_ASSERT(nbest.NumArcs(cur_state) == 0);
  6602	//       if (per_frame_loglikes != NULL)  {
  6603	//         SubVector<BaseFloat> subvec(&(loglikes[0]), loglikes.size());
  6604	//         Vector<BaseFloat> vec(subvec);
  6605	//         *per_frame_loglikes = vec;
  6606	//       }
  6607	//       break;
  6608	//     } else {
  6609	//       KALDI_ASSERT(nbest.NumArcs(cur_state) == 1);
  6610	//       fst::ArcIterator<Lattice> iter(nbest, cur_state);
  6611	//       const Lattice::Arc &arc = iter.Value();
  6612	//       BaseFloat acwt = arc.weight.Value2();
  6613	//       if (arc.ilabel != 0) {
  6614	//         if (eps_acwt > 0) {
  6615	//           acwt += eps_acwt;
  6616	//           eps_acwt = 0.0;
  6617	//         }
  6618	//         loglikes.push_back(acwt);
  6619	//         prev_frame++;
  6620	//       } else if (acwt == acwt){
  6621	//         if (prev_frame > -1) {
  6622	//           loglikes[prev_frame] += acwt;
  6623	//         } else {
  6624	//           eps_acwt += acwt;
  6625	//         }
  6626	//       }
  6627	//       cur_state = arc.nextstate;
  6628	//     }
  6629	//   }
  6630	// }
  6631	//
  6632	// int32 LatticeStateTimes(const Lattice &lat, vector<int32> *times) {
  6633	//   if (!lat.Properties(fst::kTopSorted, true))
  6634	//     KALDI_ERR << "Input lattice must be topologically sorted.";
  6635	//   KALDI_ASSERT(lat.Start() == 0);
  6636	//   int32 num_states = lat.NumStates();
  6637	//   times->clear();
  6638	//   times->resize(num_states, -1);
  6639	//   (*times)[0] = 0;
  6640	//   for (int32 state = 0; state < num_states; state++) {
  6641	//     int32 cur_time = (*times)[state];
  6642	//     for (fst::ArcIterator<Lattice> aiter(lat, state); !aiter.Done();
  6643	//         aiter.Next()) {
  6644	//       const LatticeArc &arc = aiter.Value();
  6645	//
  6646	//       if (arc.ilabel != 0) {  // Non-epsilon input label on arc
  6647	//         // next time instance
  6648	//         if ((*times)[arc.nextstate] == -1) {
  6649	//           (*times)[arc.nextstate] = cur_time + 1;
  6650	//         } else {
  6651	//           KALDI_ASSERT((*times)[arc.nextstate] == cur_time + 1);
  6652	//         }
  6653	//       } else {  // epsilon input label on arc
  6654	//         // Same time instance
  6655	//         if ((*times)[arc.nextstate] == -1)
  6656	//           (*times)[arc.nextstate] = cur_time;
  6657	//         else
  6658	//           KALDI_ASSERT((*times)[arc.nextstate] == cur_time);
  6659	//       }
  6660	//     }
  6661	//   }
  6662	//   return (*std::max_element(times->begin(), times->end()));
  6663	// }
  6664	//
  6665	// int32 CompactLatticeStateTimes(const CompactLattice &lat,
  6666	//                                vector<int32> *times) {
  6667	//   if (!lat.Properties(fst::kTopSorted, true))
  6668	//     KALDI_ERR << "Input lattice must be topologically sorted.";
  6669	//   KALDI_ASSERT(lat.Start() == 0);
  6670	//   int32 num_states = lat.NumStates();
  6671	//   times->clear();
  6672	//   times->resize(num_states, -1);
  6673	//   (*times)[0] = 0;
  6674	//   int32 utt_len = -1;
  6675	//   for (int32 state = 0; state < num_states; state++) {
  6676	//     int32 cur_time = (*times)[state];
  6677	//     for (fst::ArcIterator<CompactLattice> aiter(lat, state); !aiter.Done();
  6678	//         aiter.Next()) {
  6679	//       const CompactLatticeArc &arc = aiter.Value();
  6680	//       int32 arc_len = static_cast<int32>(arc.weight.String().size());
  6681	//       if ((*times)[arc.nextstate] == -1)
  6682	//         (*times)[arc.nextstate] = cur_time + arc_len;
  6683	//       else
  6684	//         KALDI_ASSERT((*times)[arc.nextstate] == cur_time + arc_len);
  6685	//     }
  6686	//     if (lat.Final(state) != CompactLatticeWeight::Zero()) {
  6687	//       int32 this_utt_len = (*times)[state] + lat.Final(state).String().size();
  6688	//       if (utt_len == -1) utt_len = this_utt_len;
  6689	//       else {
  6690	//         if (this_utt_len != utt_len) {
  6691	//           KALDI_WARN << "Utterance does not "
  6692	//               "seem to have a consistent length.";
  6693	//           utt_len = std::max(utt_len, this_utt_len);
  6694	//         }
  6695	//       }
  6696	//     }
  6697	//   }
  6698	//   if (utt_len == -1) {
  6699	//     KALDI_WARN << "Utterance does not have a final-state.";
  6700	//     return 0;
  6701	//   }
  6702	//   return utt_len;
  6703	// }
  6704	//
  6705	// bool ComputeCompactLatticeAlphas(const CompactLattice &clat,
  6706	//                                  vector<double> *alpha) {
  6707	//   using namespace fst;
  6708	//
  6709	//   // typedef the arc, weight types
  6710	//   typedef CompactLattice::Arc Arc;
  6711	//   typedef Arc::Weight Weight;
  6712	//   typedef Arc::StateId StateId;
  6713	//
  6714	//   //Make sure the lattice is topologically sorted.
  6715	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  6716	//     KALDI_WARN << "Input lattice must be topologically sorted.";
  6717	//     return false;
  6718	//   }
  6719	//   if (clat.Start() != 0) {
  6720	//     KALDI_WARN << "Input lattice must start from state 0.";
  6721	//     return false;
  6722	//   }
  6723	//
  6724	//   int32 num_states = clat.NumStates();
  6725	//   (*alpha).resize(0);
  6726	//   (*alpha).resize(num_states, kLogZeroDouble);
  6727	//
  6728	//   // Now propagate alphas forward. Note that we don't acount the weight of the
  6729	//   // final state to alpha[final_state] -- we acount it to beta[final_state];
  6730	//   (*alpha)[0] = 0.0;
  6731	//   for (StateId s = 0; s < num_states; s++) {
  6732	//     double this_alpha = (*alpha)[s];
  6733	//     for (ArcIterator<CompactLattice> aiter(clat, s);
  6734	//          !aiter.Done(); aiter.Next()) {
  6735	//       const Arc &arc = aiter.Value();
  6736	//       double arc_like = -(arc.weight.Weight().Value1() +
  6737	//                           arc.weight.Weight().Value2());
  6738	//       (*alpha)[arc.nextstate] = LogAdd((*alpha)[arc.nextstate],
  6739	//                                        this_alpha + arc_like);
  6740	//     }
  6741	//   }
  6742	//
  6743	//   return true;
  6744	// }
  6745	//
  6746	// bool ComputeCompactLatticeBetas(const CompactLattice &clat,
  6747	//                                 vector<double> *beta) {
  6748	//   using namespace fst;
  6749	//
  6750	//   // typedef the arc, weight types
  6751	//   typedef CompactLattice::Arc Arc;
  6752	//   typedef Arc::Weight Weight;
  6753	//   typedef Arc::StateId StateId;
  6754	//
  6755	//   // Make sure the lattice is topologically sorted.
  6756	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  6757	//     KALDI_WARN << "Input lattice must be topologically sorted.";
  6758	//     return false;
  6759	//   }
  6760	//   if (clat.Start() != 0) {
  6761	//     KALDI_WARN << "Input lattice must start from state 0.";
  6762	//     return false;
  6763	//   }
  6764	//
  6765	//   int32 num_states = clat.NumStates();
  6766	//   (*beta).resize(0);
  6767	//   (*beta).resize(num_states, kLogZeroDouble);
  6768	//
  6769	//   // Now propagate betas backward. Note that beta[final_state] contains the
  6770	//   // weight of the final state in the lattice -- compare that with alpha.
  6771	//   for (StateId s = num_states-1; s >= 0; s--) {
  6772	//     Weight f = clat.Final(s);
  6773	//     double this_beta = -(f.Weight().Value1()+f.Weight().Value2());
  6774	//     for (ArcIterator<CompactLattice> aiter(clat, s);
  6775	//          !aiter.Done(); aiter.Next()) {
  6776	//       const Arc &arc = aiter.Value();
  6777	//       double arc_like = -(arc.weight.Weight().Value1() +
  6778	//                           arc.weight.Weight().Value2());
  6779	//       double arc_beta = (*beta)[arc.nextstate] + arc_like;
  6780	//       this_beta = LogAdd(this_beta, arc_beta);
  6781	//     }
  6782	//     (*beta)[s] = this_beta;
  6783	//   }
  6784	//
  6785	//   return true;
  6786	// }
  6787	
  6788	template<class LatType>  // could be Lattice or CompactLattice
  6789	bool PruneLattice(BaseFloat beam, LatType *lat) {
  6790	  typedef typename LatType::Arc Arc;
  6791	  typedef typename Arc::Weight Weight;
  6792	  typedef typename Arc::StateId StateId;
  6793	
  6794	  KALDI_ASSERT(beam > 0.0);
  6795	  if (!lat->Properties(fst::kTopSorted, true)) {
  6796	    if (fst::TopSort(lat) == false) {
  6797	      KALDI_WARN << "Cycles detected in lattice";
  6798	      return false;
  6799	    }
  6800	  }
  6801	  // We assume states before "start" are not reachable, since
  6802	  // the lattice is topologically sorted.
  6803	  int32 start = lat->Start();
  6804	  int32 num_states = lat->NumStates();
  6805	  if (num_states == 0) return false;
  6806	  std::vector<double> forward_cost(num_states,
  6807	                                   std::numeric_limits<double>::infinity());  // viterbi forward.
  6808	  forward_cost[start] = 0.0; // lattice can't have cycles so couldn't be
  6809	  // less than this.
  6810	  double best_final_cost = std::numeric_limits<double>::infinity();
  6811	  // Update the forward probs.
  6812	  // Thanks to Jing Zheng for finding a bug here.
  6813	  for (int32 state = 0; state < num_states; state++) {
  6814	    double this_forward_cost = forward_cost[state];
  6815	    for (fst::ArcIterator<LatType> aiter(*lat, state);
  6816	         !aiter.Done();
  6817	         aiter.Next()) {
  6818	      const Arc &arc(aiter.Value());
  6819	      StateId nextstate = arc.nextstate;
  6820	      KALDI_ASSERT(nextstate > state && nextstate < num_states);
  6821	      double next_forward_cost = this_forward_cost +
  6822	          ConvertToCost(arc.weight);
  6823	      if (forward_cost[nextstate] > next_forward_cost)
  6824	        forward_cost[nextstate] = next_forward_cost;
  6825	    }
  6826	    Weight final_weight = lat->Final(state);
  6827	    double this_final_cost = this_forward_cost +
  6828	        ConvertToCost(final_weight);
  6829	    if (this_final_cost < best_final_cost)
  6830	      best_final_cost = this_final_cost;
  6831	  }
  6832	  int32 bad_state = lat->AddState(); // this state is not final.
  6833	  double cutoff = best_final_cost + beam;
  6834	
  6835	  // Go backwards updating the backward probs (which share memory with the
  6836	  // forward probs), and pruning arcs and deleting final-probs.  We prune arcs
  6837	  // by making them point to the non-final state "bad_state".  We'll then use
  6838	  // Trim() to remove unnecessary arcs and states.  [this is just easier than
  6839	  // doing it ourselves.]
  6840	  std::vector<double> &backward_cost(forward_cost);
  6841	  for (int32 state = num_states - 1; state >= 0; state--) {
  6842	    double this_forward_cost = forward_cost[state];
  6843	    double this_backward_cost = ConvertToCost(lat->Final(state));
  6844	    if (this_backward_cost + this_forward_cost > cutoff
  6845	        && this_backward_cost != std::numeric_limits<double>::infinity())
  6846	      lat->SetFinal(state, Weight::Zero());
  6847	    for (fst::MutableArcIterator<LatType> aiter(lat, state);
  6848	         !aiter.Done();
  6849	         aiter.Next()) {
  6850	      Arc arc(aiter.Value());
  6851	      StateId nextstate = arc.nextstate;
  6852	      KALDI_ASSERT(nextstate > state && nextstate < num_states);
  6853	      double arc_cost = ConvertToCost(arc.weight),
  6854	          arc_backward_cost = arc_cost + backward_cost[nextstate],
  6855	          this_fb_cost = this_forward_cost + arc_backward_cost;
  6856	      if (arc_backward_cost < this_backward_cost)
  6857	        this_backward_cost = arc_backward_cost;
  6858	      if (this_fb_cost > cutoff) { // Prune the arc.
  6859	        arc.nextstate = bad_state;
  6860	        aiter.SetValue(arc);
  6861	      }
  6862	    }
  6863	    backward_cost[state] = this_backward_cost;
  6864	  }
  6865	  fst::Connect(lat);
  6866	  return (lat->NumStates() > 0);
  6867	}
  6868	
  6869	// instantiate the template for lattice and CompactLattice.
  6870	template bool PruneLattice(BaseFloat beam, Lattice *lat);
  6871	template bool PruneLattice(BaseFloat beam, CompactLattice *lat);
  6872	
  6873	
  6874	// BaseFloat LatticeForwardBackward(const Lattice &lat, Posterior *post,
  6875	//                                  double *acoustic_like_sum) {
  6876	//   // Note, Posterior is defined as follows:  Indexed [frame], then a list
  6877	//   // of (transition-id, posterior-probability) pairs.
  6878	//   // typedef std::vector<std::vector<std::pair<int32, BaseFloat> > > Posterior;
  6879	//   using namespace fst;
  6880	//   typedef Lattice::Arc Arc;
  6881	//   typedef Arc::Weight Weight;
  6882	//   typedef Arc::StateId StateId;
  6883	//
  6884	//   if (acoustic_like_sum) *acoustic_like_sum = 0.0;
  6885	//
  6886	//   // Make sure the lattice is topologically sorted.
  6887	//   if (lat.Properties(fst::kTopSorted, true) == 0)
  6888	//     KALDI_ERR << "Input lattice must be topologically sorted.";
  6889	//   KALDI_ASSERT(lat.Start() == 0);
  6890	//
  6891	//   int32 num_states = lat.NumStates();
  6892	//   vector<int32> state_times;
  6893	//   int32 max_time = LatticeStateTimes(lat, &state_times);
  6894	//   std::vector<double> alpha(num_states, kLogZeroDouble);
  6895	//   std::vector<double> &beta(alpha); // we re-use the same memory for
  6896	//   // this, but it's semantically distinct so we name it differently.
  6897	//   double tot_forward_prob = kLogZeroDouble;
  6898	//
  6899	//   post->clear();
  6900	//   post->resize(max_time);
  6901	//
  6902	//   alpha[0] = 0.0;
  6903	//   // Propagate alphas forward.
  6904	//   for (StateId s = 0; s < num_states; s++) {
  6905	//     double this_alpha = alpha[s];
  6906	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  6907	//       const Arc &arc = aiter.Value();
  6908	//       double arc_like = -ConvertToCost(arc.weight);
  6909	//       alpha[arc.nextstate] = LogAdd(alpha[arc.nextstate], this_alpha + arc_like);
  6910	//     }
  6911	//     Weight f = lat.Final(s);
  6912	//     if (f != Weight::Zero()) {
  6913	//       double final_like = this_alpha - (f.Value1() + f.Value2());
  6914	//       tot_forward_prob = LogAdd(tot_forward_prob, final_like);
  6915	//       KALDI_ASSERT(state_times[s] == max_time &&
  6916	//                    "Lattice is inconsistent (final-prob not at max_time)");
  6917	//     }
  6918	//   }
  6919	//   for (StateId s = num_states-1; s >= 0; s--) {
  6920	//     Weight f = lat.Final(s);
  6921	//     double this_beta = -(f.Value1() + f.Value2());
  6922	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  6923	//       const Arc &arc = aiter.Value();
  6924	//       double arc_like = -ConvertToCost(arc.weight),
  6925	//           arc_beta = beta[arc.nextstate] + arc_like;
  6926	//       this_beta = LogAdd(this_beta, arc_beta);
  6927	//       int32 transition_id = arc.ilabel;
  6928	//
  6929	//       // The following "if" is an optimization to avoid un-needed exp().
  6930	//       if (transition_id != 0 || acoustic_like_sum != NULL) {
  6931	//         double posterior = Exp(alpha[s] + arc_beta - tot_forward_prob);
  6932	//
  6933	//         if (transition_id != 0) // Arc has a transition-id on it [not epsilon]
  6934	//           (*post)[state_times[s]].push_back(std::make_pair(transition_id,
  6935	//                                                            static_cast<kaldi::BaseFloat>(posterior)));
  6936	//         if (acoustic_like_sum != NULL)
  6937	//           *acoustic_like_sum -= posterior * arc.weight.Value2();
  6938	//       }
  6939	//     }
  6940	//     if (acoustic_like_sum != NULL && f != Weight::Zero()) {
  6941	//       double final_logprob = - ConvertToCost(f),
  6942	//           posterior = Exp(alpha[s] + final_logprob - tot_forward_prob);
  6943	//       *acoustic_like_sum -= posterior * f.Value2();
  6944	//     }
  6945	//     beta[s] = this_beta;
  6946	//   }
  6947	//   double tot_backward_prob = beta[0];
  6948	//   if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-8)) {
  6949	//     KALDI_WARN << "Total forward probability over lattice = " << tot_forward_prob
  6950	//               << ", while total backward probability = " << tot_backward_prob;
  6951	//   }
  6952	//   // Now combine any posteriors with the same transition-id.
  6953	//   for (int32 t = 0; t < max_time; t++)
  6954	//     MergePairVectorSumming(&((*post)[t]));
  6955	//   return tot_backward_prob;
  6956	// }
  6957	//
  6958	//
  6959	// void LatticeActivePhones(const Lattice &lat, const TransitionModel &trans,
  6960	//                          const vector<int32> &silence_phones,
  6961	//                          vector< std::set<int32> > *active_phones) {
  6962	//   KALDI_ASSERT(IsSortedAndUniq(silence_phones));
  6963	//   vector<int32> state_times;
  6964	//   int32 num_states = lat.NumStates();
  6965	//   int32 max_time = LatticeStateTimes(lat, &state_times);
  6966	//   active_phones->clear();
  6967	//   active_phones->resize(max_time);
  6968	//   for (int32 state = 0; state < num_states; state++) {
  6969	//     int32 cur_time = state_times[state];
  6970	//     for (fst::ArcIterator<Lattice> aiter(lat, state); !aiter.Done();
  6971	//         aiter.Next()) {
  6972	//       const LatticeArc &arc = aiter.Value();
  6973	//       if (arc.ilabel != 0) {  // Non-epsilon arc
  6974	//         int32 phone = trans.TransitionIdToPhone(arc.ilabel);
  6975	//         if (!std::binary_search(silence_phones.begin(),
  6976	//                                 silence_phones.end(), phone))
  6977	//           (*active_phones)[cur_time].insert(phone);
  6978	//       }
  6979	//     }  // end looping over arcs
  6980	//   }  // end looping over states
  6981	// }
  6982	//
  6983	// void ConvertLatticeToPhones(const TransitionModel &trans,
  6984	//                             Lattice *lat) {
  6985	//   typedef LatticeArc Arc;
  6986	//   int32 num_states = lat->NumStates();
  6987	//   for (int32 state = 0; state < num_states; state++) {
  6988	//     for (fst::MutableArcIterator<Lattice> aiter(lat, state); !aiter.Done();
  6989	//         aiter.Next()) {
  6990	//       Arc arc(aiter.Value());
  6991	//       arc.olabel = 0; // remove any word.
  6992	//       if ((arc.ilabel != 0) // has a transition-id on input..
  6993	//           && (trans.TransitionIdToHmmState(arc.ilabel) == 0)
  6994	//           && (!trans.IsSelfLoop(arc.ilabel))) {
  6995	//          // && trans.IsFinal(arc.ilabel)) // there is one of these per phone...
  6996	//         arc.olabel = trans.TransitionIdToPhone(arc.ilabel);
  6997	//       }
  6998	//       aiter.SetValue(arc);
  6999	//     }  // end looping over arcs
  7000	//   }  // end looping over states
  7001	// }
  7002	//
  7003	//
  7004	// static inline double LogAddOrMax(bool viterbi, double a, double b) {
  7005	//   if (viterbi)
  7006	//     return std::max(a, b);
  7007	//   else
  7008	//     return LogAdd(a, b);
  7009	// }
  7010	//
  7011	// template<typename LatticeType>
  7012	// double ComputeLatticeAlphasAndBetas(const LatticeType &lat,
  7013	//                                     bool viterbi,
  7014	//                                     vector<double> *alpha,
  7015	//                                     vector<double> *beta) {
  7016	//   typedef typename LatticeType::Arc Arc;
  7017	//   typedef typename Arc::Weight Weight;
  7018	//   typedef typename Arc::StateId StateId;
  7019	//
  7020	//   StateId num_states = lat.NumStates();
  7021	//   KALDI_ASSERT(lat.Properties(fst::kTopSorted, true) == fst::kTopSorted);
  7022	//   KALDI_ASSERT(lat.Start() == 0);
  7023	//   alpha->clear();
  7024	//   beta->clear();
  7025	//   alpha->resize(num_states, kLogZeroDouble);
  7026	//   beta->resize(num_states, kLogZeroDouble);
  7027	//
  7028	//   double tot_forward_prob = kLogZeroDouble;
  7029	//   (*alpha)[0] = 0.0;
  7030	//   // Propagate alphas forward.
  7031	//   for (StateId s = 0; s < num_states; s++) {
  7032	//     double this_alpha = (*alpha)[s];
  7033	//     for (fst::ArcIterator<LatticeType> aiter(lat, s); !aiter.Done();
  7034	//          aiter.Next()) {
  7035	//       const Arc &arc = aiter.Value();
  7036	//       double arc_like = -ConvertToCost(arc.weight);
  7037	//       (*alpha)[arc.nextstate] = LogAddOrMax(viterbi, (*alpha)[arc.nextstate],
  7038	//                                                 this_alpha + arc_like);
  7039	//     }
  7040	//     Weight f = lat.Final(s);
  7041	//     if (f != Weight::Zero()) {
  7042	//       double final_like = this_alpha - ConvertToCost(f);
  7043	//       tot_forward_prob = LogAddOrMax(viterbi, tot_forward_prob, final_like);
  7044	//     }
  7045	//   }
  7046	//   for (StateId s = num_states-1; s >= 0; s--) { // it's guaranteed signed.
  7047	//     double this_beta = -ConvertToCost(lat.Final(s));
  7048	//     for (fst::ArcIterator<LatticeType> aiter(lat, s); !aiter.Done();
  7049	//          aiter.Next()) {
  7050	//       const Arc &arc = aiter.Value();
  7051	//       double arc_like = -ConvertToCost(arc.weight),
  7052	//           arc_beta = (*beta)[arc.nextstate] + arc_like;
  7053	//       this_beta = LogAddOrMax(viterbi, this_beta, arc_beta);
  7054	//     }
  7055	//     (*beta)[s] = this_beta;
  7056	//   }
  7057	//   double tot_backward_prob = (*beta)[lat.Start()];
  7058	//   if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-8)) {
  7059	//     KALDI_WARN << "Total forward probability over lattice = " << tot_forward_prob
  7060	//                << ", while total backward probability = " << tot_backward_prob;
  7061	//   }
  7062	//   // Split the difference when returning... they should be the same.
  7063	//   return 0.5 * (tot_backward_prob + tot_forward_prob);
  7064	// }
  7065	//
  7066	// // instantiate the template for Lattice and CompactLattice
  7067	// template
  7068	// double ComputeLatticeAlphasAndBetas(const Lattice &lat,
  7069	//                                     bool viterbi,
  7070	//                                     vector<double> *alpha,
  7071	//                                     vector<double> *beta);
  7072	//
  7073	// template
  7074	// double ComputeLatticeAlphasAndBetas(const CompactLattice &lat,
  7075	//                                     bool viterbi,
  7076	//                                     vector<double> *alpha,
  7077	//                                     vector<double> *beta);
  7078	//
  7079	//
  7080	//
  7081	// /// This is used in CompactLatticeLimitDepth.
  7082	// struct LatticeArcRecord {
  7083	//   BaseFloat logprob; // logprob <= 0 is the best Viterbi logprob of this arc,
  7084	//                      // minus the overall best-cost of the lattice.
  7085	//   CompactLatticeArc::StateId state; // state in the lattice.
  7086	//   size_t arc; // arc index within the state.
  7087	//   bool operator < (const LatticeArcRecord &other) const {
  7088	//     return logprob < other.logprob;
  7089	//   }
  7090	// };
  7091	//
  7092	// void CompactLatticeLimitDepth(int32 max_depth_per_frame,
  7093	//                               CompactLattice *clat) {
  7094	//   typedef CompactLatticeArc Arc;
  7095	//   typedef Arc::Weight Weight;
  7096	//   typedef Arc::StateId StateId;
  7097	//
  7098	//   if (clat->Start() == fst::kNoStateId) {
  7099	//     KALDI_WARN << "Limiting depth of empty lattice.";
  7100	//     return;
  7101	//   }
  7102	//   if (clat->Properties(fst::kTopSorted, true) == 0) {
  7103	//     if (!TopSort(clat))
  7104	//       KALDI_ERR << "Topological sorting of lattice failed.";
  7105	//   }
  7106	//
  7107	//   vector<int32> state_times;
  7108	//   int32 T = CompactLatticeStateTimes(*clat, &state_times);
  7109	//
  7110	//   // The alpha and beta quantities here are "viterbi" alphas and beta.
  7111	//   std::vector<double> alpha;
  7112	//   std::vector<double> beta;
  7113	//   bool viterbi = true;
  7114	//   double best_prob = ComputeLatticeAlphasAndBetas(*clat, viterbi,
  7115	//                                                   &alpha, &beta);
  7116	//
  7117	//   std::vector<std::vector<LatticeArcRecord> > arc_records(T);
  7118	//
  7119	//   StateId num_states = clat->NumStates();
  7120	//   for (StateId s = 0; s < num_states; s++) {
  7121	//     for (fst::ArcIterator<CompactLattice> aiter(*clat, s); !aiter.Done();
  7122	//          aiter.Next()) {
  7123	//       const Arc &arc = aiter.Value();
  7124	//       LatticeArcRecord arc_record;
  7125	//       arc_record.state = s;
  7126	//       arc_record.arc = aiter.Position();
  7127	//       arc_record.logprob =
  7128	//           (alpha[s] + beta[arc.nextstate] - ConvertToCost(arc.weight))
  7129	//            - best_prob;
  7130	//       KALDI_ASSERT(arc_record.logprob < 0.1); // Should be zero or negative.
  7131	//       int32 num_frames = arc.weight.String().size(), start_t = state_times[s];
  7132	//       for (int32 t = start_t; t < start_t + num_frames; t++) {
  7133	//         KALDI_ASSERT(t < T);
  7134	//         arc_records[t].push_back(arc_record);
  7135	//       }
  7136	//     }
  7137	//   }
  7138	//   StateId dead_state = clat->AddState(); // A non-coaccesible state which we use
  7139	//                                          // to remove arcs (make them end
  7140	//                                          // there).
  7141	//   size_t max_depth = max_depth_per_frame;
  7142	//   for (int32 t = 0; t < T; t++) {
  7143	//     size_t size = arc_records[t].size();
  7144	//     if (size > max_depth) {
  7145	//       // we sort from worst to best, so we keep the later-numbered ones,
  7146	//       // and delete the lower-numbered ones.
  7147	//       size_t cutoff = size - max_depth;
  7148	//       std::nth_element(arc_records[t].begin(),
  7149	//                        arc_records[t].begin() + cutoff,
  7150	//                        arc_records[t].end());
  7151	//       for (size_t index = 0; index < cutoff; index++) {
  7152	//         LatticeArcRecord record(arc_records[t][index]);
  7153	//         fst::MutableArcIterator<CompactLattice> aiter(clat, record.state);
  7154	//         aiter.Seek(record.arc);
  7155	//         Arc arc = aiter.Value();
  7156	//         if (arc.nextstate != dead_state) { // not already killed.
  7157	//           arc.nextstate = dead_state;
  7158	//           aiter.SetValue(arc);
  7159	//         }
  7160	//       }
  7161	//     }
  7162	//   }
  7163	//   Connect(clat);
  7164	//   TopSortCompactLatticeIfNeeded(clat);
  7165	// }
  7166	//
  7167	//
  7168	// void TopSortCompactLatticeIfNeeded(CompactLattice *clat) {
  7169	//   if (clat->Properties(fst::kTopSorted, true) == 0) {
  7170	//     if (fst::TopSort(clat) == false) {
  7171	//       KALDI_ERR << "Topological sorting failed";
  7172	//     }
  7173	//   }
  7174	// }
  7175	//
  7176	// void TopSortLatticeIfNeeded(Lattice *lat) {
  7177	//   if (lat->Properties(fst::kTopSorted, true) == 0) {
  7178	//     if (fst::TopSort(lat) == false) {
  7179	//       KALDI_ERR << "Topological sorting failed";
  7180	//     }
  7181	//   }
  7182	// }
  7183	//
  7184	//
  7185	// /// Returns the depth of the lattice, defined as the average number of
  7186	// /// arcs crossing any given frame.  Returns 1 for empty lattices.
  7187	// /// Requires that input is topologically sorted.
  7188	// BaseFloat CompactLatticeDepth(const CompactLattice &clat,
  7189	//                               int32 *num_frames) {
  7190	//   typedef CompactLattice::Arc::StateId StateId;
  7191	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  7192	//     KALDI_ERR << "Lattice input to CompactLatticeDepth was not topologically "
  7193	//               << "sorted.";
  7194	//   }
  7195	//   if (clat.Start() == fst::kNoStateId) {
  7196	//     *num_frames = 0;
  7197	//     return 1.0;
  7198	//   }
  7199	//   size_t num_arc_frames = 0;
  7200	//   int32 t;
  7201	//   {
  7202	//     vector<int32> state_times;
  7203	//     t = CompactLatticeStateTimes(clat, &state_times);
  7204	//   }
  7205	//   if (num_frames != NULL)
  7206	//     *num_frames = t;
  7207	//   for (StateId s = 0; s < clat.NumStates(); s++) {
  7208	//     for (fst::ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done();
  7209	//          aiter.Next()) {
  7210	//       const CompactLatticeArc &arc = aiter.Value();
  7211	//       num_arc_frames += arc.weight.String().size();
  7212	//     }
  7213	//     num_arc_frames += clat.Final(s).String().size();
  7214	//   }
  7215	//   return num_arc_frames / static_cast<BaseFloat>(t);
  7216	// }
  7217	//
  7218	//
  7219	// void CompactLatticeDepthPerFrame(const CompactLattice &clat,
  7220	//                                  std::vector<int32> *depth_per_frame) {
  7221	//   typedef CompactLattice::Arc::StateId StateId;
  7222	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  7223	//     KALDI_ERR << "Lattice input to CompactLatticeDepthPerFrame was not "
  7224	//               << "topologically sorted.";
  7225	//   }
  7226	//   if (clat.Start() == fst::kNoStateId) {
  7227	//     depth_per_frame->clear();
  7228	//     return;
  7229	//   }
  7230	//   vector<int32> state_times;
  7231	//   int32 T = CompactLatticeStateTimes(clat, &state_times);
  7232	//
  7233	//   depth_per_frame->clear();
  7234	//   if (T <= 0) {
  7235	//     return;
  7236	//   } else {
  7237	//     depth_per_frame->resize(T, 0);
  7238	//     for (StateId s = 0; s < clat.NumStates(); s++) {
  7239	//       int32 start_time = state_times[s];
  7240	//       for (fst::ArcIterator<CompactLattice> aiter(clat, s); !aiter.Done();
  7241	//            aiter.Next()) {
  7242	//         const CompactLatticeArc &arc = aiter.Value();
  7243	//         int32 len = arc.weight.String().size();
  7244	//         for (int32 t = start_time; t < start_time + len; t++) {
  7245	//           KALDI_ASSERT(t < T);
  7246	//           (*depth_per_frame)[t]++;
  7247	//         }
  7248	//       }
  7249	//       int32 final_len = clat.Final(s).String().size();
  7250	//       for (int32 t = start_time; t < start_time + final_len; t++) {
  7251	//         KALDI_ASSERT(t < T);
  7252	//         (*depth_per_frame)[t]++;
  7253	//       }
  7254	//     }
  7255	//   }
  7256	// }
  7257	//
  7258	//
  7259	//
  7260	// void ConvertCompactLatticeToPhones(const TransitionModel &trans,
  7261	//                                    CompactLattice *clat) {
  7262	//   typedef CompactLatticeArc Arc;
  7263	//   typedef Arc::Weight Weight;
  7264	//   int32 num_states = clat->NumStates();
  7265	//   for (int32 state = 0; state < num_states; state++) {
  7266	//     for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
  7267	//          !aiter.Done();
  7268	//          aiter.Next()) {
  7269	//       Arc arc(aiter.Value());
  7270	//       std::vector<int32> phone_seq;
  7271	//       const std::vector<int32> &tid_seq = arc.weight.String();
  7272	//       for (std::vector<int32>::const_iterator iter = tid_seq.begin();
  7273	//            iter != tid_seq.end(); ++iter) {
  7274	//         if (trans.IsFinal(*iter))// note: there is one of these per phone...
  7275	//           phone_seq.push_back(trans.TransitionIdToPhone(*iter));
  7276	//       }
  7277	//       arc.weight.SetString(phone_seq);
  7278	//       aiter.SetValue(arc);
  7279	//     } // end looping over arcs
  7280	//     Weight f = clat->Final(state);
  7281	//     if (f != Weight::Zero()) {
  7282	//       std::vector<int32> phone_seq;
  7283	//       const std::vector<int32> &tid_seq = f.String();
  7284	//       for (std::vector<int32>::const_iterator iter = tid_seq.begin();
  7285	//            iter != tid_seq.end(); ++iter) {
  7286	//         if (trans.IsFinal(*iter))// note: there is one of these per phone...
  7287	//           phone_seq.push_back(trans.TransitionIdToPhone(*iter));
  7288	//       }
  7289	//       f.SetString(phone_seq);
  7290	//       clat->SetFinal(state, f);
  7291	//     }
  7292	//   }  // end looping over states
  7293	// }
  7294	//
  7295	// bool LatticeBoost(const TransitionModel &trans,
  7296	//                   const std::vector<int32> &alignment,
  7297	//                   const std::vector<int32> &silence_phones,
  7298	//                   BaseFloat b,
  7299	//                   BaseFloat max_silence_error,
  7300	//                   Lattice *lat) {
  7301	//   TopSortLatticeIfNeeded(lat);
  7302	//
  7303	//   // get all stored properties (test==false means don't test if not known).
  7304	//   uint64 props = lat->Properties(fst::kFstProperties,
  7305	//                                  false);
  7306	//
  7307	//   KALDI_ASSERT(IsSortedAndUniq(silence_phones));
  7308	//   KALDI_ASSERT(max_silence_error >= 0.0 && max_silence_error <= 1.0);
  7309	//   vector<int32> state_times;
  7310	//   int32 num_states = lat->NumStates();
  7311	//   int32 num_frames = LatticeStateTimes(*lat, &state_times);
  7312	//   KALDI_ASSERT(num_frames == static_cast<int32>(alignment.size()));
  7313	//   for (int32 state = 0; state < num_states; state++) {
  7314	//     int32 cur_time = state_times[state];
  7315	//     for (fst::MutableArcIterator<Lattice> aiter(lat, state); !aiter.Done();
  7316	//          aiter.Next()) {
  7317	//       LatticeArc arc = aiter.Value();
  7318	//       if (arc.ilabel != 0) {  // Non-epsilon arc
  7319	//         if (arc.ilabel < 0 || arc.ilabel > trans.NumTransitionIds()) {
  7320	//           KALDI_WARN << "Lattice has out-of-range transition-ids: "
  7321	//                      << "lattice/model mismatch?";
  7322	//           return false;
  7323	//         }
  7324	//         int32 phone = trans.TransitionIdToPhone(arc.ilabel),
  7325	//             ref_phone = trans.TransitionIdToPhone(alignment[cur_time]);
  7326	//         BaseFloat frame_error;
  7327	//         if (phone == ref_phone) {
  7328	//           frame_error = 0.0;
  7329	//         } else { // an error...
  7330	//           if (std::binary_search(silence_phones.begin(), silence_phones.end(), phone))
  7331	//             frame_error = max_silence_error;
  7332	//           else
  7333	//             frame_error = 1.0;
  7334	//         }
  7335	//         BaseFloat delta_cost = -b * frame_error; // negative cost if
  7336	//         // frame is wrong, to boost likelihood of arcs with errors on them.
  7337	//         // Add this cost to the graph part.
  7338	//         arc.weight.SetValue1(arc.weight.Value1() + delta_cost);
  7339	//         aiter.SetValue(arc);
  7340	//       }
  7341	//     }
  7342	//   }
  7343	//   // All we changed is the weights, so any properties that were
  7344	//   // known before, are still known, except for whether or not the
  7345	//   // lattice was weighted.
  7346	//   lat->SetProperties(props,
  7347	//                      ~(fst::kWeighted|fst::kUnweighted));
  7348	//
  7349	//   return true;
  7350	// }
  7351	//
  7352	//
  7353	//
  7354	// BaseFloat LatticeForwardBackwardMpeVariants(
  7355	//     const TransitionModel &trans,
  7356	//     const std::vector<int32> &silence_phones,
  7357	//     const Lattice &lat,
  7358	//     const std::vector<int32> &num_ali,
  7359	//     std::string criterion,
  7360	//     bool one_silence_class,
  7361	//     Posterior *post) {
  7362	//   using namespace fst;
  7363	//   typedef Lattice::Arc Arc;
  7364	//   typedef Arc::Weight Weight;
  7365	//   typedef Arc::StateId StateId;
  7366	//
  7367	//   KALDI_ASSERT(criterion == "mpfe" || criterion == "smbr");
  7368	//   bool is_mpfe = (criterion == "mpfe");
  7369	//
  7370	//   if (lat.Properties(fst::kTopSorted, true) == 0)
  7371	//     KALDI_ERR << "Input lattice must be topologically sorted.";
  7372	//   KALDI_ASSERT(lat.Start() == 0);
  7373	//
  7374	//   int32 num_states = lat.NumStates();
  7375	//   vector<int32> state_times;
  7376	//   int32 max_time = LatticeStateTimes(lat, &state_times);
  7377	//   KALDI_ASSERT(max_time == static_cast<int32>(num_ali.size()));
  7378	//   std::vector<double> alpha(num_states, kLogZeroDouble),
  7379	//       alpha_smbr(num_states, 0), //forward variable for sMBR
  7380	//       beta(num_states, kLogZeroDouble),
  7381	//       beta_smbr(num_states, 0); //backward variable for sMBR
  7382	//
  7383	//   double tot_forward_prob = kLogZeroDouble;
  7384	//   double tot_forward_score = 0;
  7385	//
  7386	//   post->clear();
  7387	//   post->resize(max_time);
  7388	//
  7389	//   alpha[0] = 0.0;
  7390	//   // First Pass Forward,
  7391	//   for (StateId s = 0; s < num_states; s++) {
  7392	//     double this_alpha = alpha[s];
  7393	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  7394	//       const Arc &arc = aiter.Value();
  7395	//       double arc_like = -ConvertToCost(arc.weight);
  7396	//       alpha[arc.nextstate] = LogAdd(alpha[arc.nextstate], this_alpha + arc_like);
  7397	//     }
  7398	//     Weight f = lat.Final(s);
  7399	//     if (f != Weight::Zero()) {
  7400	//       double final_like = this_alpha - (f.Value1() + f.Value2());
  7401	//       tot_forward_prob = LogAdd(tot_forward_prob, final_like);
  7402	//       KALDI_ASSERT(state_times[s] == max_time &&
  7403	//                    "Lattice is inconsistent (final-prob not at max_time)");
  7404	//     }
  7405	//   }
  7406	//   // First Pass Backward,
  7407	//   for (StateId s = num_states-1; s >= 0; s--) {
  7408	//     Weight f = lat.Final(s);
  7409	//     double this_beta = -(f.Value1() + f.Value2());
  7410	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  7411	//       const Arc &arc = aiter.Value();
  7412	//       double arc_like = -ConvertToCost(arc.weight),
  7413	//           arc_beta = beta[arc.nextstate] + arc_like;
  7414	//       this_beta = LogAdd(this_beta, arc_beta);
  7415	//     }
  7416	//     beta[s] = this_beta;
  7417	//   }
  7418	//   // First Pass Forward-Backward Check
  7419	//   double tot_backward_prob = beta[0];
  7420	//   // may loose the condition somehow here 1e-6 (was 1e-8)
  7421	//   if (!ApproxEqual(tot_forward_prob, tot_backward_prob, 1e-6)) {
  7422	//     KALDI_ERR << "Total forward probability over lattice = " << tot_forward_prob
  7423	//               << ", while total backward probability = " << tot_backward_prob;
  7424	//   }
  7425	//
  7426	//   alpha_smbr[0] = 0.0;
  7427	//   // Second Pass Forward, calculate forward for MPFE/SMBR
  7428	//   for (StateId s = 0; s < num_states; s++) {
  7429	//     double this_alpha = alpha[s];
  7430	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  7431	//       const Arc &arc = aiter.Value();
  7432	//       double arc_like = -ConvertToCost(arc.weight);
  7433	//       double frame_acc = 0.0;
  7434	//       if (arc.ilabel != 0) {
  7435	//         int32 cur_time = state_times[s];
  7436	//         int32 phone = trans.TransitionIdToPhone(arc.ilabel),
  7437	//             ref_phone = trans.TransitionIdToPhone(num_ali[cur_time]);
  7438	//         bool phone_is_sil = std::binary_search(silence_phones.begin(),
  7439	//                                                silence_phones.end(),
  7440	//                                                phone),
  7441	//             ref_phone_is_sil = std::binary_search(silence_phones.begin(),
  7442	//                                                   silence_phones.end(),
  7443	//                                                   ref_phone),
  7444	//             both_sil = phone_is_sil && ref_phone_is_sil;
  7445	//         if (!is_mpfe) { // smbr.
  7446	//           int32 pdf = trans.TransitionIdToPdf(arc.ilabel),
  7447	//               ref_pdf = trans.TransitionIdToPdf(num_ali[cur_time]);
  7448	//           if (!one_silence_class)  // old behavior
  7449	//             frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
  7450	//           else
  7451	//             frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
  7452	//         } else {
  7453	//           if (!one_silence_class)  // old behavior
  7454	//             frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
  7455	//           else
  7456	//             frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
  7457	//         }
  7458	//       }
  7459	//       double arc_scale = Exp(alpha[s] + arc_like - alpha[arc.nextstate]);
  7460	//       alpha_smbr[arc.nextstate] += arc_scale * (alpha_smbr[s] + frame_acc);
  7461	//     }
  7462	//     Weight f = lat.Final(s);
  7463	//     if (f != Weight::Zero()) {
  7464	//       double final_like = this_alpha - (f.Value1() + f.Value2());
  7465	//       double arc_scale = Exp(final_like - tot_forward_prob);
  7466	//       tot_forward_score += arc_scale * alpha_smbr[s];
  7467	//       KALDI_ASSERT(state_times[s] == max_time &&
  7468	//                    "Lattice is inconsistent (final-prob not at max_time)");
  7469	//     }
  7470	//   }
  7471	//   // Second Pass Backward, collect Mpe style posteriors
  7472	//   for (StateId s = num_states-1; s >= 0; s--) {
  7473	//     for (ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  7474	//       const Arc &arc = aiter.Value();
  7475	//       double arc_like = -ConvertToCost(arc.weight),
  7476	//           arc_beta = beta[arc.nextstate] + arc_like;
  7477	//       double frame_acc = 0.0;
  7478	//       int32 transition_id = arc.ilabel;
  7479	//       if (arc.ilabel != 0) {
  7480	//         int32 cur_time = state_times[s];
  7481	//         int32 phone = trans.TransitionIdToPhone(arc.ilabel),
  7482	//             ref_phone = trans.TransitionIdToPhone(num_ali[cur_time]);
  7483	//         bool phone_is_sil = std::binary_search(silence_phones.begin(),
  7484	//                                                silence_phones.end(), phone),
  7485	//             ref_phone_is_sil = std::binary_search(silence_phones.begin(),
  7486	//                                                   silence_phones.end(),
  7487	//                                                   ref_phone),
  7488	//             both_sil = phone_is_sil && ref_phone_is_sil;
  7489	//         if (!is_mpfe) { // smbr.
  7490	//           int32 pdf = trans.TransitionIdToPdf(arc.ilabel),
  7491	//               ref_pdf = trans.TransitionIdToPdf(num_ali[cur_time]);
  7492	//           if (!one_silence_class)  // old behavior
  7493	//             frame_acc = (pdf == ref_pdf && !phone_is_sil) ? 1.0 : 0.0;
  7494	//           else
  7495	//             frame_acc = (pdf == ref_pdf || both_sil) ? 1.0 : 0.0;
  7496	//         } else {
  7497	//           if (!one_silence_class)  // old behavior
  7498	//             frame_acc = (phone == ref_phone && !phone_is_sil) ? 1.0 : 0.0;
  7499	//           else
  7500	//             frame_acc = (phone == ref_phone || both_sil) ? 1.0 : 0.0;
  7501	//         }
  7502	//       }
  7503	//       double arc_scale = Exp(beta[arc.nextstate] + arc_like - beta[s]);
  7504	//       // check arc_scale NAN,
  7505	//       // this is to prevent partial paths in Lattices
  7506	//       // i.e., paths don't survive to the final state
  7507	//       if (KALDI_ISNAN(arc_scale)) arc_scale = 0;
  7508	//       beta_smbr[s] += arc_scale * (beta_smbr[arc.nextstate] + frame_acc);
  7509	//
  7510	//       if (transition_id != 0) { // Arc has a transition-id on it [not epsilon]
  7511	//         double posterior = Exp(alpha[s] + arc_beta - tot_forward_prob);
  7512	//         double acc_diff = alpha_smbr[s] + frame_acc + beta_smbr[arc.nextstate]
  7513	//                                - tot_forward_score;
  7514	//         double posterior_smbr = posterior * acc_diff;
  7515	//         (*post)[state_times[s]].push_back(std::make_pair(transition_id,
  7516	//                                                          static_cast<BaseFloat>(posterior_smbr)));
  7517	//       }
  7518	//     }
  7519	//   }
  7520	//
  7521	//   //Second Pass Forward Backward check
  7522	//   double tot_backward_score = beta_smbr[0];  // Initial state id == 0
  7523	//   // may loose the condition somehow here 1e-5/1e-4
  7524	//   if (!ApproxEqual(tot_forward_score, tot_backward_score, 1e-4)) {
  7525	//     KALDI_ERR << "Total forward score over lattice = " << tot_forward_score
  7526	//               << ", while total backward score = " << tot_backward_score;
  7527	//   }
  7528	//
  7529	//   // Output the computed posteriors
  7530	//   for (int32 t = 0; t < max_time; t++)
  7531	//     MergePairVectorSumming(&((*post)[t]));
  7532	//   return tot_forward_score;
  7533	// }
  7534	//
  7535	// bool CompactLatticeToWordAlignment(const CompactLattice &clat,
  7536	//                                    std::vector<int32> *words,
  7537	//                                    std::vector<int32> *begin_times,
  7538	//                                    std::vector<int32> *lengths) {
  7539	//   words->clear();
  7540	//   begin_times->clear();
  7541	//   lengths->clear();
  7542	//   typedef CompactLattice::Arc Arc;
  7543	//   typedef Arc::Label Label;
  7544	//   typedef CompactLattice::StateId StateId;
  7545	//   typedef CompactLattice::Weight Weight;
  7546	//   using namespace fst;
  7547	//   StateId state = clat.Start();
  7548	//   int32 cur_time = 0;
  7549	//   if (state == kNoStateId) {
  7550	//     KALDI_WARN << "Empty lattice.";
  7551	//     return false;
  7552	//   }
  7553	//   while (1) {
  7554	//     Weight final = clat.Final(state);
  7555	//     size_t num_arcs = clat.NumArcs(state);
  7556	//     if (final != Weight::Zero()) {
  7557	//       if (num_arcs != 0) {
  7558	//         KALDI_WARN << "Lattice is not linear.";
  7559	//         return false;
  7560	//       }
  7561	//       if (! final.String().empty()) {
  7562	//         KALDI_WARN << "Lattice has alignments on final-weight: probably "
  7563	//             "was not word-aligned (alignments will be approximate)";
  7564	//       }
  7565	//       return true;
  7566	//     } else {
  7567	//       if (num_arcs != 1) {
  7568	//         KALDI_WARN << "Lattice is not linear: num-arcs = " << num_arcs;
  7569	//         return false;
  7570	//       }
  7571	//       fst::ArcIterator<CompactLattice> aiter(clat, state);
  7572	//       const Arc &arc = aiter.Value();
  7573	//       Label word_id = arc.ilabel; // Note: ilabel==olabel, since acceptor.
  7574	//       // Also note: word_id may be zero; we output it anyway.
  7575	//       int32 length = arc.weight.String().size();
  7576	//       words->push_back(word_id);
  7577	//       begin_times->push_back(cur_time);
  7578	//       lengths->push_back(length);
  7579	//       cur_time += length;
  7580	//       state = arc.nextstate;
  7581	//     }
  7582	//   }
  7583	// }
  7584	//
  7585	//
  7586	// bool CompactLatticeToWordProns(
  7587	//     const TransitionModel &tmodel,
  7588	//     const CompactLattice &clat,
  7589	//     std::vector<int32> *words,
  7590	//     std::vector<int32> *begin_times,
  7591	//     std::vector<int32> *lengths,
  7592	//     std::vector<std::vector<int32> > *prons,
  7593	//     std::vector<std::vector<int32> > *phone_lengths) {
  7594	//   words->clear();
  7595	//   begin_times->clear();
  7596	//   lengths->clear();
  7597	//   prons->clear();
  7598	//   phone_lengths->clear();
  7599	//   typedef CompactLattice::Arc Arc;
  7600	//   typedef Arc::Label Label;
  7601	//   typedef CompactLattice::StateId StateId;
  7602	//   typedef CompactLattice::Weight Weight;
  7603	//   using namespace fst;
  7604	//   StateId state = clat.Start();
  7605	//   int32 cur_time = 0;
  7606	//   if (state == kNoStateId) {
  7607	//     KALDI_WARN << "Empty lattice.";
  7608	//     return false;
  7609	//   }
  7610	//   while (1) {
  7611	//     Weight final = clat.Final(state);
  7612	//     size_t num_arcs = clat.NumArcs(state);
  7613	//     if (final != Weight::Zero()) {
  7614	//       if (num_arcs != 0) {
  7615	//         KALDI_WARN << "Lattice is not linear.";
  7616	//         return false;
  7617	//       }
  7618	//       if (! final.String().empty()) {
  7619	//         KALDI_WARN << "Lattice has alignments on final-weight: probably "
  7620	//             "was not word-aligned (alignments will be approximate)";
  7621	//       }
  7622	//       return true;
  7623	//     } else {
  7624	//       if (num_arcs != 1) {
  7625	//         KALDI_WARN << "Lattice is not linear: num-arcs = " << num_arcs;
  7626	//         return false;
  7627	//       }
  7628	//       fst::ArcIterator<CompactLattice> aiter(clat, state);
  7629	//       const Arc &arc = aiter.Value();
  7630	//       Label word_id = arc.ilabel; // Note: ilabel==olabel, since acceptor.
  7631	//       // Also note: word_id may be zero; we output it anyway.
  7632	//       int32 length = arc.weight.String().size();
  7633	//       words->push_back(word_id);
  7634	//       begin_times->push_back(cur_time);
  7635	//       lengths->push_back(length);
  7636	//       const std::vector<int32> &arc_alignment = arc.weight.String();
  7637	//       std::vector<std::vector<int32> > split_alignment;
  7638	//       SplitToPhones(tmodel, arc_alignment, &split_alignment);
  7639	//       std::vector<int32> phones(split_alignment.size());
  7640	//       std::vector<int32> plengths(split_alignment.size());
  7641	//       for (size_t i = 0; i < split_alignment.size(); i++) {
  7642	//         KALDI_ASSERT(!split_alignment[i].empty());
  7643	//         phones[i] = tmodel.TransitionIdToPhone(split_alignment[i][0]);
  7644	//         plengths[i] = split_alignment[i].size();
  7645	//       }
  7646	//       prons->push_back(phones);
  7647	//       phone_lengths->push_back(plengths);
  7648	//
  7649	//       cur_time += length;
  7650	//       state = arc.nextstate;
  7651	//     }
  7652	//   }
  7653	// }
  7654	//
  7655	//
  7656	//
  7657	// void CompactLatticeShortestPath(const CompactLattice &clat,
  7658	//                                 CompactLattice *shortest_path) {
  7659	//   using namespace fst;
  7660	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  7661	//     CompactLattice clat_copy(clat);
  7662	//     if (!TopSort(&clat_copy))
  7663	//       KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
  7664	//     CompactLatticeShortestPath(clat_copy, shortest_path);
  7665	//     return;
  7666	//   }
  7667	//   // Now we can assume it's topologically sorted.
  7668	//   shortest_path->DeleteStates();
  7669	//   if (clat.Start() == kNoStateId) return;
  7670	//   typedef CompactLatticeArc Arc;
  7671	//   typedef Arc::StateId StateId;
  7672	//   typedef CompactLatticeWeight Weight;
  7673	//   vector<std::pair<double, StateId> > best_cost_and_pred(clat.NumStates() + 1);
  7674	//   StateId superfinal = clat.NumStates();
  7675	//   for (StateId s = 0; s <= clat.NumStates(); s++) {
  7676	//     best_cost_and_pred[s].first = std::numeric_limits<double>::infinity();
  7677	//     best_cost_and_pred[s].second = fst::kNoStateId;
  7678	//   }
  7679	//   best_cost_and_pred[clat.Start()].first = 0;
  7680	//   for (StateId s = 0; s < clat.NumStates(); s++) {
  7681	//     double my_cost = best_cost_and_pred[s].first;
  7682	//     for (ArcIterator<CompactLattice> aiter(clat, s);
  7683	//          !aiter.Done();
  7684	//          aiter.Next()) {
  7685	//       const Arc &arc = aiter.Value();
  7686	//       double arc_cost = ConvertToCost(arc.weight),
  7687	//           next_cost = my_cost + arc_cost;
  7688	//       if (next_cost < best_cost_and_pred[arc.nextstate].first) {
  7689	//         best_cost_and_pred[arc.nextstate].first = next_cost;
  7690	//         best_cost_and_pred[arc.nextstate].second = s;
  7691	//       }
  7692	//     }
  7693	//     double final_cost = ConvertToCost(clat.Final(s)),
  7694	//         tot_final = my_cost + final_cost;
  7695	//     if (tot_final < best_cost_and_pred[superfinal].first) {
  7696	//       best_cost_and_pred[superfinal].first = tot_final;
  7697	//       best_cost_and_pred[superfinal].second = s;
  7698	//     }
  7699	//   }
  7700	//   std::vector<StateId> states; // states on best path.
  7701	//   StateId cur_state = superfinal, start_state = clat.Start();
  7702	//   while (cur_state != start_state) {
  7703	//     StateId prev_state = best_cost_and_pred[cur_state].second;
  7704	//     if (prev_state == kNoStateId) {
  7705	//       KALDI_WARN << "Failure in best-path algorithm for lattice (infinite costs?)";
  7706	//       return; // return empty best-path.
  7707	//     }
  7708	//     states.push_back(prev_state);
  7709	//     KALDI_ASSERT(cur_state != prev_state && "Lattice with cycles");
  7710	//     cur_state = prev_state;
  7711	//   }
  7712	//   std::reverse(states.begin(), states.end());
  7713	//   for (size_t i = 0; i < states.size(); i++)
  7714	//     shortest_path->AddState();
  7715	//   for (StateId s = 0; static_cast<size_t>(s) < states.size(); s++) {
  7716	//     if (s == 0) shortest_path->SetStart(s);
  7717	//     if (static_cast<size_t>(s + 1) < states.size()) { // transition to next state.
  7718	//       bool have_arc = false;
  7719	//       Arc cur_arc;
  7720	//       for (ArcIterator<CompactLattice> aiter(clat, states[s]);
  7721	//            !aiter.Done();
  7722	//            aiter.Next()) {
  7723	//         const Arc &arc = aiter.Value();
  7724	//         if (arc.nextstate == states[s+1]) {
  7725	//           if (!have_arc ||
  7726	//               ConvertToCost(arc.weight) < ConvertToCost(cur_arc.weight)) {
  7727	//             cur_arc = arc;
  7728	//             have_arc = true;
  7729	//           }
  7730	//         }
  7731	//       }
  7732	//       KALDI_ASSERT(have_arc && "Code error.");
  7733	//       shortest_path->AddArc(s, Arc(cur_arc.ilabel, cur_arc.olabel,
  7734	//                                    cur_arc.weight, s+1));
  7735	//     } else { // final-prob.
  7736	//       shortest_path->SetFinal(s, clat.Final(states[s]));
  7737	//     }
  7738	//   }
  7739	// }
  7740	//
  7741	//
  7742	// void ExpandCompactLattice(const CompactLattice &clat,
  7743	//                           double epsilon,
  7744	//                           CompactLattice *expand_clat) {
  7745	//   using namespace fst;
  7746	//   typedef CompactLattice::Arc Arc;
  7747	//   typedef Arc::Weight Weight;
  7748	//   typedef Arc::StateId StateId;
  7749	//   typedef std::pair<StateId, StateId> StatePair;
  7750	//   typedef unordered_map<StatePair, StateId, PairHasher<StateId> > MapType;
  7751	//   typedef MapType::iterator IterType;
  7752	//
  7753	//   if (clat.Start() == kNoStateId) return;
  7754	//   // Make sure the input lattice is topologically sorted.
  7755	//   if (clat.Properties(kTopSorted, true) == 0) {
  7756	//     CompactLattice clat_copy(clat);
  7757	//     KALDI_LOG << "Topsort this lattice.";
  7758	//     if (!TopSort(&clat_copy))
  7759	//       KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
  7760	//     ExpandCompactLattice(clat_copy, epsilon, expand_clat);
  7761	//     return;
  7762	//   }
  7763	//
  7764	//   // Compute backward logprobs betas for the expanded lattice.
  7765	//   // Note: the backward logprobs in the original lattice <clat> and the
  7766	//   // expanded lattice <expand_clat> are the same.
  7767	//   int32 num_states = clat.NumStates();
  7768	//   std::vector<double> beta(num_states, kLogZeroDouble);
  7769	//   ComputeCompactLatticeBetas(clat, &beta);
  7770	//   double tot_backward_logprob = beta[0];
  7771	//   std::vector<double> alpha;
  7772	//   alpha.push_back(0.0);
  7773	//   expand_clat->DeleteStates();
  7774	//   MapType state_map; // Map from state pair (orig_state, copy_state) to
  7775	//   // copy_state, where orig_state is a state in the original lattice, and
  7776	//   // copy_state is its corresponding one in the expanded lattice.
  7777	//   unordered_map<StateId, StateId> states; // Map from orig_state to its
  7778	//   // copy_state for states with incoming arcs' posteriors <= epsilon.
  7779	//   std::queue<StatePair> state_queue;
  7780	//
  7781	//   // Set start state in the expanded lattice.
  7782	//   StateId start_state = expand_clat->AddState();
  7783	//   expand_clat->SetStart(start_state);
  7784	//   StatePair start_pair(clat.Start(), start_state);
  7785	//   state_queue.push(start_pair);
  7786	//   std::pair<IterType, bool> result =
  7787	//     state_map.insert(std::make_pair(start_pair, start_state));
  7788	//   KALDI_ASSERT(result.second == true);
  7789	//
  7790	//   // Expand <clat> and update forward logprobs alphas in <expand_clat>.
  7791	//   while (!state_queue.empty()) {
  7792	//     StatePair s = state_queue.front();
  7793	//     StateId s1 = s.first,
  7794	//             s2 = s.second;
  7795	//     state_queue.pop();
  7796	//
  7797	//     Weight f = clat.Final(s1);
  7798	//     if (f != Weight::Zero()) {
  7799	//       KALDI_ASSERT(state_map.find(s) != state_map.end());
  7800	//       expand_clat->SetFinal(state_map[s], f);
  7801	//     }
  7802	//
  7803	//     for (ArcIterator<CompactLattice> aiter(clat, s1);
  7804	//          !aiter.Done(); aiter.Next()) {
  7805	//       const Arc &arc = aiter.Value();
  7806	//       StateId orig_state = arc.nextstate;
  7807	//       double arc_like = -ConvertToCost(arc.weight),
  7808	//              this_alpha = alpha[s2] + arc_like,
  7809	//              arc_post = Exp(this_alpha + beta[orig_state] -
  7810	//                             tot_backward_logprob);
  7811	//       // Generate the expanded lattice.
  7812	//       StateId copy_state;
  7813	//       if (arc_post > epsilon) {
  7814	//         copy_state = expand_clat->AddState();
  7815	//         StatePair next_pair(orig_state, copy_state);
  7816	//         std::pair<IterType, bool> result =
  7817	//           state_map.insert(std::make_pair(next_pair, copy_state));
  7818	//         KALDI_ASSERT(result.second == true);
  7819	//         state_queue.push(next_pair);
  7820	//       } else {
  7821	//         unordered_map<StateId, StateId>::iterator iter = states.find(orig_state);
  7822	//         if (iter == states.end() ) { // The counterpart state of orig_state
  7823	//                                    // has not been created in <expand_clat> yet.
  7824	//           copy_state = expand_clat->AddState();
  7825	//           StatePair next_pair(orig_state, copy_state);
  7826	//           std::pair<IterType, bool> result =
  7827	//             state_map.insert(std::make_pair(next_pair, copy_state));
  7828	//           KALDI_ASSERT(result.second == true);
  7829	//           state_queue.push(next_pair);
  7830	//           states[orig_state] = copy_state;
  7831	//         } else {
  7832	//           copy_state = iter->second;
  7833	//         }
  7834	//       }
  7835	//       // Create an arc from state_map[s] to copy_state in the expanded lattice.
  7836	//       expand_clat->AddArc(state_map[s], Arc(arc.ilabel, arc.olabel, arc.weight,
  7837	//                                             copy_state));
  7838	//       // Compute forward logprobs alpha for the expanded lattice.
  7839	//       if ((alpha.size() - 1) < copy_state) { // The first time to compute alpha
  7840	//                                              // for copy_state in <expand_clat>.
  7841	//         alpha.push_back(this_alpha);
  7842	//       } else { // Accumulate alpha.
  7843	//         alpha[copy_state] = LogAdd(alpha[copy_state], this_alpha);
  7844	//       }
  7845	//     }
  7846	//   } // end while
  7847	// }
  7848	//
  7849	//
  7850	// void CompactLatticeBestCostsAndTracebacks(
  7851	//     const CompactLattice &clat,
  7852	//     CostTraceType *forward_best_cost_and_pred,
  7853	//     CostTraceType *backward_best_cost_and_pred) {
  7854	//
  7855	//   // typedef the arc, weight types
  7856	//   typedef CompactLatticeArc Arc;
  7857	//   typedef Arc::Weight Weight;
  7858	//   typedef Arc::StateId StateId;
  7859	//
  7860	//   forward_best_cost_and_pred->clear();
  7861	//   backward_best_cost_and_pred->clear();
  7862	//   forward_best_cost_and_pred->resize(clat.NumStates());
  7863	//   backward_best_cost_and_pred->resize(clat.NumStates());
  7864	//   // Initialize the cost and predecessor state for each state.
  7865	//   for (StateId s = 0; s < clat.NumStates(); s++) {
  7866	//     (*forward_best_cost_and_pred)[s].first =
  7867	//                                         std::numeric_limits<double>::infinity();
  7868	//     (*backward_best_cost_and_pred)[s].first =
  7869	//                                         std::numeric_limits<double>::infinity();
  7870	//     (*forward_best_cost_and_pred)[s].second = fst::kNoStateId;
  7871	//     (*backward_best_cost_and_pred)[s].second = fst::kNoStateId;
  7872	//   }
  7873	//
  7874	//   StateId start_state = clat.Start();
  7875	//   (*forward_best_cost_and_pred)[start_state].first = 0;
  7876	//   // Transverse the lattice forwardly to compute the best cost from the start
  7877	//   // state to each state and the best predecessor state of each state.
  7878	//   for (StateId s = 0; s < clat.NumStates(); s++) {
  7879	//     double cur_cost = (*forward_best_cost_and_pred)[s].first;
  7880	//     for (fst::ArcIterator<CompactLattice> aiter(clat, s);
  7881	//          !aiter.Done(); aiter.Next()) {
  7882	//       const Arc &arc = aiter.Value();
  7883	//       double next_cost = cur_cost + ConvertToCost(arc.weight);
  7884	//       if (next_cost < (*forward_best_cost_and_pred)[arc.nextstate].first) {
  7885	//         (*forward_best_cost_and_pred)[arc.nextstate].first = next_cost;
  7886	//         (*forward_best_cost_and_pred)[arc.nextstate].second = s;
  7887	//       }
  7888	//     }
  7889	//   }
  7890	//   // Transverse the lattice backwardly to compute the best cost from a final
  7891	//   // state to each state and the best predecessor state of each state.
  7892	//   for (StateId s = clat.NumStates() - 1; s >= 0; s--) {
  7893	//     double this_cost = ConvertToCost(clat.Final(s));
  7894	//     for (fst::ArcIterator<CompactLattice> aiter(clat, s);
  7895	//          !aiter.Done(); aiter.Next()) {
  7896	//       const Arc &arc = aiter.Value();
  7897	//       double next_cost = (*backward_best_cost_and_pred)[arc.nextstate].first +
  7898	//         ConvertToCost(arc.weight);
  7899	//       if (next_cost < this_cost) {
  7900	//         this_cost = next_cost;
  7901	//         (*backward_best_cost_and_pred)[s].second = arc.nextstate;
  7902	//       }
  7903	//     }
  7904	//     (*backward_best_cost_and_pred)[s].first = this_cost;
  7905	//   }
  7906	// }
  7907	//
  7908	//
  7909	// void AddNnlmScoreToCompactLattice(const MapT &nnlm_scores,
  7910	//                                   CompactLattice *clat) {
  7911	//   if (clat->Start() == fst::kNoStateId) return;
  7912	//   // Make sure the input lattice is topologically sorted.
  7913	//   if (clat->Properties(fst::kTopSorted, true) == 0) {
  7914	//     KALDI_LOG << "Topsort this lattice.";
  7915	//     if (!TopSort(clat))
  7916	//       KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
  7917	//     AddNnlmScoreToCompactLattice(nnlm_scores, clat);
  7918	//     return;
  7919	//   }
  7920	//
  7921	//   // typedef the arc, weight types
  7922	//   typedef CompactLatticeArc Arc;
  7923	//   typedef Arc::Weight Weight;
  7924	//   typedef Arc::StateId StateId;
  7925	//   typedef std::pair<int32, int32> StatePair;
  7926	//
  7927	//   int32 num_states = clat->NumStates();
  7928	//   unordered_map<StatePair, bool, PairHasher<int32> > final_state_check;
  7929	//   for (StateId s = 0; s < num_states; s++) {
  7930	//     for (fst::MutableArcIterator<CompactLattice> aiter(clat, s);
  7931	//          !aiter.Done(); aiter.Next()) {
  7932	//       Arc arc(aiter.Value());
  7933	//       StatePair arc_index = std::make_pair(static_cast<int32>(s),
  7934	//                                            static_cast<int32>(arc.nextstate));
  7935	//       MapT::const_iterator it = nnlm_scores.find(arc_index);
  7936	//       double nnlm_score;
  7937	//       if (it != nnlm_scores.end())
  7938	//         nnlm_score = it->second;
  7939	//       else
  7940	//         KALDI_ERR << "Some arc does not have neural language model score.";
  7941	//       if (arc.ilabel != 0) { // if there is a word on this arc
  7942	//         LatticeWeight weight = arc.weight.Weight();
  7943	//         // Add associated neural LM score to each arc.
  7944	//         weight.SetValue1(weight.Value1() + nnlm_score);
  7945	//         arc.weight.SetWeight(weight);
  7946	//         aiter.SetValue(arc);
  7947	//       }
  7948	//       Weight clat_final = clat->Final(arc.nextstate);
  7949	//       StatePair final_pair = std::make_pair(arc.nextstate, arc.nextstate);
  7950	//       // Add neural LM scores to each final state only once.
  7951	//       if (clat_final != CompactLatticeWeight::Zero() &&
  7952	//           final_state_check.find(final_pair) == final_state_check.end()) {
  7953	//         MapT::const_iterator final_it = nnlm_scores.find(final_pair);
  7954	//         double final_nnlm_score = 0.0;
  7955	//         if (final_it != nnlm_scores.end())
  7956	//           final_nnlm_score = final_it->second;
  7957	//         // Add neural LM scores to the final weight.
  7958	//         Weight final_weight(LatticeWeight(clat_final.Weight().Value1() +
  7959	//                                           final_nnlm_score,
  7960	//                                           clat_final.Weight().Value2()),
  7961	//                                           clat_final.String());
  7962	//         clat->SetFinal(arc.nextstate, final_weight);
  7963	//         final_state_check[final_pair] = true;
  7964	//       }
  7965	//     } // end looping over arcs
  7966	//   } // end looping over states
  7967	// }
  7968	//
  7969	// void AddWordInsPenToCompactLattice(BaseFloat word_ins_penalty,
  7970	//                                    CompactLattice *clat) {
  7971	//   typedef CompactLatticeArc Arc;
  7972	//   int32 num_states = clat->NumStates();
  7973	//
  7974	//   //scan the lattice
  7975	//   for (int32 state = 0; state < num_states; state++) {
  7976	//     for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
  7977	//          !aiter.Done(); aiter.Next()) {
  7978	//
  7979	//       Arc arc(aiter.Value());
  7980	//
  7981	//       if (arc.ilabel != 0) { // if there is a word on this arc
  7982	//         LatticeWeight weight = arc.weight.Weight();
  7983	//         // add word insertion penalty to lattice
  7984	//         weight.SetValue1( weight.Value1() + word_ins_penalty);
  7985	//         arc.weight.SetWeight(weight);
  7986	//         aiter.SetValue(arc);
  7987	//       }
  7988	//     } // end looping over arcs
  7989	//   }  // end looping over states
  7990	// }
  7991	//
  7992	// struct ClatRescoreTuple {
  7993	//   ClatRescoreTuple(int32 state, int32 arc, int32 tid):
  7994	//       state_id(state), arc_id(arc), tid(tid) { }
  7995	//   int32 state_id;
  7996	//   int32 arc_id;
  7997	//   int32 tid;
  7998	// };
  7999	//
  8000	// /** RescoreCompactLatticeInternal is the internal code for both
  8001	//     RescoreCompactLattice and RescoreCompatLatticeSpeedup.  For
  8002	//     RescoreCompactLattice, "tmodel" will be NULL and speedup_factor will be 1.0.
  8003	//  */
  8004	// bool RescoreCompactLatticeInternal(
  8005	//     const TransitionModel *tmodel,
  8006	//     BaseFloat speedup_factor,
  8007	//     DecodableInterface *decodable,
  8008	//     CompactLattice *clat) {
  8009	//   KALDI_ASSERT(speedup_factor >= 1.0);
  8010	//   if (clat->NumStates() == 0) {
  8011	//     KALDI_WARN << "Rescoring empty lattice";
  8012	//     return false;
  8013	//   }
  8014	//   if (!clat->Properties(fst::kTopSorted, true)) {
  8015	//     if (fst::TopSort(clat) == false) {
  8016	//       KALDI_WARN << "Cycles detected in lattice.";
  8017	//       return false;
  8018	//     }
  8019	//   }
  8020	//   std::vector<int32> state_times;
  8021	//   int32 utt_len = kaldi::CompactLatticeStateTimes(*clat, &state_times);
  8022	//
  8023	//   std::vector<std::vector<ClatRescoreTuple> > time_to_state(utt_len);
  8024	//
  8025	//   int32 num_states = clat->NumStates();
  8026	//   KALDI_ASSERT(num_states == state_times.size());
  8027	//   for (size_t state = 0; state < num_states; state++) {
  8028	//     KALDI_ASSERT(state_times[state] >= 0);
  8029	//     int32 t = state_times[state];
  8030	//     int32 arc_id = 0;
  8031	//     for (fst::MutableArcIterator<CompactLattice> aiter(clat, state);
  8032	//          !aiter.Done(); aiter.Next(), arc_id++) {
  8033	//       CompactLatticeArc arc = aiter.Value();
  8034	//       std::vector<int32> arc_string = arc.weight.String();
  8035	//
  8036	//       for (size_t offset = 0; offset < arc_string.size(); offset++) {
  8037	//         if (t < utt_len) { // end state may be past this..
  8038	//           int32 tid = arc_string[offset];
  8039	//           time_to_state[t+offset].push_back(ClatRescoreTuple(state, arc_id, tid));
  8040	//         } else {
  8041	//           if (t != utt_len) {
  8042	//             KALDI_WARN << "There appears to be lattice/feature mismatch, "
  8043	//                        << "aborting.";
  8044	//             return false;
  8045	//           }
  8046	//         }
  8047	//       }
  8048	//     }
  8049	//     if (clat->Final(state) != CompactLatticeWeight::Zero()) {
  8050	//       arc_id = -1;
  8051	//       std::vector<int32> arc_string = clat->Final(state).String();
  8052	//       for (size_t offset = 0; offset < arc_string.size(); offset++) {
  8053	//         KALDI_ASSERT(t + offset < utt_len); // already checked in
  8054	//         // CompactLatticeStateTimes, so would be code error.
  8055	//         time_to_state[t+offset].push_back(
  8056	//             ClatRescoreTuple(state, arc_id, arc_string[offset]));
  8057	//       }
  8058	//     }
  8059	//   }
  8060	//
  8061	//   for (int32 t = 0; t < utt_len; t++) {
  8062	//     if ((t < utt_len - 1) && decodable->IsLastFrame(t)) {
  8063	//       KALDI_WARN << "Features are too short for lattice: utt-len is "
  8064	//                  << utt_len << ", " << t << " is last frame";
  8065	//       return false;
  8066	//     }
  8067	//     // frame_scale is the scale we put on the computed acoustic probs for this
  8068	//     // frame.  It will always be 1.0 if tmodel == NULL (i.e. if we are not doing
  8069	//     // the "speedup" code).  For frames with multiple pdf-ids it will be one.
  8070	//     // For frames with only one pdf-id, it will equal speedup_factor (>=1.0)
  8071	//     // with probability 1.0 / speedup_factor, and zero otherwise.  If it is zero,
  8072	//     // we can avoid computing the probabilities.
  8073	//     BaseFloat frame_scale = 1.0;
  8074	//     KALDI_ASSERT(!time_to_state[t].empty());
  8075	//     if (tmodel != NULL) {
  8076	//       int32 pdf_id = tmodel->TransitionIdToPdf(time_to_state[t][0].tid);
  8077	//       bool frame_has_multiple_pdfs = false;
  8078	//       for (size_t i = 1; i < time_to_state[t].size(); i++) {
  8079	//         if (tmodel->TransitionIdToPdf(time_to_state[t][i].tid) != pdf_id) {
  8080	//           frame_has_multiple_pdfs = true;
  8081	//           break;
  8082	//         }
  8083	//       }
  8084	//       if (frame_has_multiple_pdfs) {
  8085	//         frame_scale = 1.0;
  8086	//       } else {
  8087	//         if (WithProb(1.0 / speedup_factor)) {
  8088	//           frame_scale = speedup_factor;
  8089	//         } else {
  8090	//           frame_scale = 0.0;
  8091	//         }
  8092	//       }
  8093	//       if (frame_scale == 0.0)
  8094	//         continue; // the code below would be pointless.
  8095	//     }
  8096	//
  8097	//     for (size_t i = 0; i < time_to_state[t].size(); i++) {
  8098	//       int32 state = time_to_state[t][i].state_id;
  8099	//       int32 arc_id = time_to_state[t][i].arc_id;
  8100	//       int32 tid = time_to_state[t][i].tid;
  8101	//
  8102	//       if (arc_id == -1) { // Final state
  8103	//         // Access the trans_id
  8104	//         CompactLatticeWeight curr_clat_weight = clat->Final(state);
  8105	//
  8106	//         // Calculate likelihood
  8107	//         BaseFloat log_like = decodable->LogLikelihood(t, tid) * frame_scale;
  8108	//         // update weight
  8109	//         CompactLatticeWeight new_clat_weight = curr_clat_weight;
  8110	//         LatticeWeight new_lat_weight = new_clat_weight.Weight();
  8111	//         new_lat_weight.SetValue2(-log_like + curr_clat_weight.Weight().Value2());
  8112	//         new_clat_weight.SetWeight(new_lat_weight);
  8113	//         clat->SetFinal(state, new_clat_weight);
  8114	//       } else {
  8115	//         fst::MutableArcIterator<CompactLattice> aiter(clat, state);
  8116	//
  8117	//         aiter.Seek(arc_id);
  8118	//         CompactLatticeArc arc = aiter.Value();
  8119	//
  8120	//         // Calculate likelihood
  8121	//         BaseFloat log_like = decodable->LogLikelihood(t, tid) * frame_scale;
  8122	//         // update weight
  8123	//         LatticeWeight new_weight = arc.weight.Weight();
  8124	//         new_weight.SetValue2(-log_like + arc.weight.Weight().Value2());
  8125	//         arc.weight.SetWeight(new_weight);
  8126	//         aiter.SetValue(arc);
  8127	//       }
  8128	//     }
  8129	//   }
  8130	//   return true;
  8131	// }
  8132	//
  8133	//
  8134	// bool RescoreCompactLatticeSpeedup(
  8135	//     const TransitionModel &tmodel,
  8136	//     BaseFloat speedup_factor,
  8137	//     DecodableInterface *decodable,
  8138	//     CompactLattice *clat) {
  8139	//   return RescoreCompactLatticeInternal(&tmodel, speedup_factor, decodable, clat);
  8140	// }
  8141	//
  8142	// bool RescoreCompactLattice(DecodableInterface *decodable,
  8143	//                            CompactLattice *clat) {
  8144	//   return RescoreCompactLatticeInternal(NULL, 1.0, decodable, clat);
  8145	// }
  8146	//
  8147	//
  8148	// bool RescoreLattice(DecodableInterface *decodable,
  8149	//                     Lattice *lat) {
  8150	//   if (lat->NumStates() == 0) {
  8151	//     KALDI_WARN << "Rescoring empty lattice";
  8152	//     return false;
  8153	//   }
  8154	//   if (!lat->Properties(fst::kTopSorted, true)) {
  8155	//     if (fst::TopSort(lat) == false) {
  8156	//       KALDI_WARN << "Cycles detected in lattice.";
  8157	//       return false;
  8158	//     }
  8159	//   }
  8160	//   std::vector<int32> state_times;
  8161	//   int32 utt_len = kaldi::LatticeStateTimes(*lat, &state_times);
  8162	//
  8163	//   std::vector<std::vector<int32> > time_to_state(utt_len );
  8164	//
  8165	//   int32 num_states = lat->NumStates();
  8166	//   KALDI_ASSERT(num_states == state_times.size());
  8167	//   for (size_t state = 0; state < num_states; state++) {
  8168	//     int32 t = state_times[state];
  8169	//     // Don't check t >= 0 because non-accessible states could have t = -1.
  8170	//     KALDI_ASSERT(t <= utt_len);
  8171	//     if (t >= 0 && t < utt_len)
  8172	//       time_to_state[t].push_back(state);
  8173	//   }
  8174	//
  8175	//   for (int32 t = 0; t < utt_len; t++) {
  8176	//     if ((t < utt_len - 1) && decodable->IsLastFrame(t)) {
  8177	//       KALDI_WARN << "Features are too short for lattice: utt-len is "
  8178	//                  << utt_len << ", " << t << " is last frame";
  8179	//       return false;
  8180	//     }
  8181	//     for (size_t i = 0; i < time_to_state[t].size(); i++) {
  8182	//       int32 state = time_to_state[t][i];
  8183	//       for (fst::MutableArcIterator<Lattice> aiter(lat, state);
  8184	//            !aiter.Done(); aiter.Next()) {
  8185	//         LatticeArc arc = aiter.Value();
  8186	//         if (arc.ilabel != 0) {
  8187	//           int32 trans_id = arc.ilabel; // Note: it doesn't necessarily
  8188	//           // have to be a transition-id, just whatever the Decodable
  8189	//           // object is expecting, but it's normally a transition-id.
  8190	//
  8191	//           BaseFloat log_like = decodable->LogLikelihood(t, trans_id);
  8192	//           arc.weight.SetValue2(-log_like + arc.weight.Value2());
  8193	//           aiter.SetValue(arc);
  8194	//         }
  8195	//       }
  8196	//     }
  8197	//   }
  8198	//   return true;
  8199	// }
  8200	//
  8201	//
  8202	// BaseFloat LatticeForwardBackwardMmi(
  8203	//     const TransitionModel &tmodel,
  8204	//     const Lattice &lat,
  8205	//     const std::vector<int32> &num_ali,
  8206	//     bool drop_frames,
  8207	//     bool convert_to_pdf_ids,
  8208	//     bool cancel,
  8209	//     Posterior *post) {
  8210	//   // First compute the MMI posteriors.
  8211	//
  8212	//   Posterior den_post;
  8213	//   BaseFloat ans = LatticeForwardBackward(lat,
  8214	//                                          &den_post,
  8215	//                                          NULL);
  8216	//
  8217	//   Posterior num_post;
  8218	//   AlignmentToPosterior(num_ali, &num_post);
  8219	//
  8220	//   // Now negate the MMI posteriors and add the numerator
  8221	//   // posteriors.
  8222	//   ScalePosterior(-1.0, &den_post);
  8223	//
  8224	//   if (convert_to_pdf_ids) {
  8225	//     Posterior num_tmp;
  8226	//     ConvertPosteriorToPdfs(tmodel, num_post, &num_tmp);
  8227	//     num_tmp.swap(num_post);
  8228	//     Posterior den_tmp;
  8229	//     ConvertPosteriorToPdfs(tmodel, den_post, &den_tmp);
  8230	//     den_tmp.swap(den_post);
  8231	//   }
  8232	//
  8233	//   MergePosteriors(num_post, den_post,
  8234	//                   cancel, drop_frames, post);
  8235	//
  8236	//   return ans;
  8237	// }
  8238	//
  8239	//
  8240	// int32 LongestSentenceLength(const Lattice &lat) {
  8241	//   typedef Lattice::Arc Arc;
  8242	//   typedef Arc::Label Label;
  8243	//   typedef Arc::StateId StateId;
  8244	//
  8245	//   if (lat.Properties(fst::kTopSorted, true) == 0) {
  8246	//     Lattice lat_copy(lat);
  8247	//     if (!TopSort(&lat_copy))
  8248	//       KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
  8249	//     return LongestSentenceLength(lat_copy);
  8250	//   }
  8251	//   std::vector<int32> max_length(lat.NumStates(), 0);
  8252	//   int32 lattice_max_length = 0;
  8253	//   for (StateId s = 0; s < lat.NumStates(); s++) {
  8254	//     int32 this_max_length = max_length[s];
  8255	//     for (fst::ArcIterator<Lattice> aiter(lat, s); !aiter.Done(); aiter.Next()) {
  8256	//       const Arc &arc = aiter.Value();
  8257	//       bool arc_has_word = (arc.olabel != 0);
  8258	//       StateId nextstate = arc.nextstate;
  8259	//       KALDI_ASSERT(static_cast<size_t>(nextstate) < max_length.size());
  8260	//       if (arc_has_word) {
  8261	//         // A lattice should ideally not have cycles anyway; a cycle with a word
  8262	//         // on is something very bad.
  8263	//         KALDI_ASSERT(nextstate > s && "Lattice has cycles with words on.");
  8264	//         max_length[nextstate] = std::max(max_length[nextstate],
  8265	//                                          this_max_length + 1);
  8266	//       } else {
  8267	//         max_length[nextstate] = std::max(max_length[nextstate],
  8268	//                                          this_max_length);
  8269	//       }
  8270	//     }
  8271	//     if (lat.Final(s) != LatticeWeight::Zero())
  8272	//       lattice_max_length = std::max(lattice_max_length, max_length[s]);
  8273	//   }
  8274	//   return lattice_max_length;
  8275	// }
  8276	//
  8277	// int32 LongestSentenceLength(const CompactLattice &clat) {
  8278	//   typedef CompactLattice::Arc Arc;
  8279	//   typedef Arc::Label Label;
  8280	//   typedef Arc::StateId StateId;
  8281	//
  8282	//   if (clat.Properties(fst::kTopSorted, true) == 0) {
  8283	//     CompactLattice clat_copy(clat);
  8284	//     if (!TopSort(&clat_copy))
  8285	//       KALDI_ERR << "Was not able to topologically sort lattice (cycles found?)";
  8286	//     return LongestSentenceLength(clat_copy);
  8287	//   }
  8288	//   std::vector<int32> max_length(clat.NumStates(), 0);
  8289	//   int32 lattice_max_length = 0;
  8290	//   for (StateId s = 0; s < clat.NumStates(); s++) {
  8291	//     int32 this_max_length = max_length[s];
  8292	//     for (fst::ArcIterator<CompactLattice> aiter(clat, s);
  8293	//          !aiter.Done(); aiter.Next()) {
  8294	//       const Arc &arc = aiter.Value();
  8295	//       bool arc_has_word = (arc.ilabel != 0); // note: olabel == ilabel.
  8296	//       // also note: for normal CompactLattice, e.g. as produced by
  8297	//       // determinization, all arcs will have nonzero labels, but the user might
  8298	//       // decide to remplace some of the labels with zero for some reason, and we
  8299	//       // want to support this.
  8300	//       StateId nextstate = arc.nextstate;
  8301	//       KALDI_ASSERT(static_cast<size_t>(nextstate) < max_length.size());
  8302	//       KALDI_ASSERT(nextstate > s && "CompactLattice has cycles");
  8303	//       if (arc_has_word)
  8304	//         max_length[nextstate] = std::max(max_length[nextstate],
  8305	//                                          this_max_length + 1);
  8306	//       else
  8307	//         max_length[nextstate] = std::max(max_length[nextstate],
  8308	//                                          this_max_length);
  8309	//     }
  8310	//     if (clat.Final(s) != CompactLatticeWeight::Zero())
  8311	//       lattice_max_length = std::max(lattice_max_length, max_length[s]);
  8312	//   }
  8313	//   return lattice_max_length;
  8314	// }
  8315	//
  8316	// void ComposeCompactLatticeDeterministic(
  8317	//     const CompactLattice& clat,
  8318	//     fst::DeterministicOnDemandFst<fst::StdArc>* det_fst,
  8319	//     CompactLattice* composed_clat) {
  8320	//   // StdFst::Arc and CompactLatticeArc has the same StateId type.
  8321	//   typedef fst::StdArc::StateId StateId;
  8322	//   typedef fst::StdArc::Weight Weight1;
  8323	//   typedef CompactLatticeArc::Weight Weight2;
  8324	//   typedef std::pair<StateId, StateId> StatePair;
  8325	//   typedef unordered_map<StatePair, StateId, PairHasher<StateId> > MapType;
  8326	//   typedef MapType::iterator IterType;
  8327	//
  8328	//   // Empties the output FST.
  8329	//   KALDI_ASSERT(composed_clat != NULL);
  8330	//   composed_clat->DeleteStates();
  8331	//
  8332	//   MapType state_map;
  8333	//   std::queue<StatePair> state_queue;
  8334	//
  8335	//   // Sets start state in <composed_clat>.
  8336	//   StateId start_state = composed_clat->AddState();
  8337	//   StatePair start_pair(clat.Start(), det_fst->Start());
  8338	//   composed_clat->SetStart(start_state);
  8339	//   state_queue.push(start_pair);
  8340	//   std::pair<IterType, bool> result =
  8341	//       state_map.insert(std::make_pair(start_pair, start_state));
  8342	//   KALDI_ASSERT(result.second == true);
  8343	//
  8344	//   // Starts composition here.
  8345	//   while (!state_queue.empty()) {
  8346	//     // Gets the first state in the queue.
  8347	//     StatePair s = state_queue.front();
  8348	//     StateId s1 = s.first;
  8349	//     StateId s2 = s.second;
  8350	//     state_queue.pop();
  8351	//
  8352	//
  8353	//     Weight2 clat_final = clat.Final(s1);
  8354	//     if (clat_final.Weight().Value1() !=
  8355	//         std::numeric_limits<BaseFloat>::infinity()) {
  8356	//       // Test for whether the final-prob of state s1 was zero.
  8357	//       Weight1 det_fst_final = det_fst->Final(s2);
  8358	//       if (det_fst_final.Value() !=
  8359	//           std::numeric_limits<BaseFloat>::infinity()) {
  8360	//         // Test for whether the final-prob of state s2 was zero.  If neither
  8361	//         // source-state final prob was zero, then we should create final state
  8362	//         // in fst_composed. We compute the product manually since this is more
  8363	//         // efficient.
  8364	//         Weight2 final_weight(LatticeWeight(clat_final.Weight().Value1() +
  8365	//                                            det_fst_final.Value(),
  8366	//                                            clat_final.Weight().Value2()),
  8367	//                              clat_final.String());
  8368	//         // we can assume final_weight is not Zero(), since neither of
  8369	//         // the sources was zero.
  8370	//         KALDI_ASSERT(state_map.find(s) != state_map.end());
  8371	//         composed_clat->SetFinal(state_map[s], final_weight);
  8372	//       }
  8373	//     }
  8374	//
  8375	//     // Loops over pair of edges at s1 and s2.
  8376	//     for (fst::ArcIterator<CompactLattice> aiter(clat, s1);
  8377	//          !aiter.Done(); aiter.Next()) {
  8378	//       const CompactLatticeArc& arc1 = aiter.Value();
  8379	//       fst::StdArc arc2;
  8380	//       StateId next_state1 = arc1.nextstate, next_state2;
  8381	//       bool matched = false;
  8382	//
  8383	//       if (arc1.olabel == 0) {
  8384	//         // If the symbol on <arc1> is <epsilon>, we transit to the next state
  8385	//         // for <clat>, but keep <det_fst> at the current state.
  8386	//         matched = true;
  8387	//         next_state2 = s2;
  8388	//       } else {
  8389	//         // Otherwise try to find the matched arc in <det_fst>.
  8390	//         matched = det_fst->GetArc(s2, arc1.olabel, &arc2);
  8391	//         if (matched) {
  8392	//           next_state2 = arc2.nextstate;
  8393	//         }
  8394	//       }
  8395	//
  8396	//       // If matched arc is found in <det_fst>, then we have to add new arcs to
  8397	//       // <composed_clat>.
  8398	//       if (matched) {
  8399	//         StatePair next_state_pair(next_state1, next_state2);
  8400	//         IterType siter = state_map.find(next_state_pair);
  8401	//         StateId next_state;
  8402	//
  8403	//         // Adds composed state to <state_map>.
  8404	//         if (siter == state_map.end()) {
  8405	//           // If the composed state has not been created yet, create it.
  8406	//           next_state = composed_clat->AddState();
  8407	//           std::pair<const StatePair, StateId> next_state_map(next_state_pair,
  8408	//                                                              next_state);
  8409	//           std::pair<IterType, bool> result = state_map.insert(next_state_map);
  8410	//           KALDI_ASSERT(result.second);
  8411	//           state_queue.push(next_state_pair);
  8412	//         } else {
  8413	//           // If the composed state is already in <state_map>, we can directly
  8414	//           // use that.
  8415	//           next_state = siter->second;
  8416	//         }
  8417	//
  8418	//         // Adds arc to <composed_clat>.
  8419	//         if (arc1.olabel == 0) {
  8420	//           composed_clat->AddArc(state_map[s],
  8421	//                                 CompactLatticeArc(arc1.ilabel, 0,
  8422	//                                                   arc1.weight, next_state));
  8423	//         } else {
  8424	//           Weight2 composed_weight(
  8425	//               LatticeWeight(arc1.weight.Weight().Value1() +
  8426	//                             arc2.weight.Value(),
  8427	//                             arc1.weight.Weight().Value2()),
  8428	//               arc1.weight.String());
  8429	//           composed_clat->AddArc(state_map[s],
  8430	//                                 CompactLatticeArc(arc1.ilabel, arc2.olabel,
  8431	//                                                   composed_weight, next_state));
  8432	//         }
  8433	//       }
  8434	//     }
  8435	//   }
  8436	//   fst::Connect(composed_clat);
  8437	// }
  8438	//
  8439	//
  8440	// void ComputeAcousticScoresMap(
  8441	//     const Lattice &lat,
  8442	//     unordered_map<std::pair<int32, int32>, std::pair<BaseFloat, int32>,
  8443	//                                         PairHasher<int32> > *acoustic_scores) {
  8444	//   // typedef the arc, weight types
  8445	//   typedef Lattice::Arc Arc;
  8446	//   typedef Arc::Weight LatticeWeight;
  8447	//   typedef Arc::StateId StateId;
  8448	//
  8449	//   acoustic_scores->clear();
  8450	//
  8451	//   std::vector<int32> state_times;
  8452	//   LatticeStateTimes(lat, &state_times);   // Assumes the input is top sorted
  8453	//
  8454	//   KALDI_ASSERT(lat.Start() == 0);
  8455	//
  8456	//   for (StateId s = 0; s < lat.NumStates(); s++) {
  8457	//     int32 t = state_times[s];
  8458	//     for (fst::ArcIterator<Lattice> aiter(lat, s); !aiter.Done();
  8459	//           aiter.Next()) {
  8460	//       const Arc &arc = aiter.Value();
  8461	//       const LatticeWeight &weight = arc.weight;
  8462	//
  8463	//       int32 tid = arc.ilabel;
  8464	//
  8465	//       if (tid != 0) {
  8466	//         unordered_map<std::pair<int32, int32>, std::pair<BaseFloat, int32>,
  8467	//           PairHasher<int32> >::iterator it = acoustic_scores->find(std::make_pair(t, tid));
  8468	//         if (it == acoustic_scores->end()) {
  8469	//           acoustic_scores->insert(std::make_pair(std::make_pair(t, tid),
  8470	//                                           std::make_pair(weight.Value2(), 1)));
  8471	//         } else {
  8472	//           if (it->second.second == 2
  8473	//                 && it->second.first / it->second.second != weight.Value2()) {
  8474	//             KALDI_VLOG(2) << "Transitions on the same frame have different "
  8475	//                           << "acoustic costs for tid " << tid << "; "
  8476	//                           << it->second.first / it->second.second
  8477	//                           << " vs " << weight.Value2();
  8478	//           }
  8479	//           it->second.first += weight.Value2();
  8480	//           it->second.second++;
  8481	//         }
  8482	//       } else {
  8483	//         // Arcs with epsilon input label (tid) must have 0 acoustic cost
  8484	//         KALDI_ASSERT(weight.Value2() == 0);
  8485	//       }
  8486	//     }
  8487	//
  8488	//     LatticeWeight f = lat.Final(s);
  8489	//     if (f != LatticeWeight::Zero()) {
  8490	//       // Final acoustic cost must be 0 as we are reading from
  8491	//       // non-determinized, non-compact lattice
  8492	//       KALDI_ASSERT(f.Value2() == 0.0);
  8493	//     }
  8494	//   }
  8495	// }
  8496	//
  8497	// void ReplaceAcousticScoresFromMap(
  8498	//     const unordered_map<std::pair<int32, int32>, std::pair<BaseFloat, int32>,
  8499	//                                         PairHasher<int32> > &acoustic_scores,
  8500	//     Lattice *lat) {
  8501	//   // typedef the arc, weight types
  8502	//   typedef Lattice::Arc Arc;
  8503	//   typedef Arc::Weight LatticeWeight;
  8504	//   typedef Arc::StateId StateId;
  8505	//
  8506	//   TopSortLatticeIfNeeded(lat);
  8507	//
  8508	//   std::vector<int32> state_times;
  8509	//   LatticeStateTimes(*lat, &state_times);
  8510	//
  8511	//   KALDI_ASSERT(lat->Start() == 0);
  8512	//
  8513	//   for (StateId s = 0; s < lat->NumStates(); s++) {
  8514	//     int32 t = state_times[s];
  8515	//     for (fst::MutableArcIterator<Lattice> aiter(lat, s);
  8516	//          !aiter.Done(); aiter.Next()) {
  8517	//       Arc arc(aiter.Value());
  8518	//
  8519	//       int32 tid = arc.ilabel;
  8520	//       if (tid != 0) {
  8521	//         unordered_map<std::pair<int32, int32>, std::pair<BaseFloat, int32>,
  8522	//           PairHasher<int32> >::const_iterator it = acoustic_scores.find(std::make_pair(t, tid));
  8523	//         if (it == acoustic_scores.end()) {
  8524	//           KALDI_ERR << "Could not find tid " << tid << " at time " << t
  8525	//                     << " in the acoustic scores map.";
  8526	//         } else {
  8527	//           arc.weight.SetValue2(it->second.first / it->second.second);
  8528	//         }
  8529	//       } else {
  8530	//         // For epsilon arcs, set acoustic cost to 0.0
  8531	//         arc.weight.SetValue2(0.0);
  8532	//       }
  8533	//       aiter.SetValue(arc);
  8534	//     }
  8535	//
  8536	//     LatticeWeight f = lat->Final(s);
  8537	//     if (f != LatticeWeight::Zero()) {
  8538	//       // Set final acoustic cost to 0.0
  8539	//       f.SetValue2(0.0);
  8540	//       lat->SetFinal(s, f);
  8541	//     }
  8542	//   }
  8543	// }
  8544	
  8545	}  // namespace kaldi
  8546	// lm/arpa-file-parser.cc
  8547	
  8548	// Copyright 2014  Guoguo Chen
  8549	// Copyright 2016  Smart Action Company LLC (kkm)
  8550	
  8551	// See ../../COPYING for clarification regarding multiple authors
  8552	//
  8553	// Licensed under the Apache License, Version 2.0 (the "License");
  8554	// you may not use this file except in compliance with the License.
  8555	// You may obtain a copy of the License at
  8556	//
  8557	//  http://www.apache.org/licenses/LICENSE-2.0
  8558	//
  8559	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  8560	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  8561	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  8562	// MERCHANTABLITY OR NON-INFRINGEMENT.
  8563	// See the Apache 2 License for the specific language governing permissions and
  8564	// limitations under the License.
  8565	
  8566	#include <fst/fstlib.h>
  8567	
  8568	#include <sstream>
  8569	
  8570	#include "base/kaldi-error.h"
  8571	#include "base/kaldi-math.h"
  8572	#include "lm/arpa-file-parser.h"
  8573	#include "util/text-utils.h"
  8574	
  8575	namespace kaldi {
  8576	
  8577	ArpaFileParser::ArpaFileParser(const ArpaParseOptions& options,
  8578	                               fst::SymbolTable* symbols)
  8579	    : options_(options),
  8580	      symbols_(symbols),
  8581	      line_number_(0),
  8582	      warning_count_(0) {}
  8583	
  8584	ArpaFileParser::~ArpaFileParser() {}
  8585	
  8586	void TrimTrailingWhitespace(std::string* str) {
  8587	  str->erase(str->find_last_not_of(" \n\r\t") + 1);
  8588	}
  8589	
  8590	void ArpaFileParser::Read(std::istream& is) {
  8591	  // Argument sanity checks.
  8592	  if (options_.bos_symbol <= 0 || options_.eos_symbol <= 0 ||
  8593	      options_.bos_symbol == options_.eos_symbol)
  8594	    KALDI_ERR << "BOS and EOS symbols are required, must not be epsilons, and "
  8595	              << "differ from each other. Given:"
  8596	              << " BOS=" << options_.bos_symbol
  8597	              << " EOS=" << options_.eos_symbol;
  8598	  if (symbols_ != NULL &&
  8599	      options_.oov_handling == ArpaParseOptions::kReplaceWithUnk &&
  8600	      (options_.unk_symbol <= 0 || options_.unk_symbol == options_.bos_symbol ||
  8601	       options_.unk_symbol == options_.eos_symbol))
  8602	    KALDI_ERR << "When symbol table is given and OOV mode is kReplaceWithUnk, "
  8603	              << "UNK symbol is required, must not be epsilon, and "
  8604	              << "differ from both BOS and EOS symbols. Given:"
  8605	              << " UNK=" << options_.unk_symbol
  8606	              << " BOS=" << options_.bos_symbol
  8607	              << " EOS=" << options_.eos_symbol;
  8608	  if (symbols_ != NULL && symbols_->Find(options_.bos_symbol).empty())
  8609	    KALDI_ERR << "BOS symbol must exist in symbol table";
  8610	  if (symbols_ != NULL && symbols_->Find(options_.eos_symbol).empty())
  8611	    KALDI_ERR << "EOS symbol must exist in symbol table";
  8612	  if (symbols_ != NULL && options_.unk_symbol > 0 &&
  8613	      symbols_->Find(options_.unk_symbol).empty())
  8614	    KALDI_ERR << "UNK symbol must exist in symbol table";
  8615	
  8616	  ngram_counts_.clear();
  8617	  line_number_ = 0;
  8618	  warning_count_ = 0;
  8619	  current_line_.clear();
  8620	
  8621	#define PARSE_ERR KALDI_ERR << LineReference() << ": "
  8622	
  8623	  // Give derived class an opportunity to prepare its state.
  8624	  ReadStarted();
  8625	
  8626	  // Processes "\data\" section.
  8627	  bool keyword_found = false;
  8628	  while (++line_number_, getline(is, current_line_) && !is.eof()) {
  8629	    if (current_line_.find_first_not_of(" \t\n\r") == std::string::npos) {
  8630	      continue;
  8631	    }
  8632	
  8633	    TrimTrailingWhitespace(&current_line_);
  8634	
  8635	    // Continue skipping lines until the \data\ marker alone on a line is found.
  8636	    if (!keyword_found) {
  8637	      if (current_line_ == "\\data\\") {
  8638	        KALDI_LOG << "Reading \\data\\ section.";
  8639	        keyword_found = true;
  8640	      }
  8641	      continue;
  8642	    }
  8643	
  8644	    if (current_line_[0] == '\\') break;
  8645	
  8646	    // Enters "\data\" section, and looks for patterns like "ngram 1=1000",
  8647	    // which means there are 1000 unigrams.
  8648	    std::size_t equal_symbol_pos = current_line_.find("=");
  8649	    if (equal_symbol_pos != std::string::npos)
  8650	      // Guaranteed spaces around the "=".
  8651	      current_line_.replace(equal_symbol_pos, 1, " = ");
  8652	    std::vector<std::string> col;
  8653	    SplitStringToVector(current_line_, " \t", true, &col);
  8654	    if (col.size() == 4 && col[0] == "ngram" && col[2] == "=") {
  8655	      int32 order, ngram_count = 0;
  8656	      if (!ConvertStringToInteger(col[1], &order) ||
  8657	          !ConvertStringToInteger(col[3], &ngram_count)) {
  8658	        PARSE_ERR << "cannot parse ngram count";
  8659	      }
  8660	      if (ngram_counts_.size() <= order) {
  8661	        ngram_counts_.resize(order);
  8662	      }
  8663	      ngram_counts_[order - 1] = ngram_count;
  8664	    } else {
  8665	      KALDI_WARN << LineReference()
  8666	                 << ": uninterpretable line in \\data\\ section";
  8667	    }
  8668	  }
  8669	
  8670	  if (ngram_counts_.size() == 0)
  8671	    PARSE_ERR << "\\data\\ section missing or empty.";
  8672	
  8673	  // Signal that grammar order and n-gram counts are known.
  8674	  HeaderAvailable();
  8675	
  8676	  NGram ngram;
  8677	  ngram.words.reserve(ngram_counts_.size());
  8678	
  8679	  // Processes "\N-grams:" section.
  8680	  for (int32 cur_order = 1; cur_order <= ngram_counts_.size(); ++cur_order) {
  8681	    // Skips n-grams with zero count.
  8682	    if (ngram_counts_[cur_order - 1] == 0)
  8683	      KALDI_WARN << "Zero ngram count in ngram order " << cur_order
  8684	                 << "(look for 'ngram " << cur_order << "=0' in the \\data\\ "
  8685	                 << " section). There is possibly a problem with the file.";
  8686	
  8687	    // Must be looking at a \k-grams: directive at this point.
  8688	    std::ostringstream keyword;
  8689	    keyword << "\\" << cur_order << "-grams:";
  8690	    if (current_line_ != keyword.str()) {
  8691	      PARSE_ERR << "invalid directive, expecting '" << keyword.str() << "'";
  8692	    }
  8693	    KALDI_LOG << "Reading " << current_line_ << " section.";
  8694	
  8695	    int32 ngram_count = 0;
  8696	    while (++line_number_, getline(is, current_line_) && !is.eof()) {
  8697	      if (current_line_.find_first_not_of(" \n\t\r") == std::string::npos) {
  8698	        continue;
  8699	      }
  8700	      if (current_line_[0] == '\\') {
  8701	        TrimTrailingWhitespace(&current_line_);
  8702	        std::ostringstream next_keyword;
  8703	        next_keyword << "\\" << cur_order + 1 << "-grams:";
  8704	        if ((current_line_ != next_keyword.str()) &&
  8705	            (current_line_ != "\\end\\")) {
  8706	          if (ShouldWarn()) {
  8707	            KALDI_WARN << "ignoring possible directive '" << current_line_
  8708	                       << "' expecting '" << next_keyword.str() << "'";
  8709	
  8710	            if (warning_count_ > 0 &&
  8711	                warning_count_ > static_cast<uint32>(options_.max_warnings)) {
  8712	              KALDI_WARN << "Of " << warning_count_ << " parse warnings, "
  8713	                         << options_.max_warnings << " were reported. "
  8714	                         << "Run program with --max-arpa-warnings=-1 "
  8715	                         << "to see all warnings";
  8716	            }
  8717	          }
  8718	        } else {
  8719	          break;
  8720	        }
  8721	      }
  8722	
  8723	      std::vector<std::string> col;
  8724	      SplitStringToVector(current_line_, " \t", true, &col);
  8725	
  8726	      if (col.size() < 1 + cur_order || col.size() > 2 + cur_order ||
  8727	          (cur_order == ngram_counts_.size() && col.size() != 1 + cur_order)) {
  8728	        PARSE_ERR << "Invalid n-gram data line";
  8729	      }
  8730	      ++ngram_count;
  8731	
  8732	      // Parse out n-gram logprob and, if present, backoff weight.
  8733	      if (!ConvertStringToReal(col[0], &ngram.logprob)) {
  8734	        PARSE_ERR << "invalid n-gram logprob '" << col[0] << "'";
  8735	      }
  8736	      ngram.backoff = 0.0;
  8737	      if (col.size() > cur_order + 1) {
  8738	        if (!ConvertStringToReal(col[cur_order + 1], &ngram.backoff))
  8739	          PARSE_ERR << "invalid backoff weight '" << col[cur_order + 1] << "'";
  8740	      }
  8741	      // Convert to natural log.
  8742	      ngram.logprob *= M_LN10;
  8743	      ngram.backoff *= M_LN10;
  8744	
  8745	      ngram.words.resize(cur_order);
  8746	      bool skip_ngram = false;
  8747	      for (int32 index = 0; !skip_ngram && index < cur_order; ++index) {
  8748	        int32 word;
  8749	        if (symbols_) {
  8750	          // Symbol table provided, so symbol labels are expected.
  8751	          if (options_.oov_handling == ArpaParseOptions::kAddToSymbols) {
  8752	            word = symbols_->AddSymbol(col[1 + index]);
  8753	          } else {
  8754	            word = symbols_->Find(col[1 + index]);
  8755	            if (word == -1) {  // fst::kNoSymbol
  8756	              switch (options_.oov_handling) {
  8757	                case ArpaParseOptions::kReplaceWithUnk:
  8758	                  word = options_.unk_symbol;
  8759	                  break;
  8760	                case ArpaParseOptions::kSkipNGram:
  8761	                  if (ShouldWarn())
  8762	                    KALDI_WARN << LineReference() << " skipped: word '"
  8763	                               << col[1 + index] << "' not in symbol table";
  8764	                  skip_ngram = true;
  8765	                  break;
  8766	                default:
  8767	                  PARSE_ERR << "word '" << col[1 + index]
  8768	                            << "' not in symbol table";
  8769	              }
  8770	            }
  8771	          }
  8772	        } else {
  8773	          // Symbols not provided, LM file should contain integers.
  8774	          if (!ConvertStringToInteger(col[1 + index], &word) || word < 0) {
  8775	            PARSE_ERR << "invalid symbol '" << col[1 + index] << "'";
  8776	          }
  8777	        }
  8778	        // Whichever way we got it, an epsilon is invalid.
  8779	        if (word == 0) {
  8780	          PARSE_ERR << "epsilon symbol '" << col[1 + index]
  8781	                    << "' is illegal in ARPA LM";
  8782	        }
  8783	        ngram.words[index] = word;
  8784	      }
  8785	      if (!skip_ngram) {
  8786	        ConsumeNGram(ngram);
  8787	      }
  8788	    }
  8789	    if (ngram_count > ngram_counts_[cur_order - 1]) {
  8790	      PARSE_ERR << "header said there would be " << ngram_counts_[cur_order - 1]
  8791	                << " n-grams of order " << cur_order
  8792	                << ", but we saw more already.";
  8793	    }
  8794	  }
  8795	
  8796	  if (current_line_ != "\\end\\") {
  8797	    PARSE_ERR << "invalid or unexpected directive line, expecting \\end\\";
  8798	  }
  8799	
  8800	  if (warning_count_ > 0 &&
  8801	      warning_count_ > static_cast<uint32>(options_.max_warnings)) {
  8802	    KALDI_WARN << "Of " << warning_count_ << " parse warnings, "
  8803	               << options_.max_warnings << " were reported. Run program with "
  8804	               << "--max_warnings=-1 to see all warnings";
  8805	  }
  8806	
  8807	  current_line_.clear();
  8808	  ReadComplete();
  8809	
  8810	#undef PARSE_ERR
  8811	}
  8812	
  8813	std::string ArpaFileParser::LineReference() const {
  8814	  std::ostringstream ss;
  8815	  ss << "line " << line_number_ << " [" << current_line_ << "]";
  8816	  return ss.str();
  8817	}
  8818	
  8819	bool ArpaFileParser::ShouldWarn() {
  8820	  return (warning_count_ != -1) &&
  8821	         (++warning_count_ <= static_cast<uint32>(options_.max_warnings));
  8822	}
  8823	
  8824	}  // namespace kaldi
  8825	// lm/arpa-lm-compiler.cc
  8826	
  8827	// Copyright 2009-2011 Gilles Boulianne
  8828	// Copyright 2016 Smart Action LLC (kkm)
  8829	// Copyright 2017 Xiaohui Zhang
  8830	
  8831	// See ../../COPYING for clarification regarding multiple authors
  8832	//
  8833	// Licensed under the Apache License, Version 2.0 (the "License");
  8834	// you may not use this file except in compliance with the License.
  8835	// You may obtain a copy of the License at
  8836	//
  8837	//  http://www.apache.org/licenses/LICENSE-2.0
  8838	//
  8839	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  8840	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  8841	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  8842	// MERCHANTABLITY OR NON-INFRINGEMENT.
  8843	// See the Apache 2 License for the specific language governing permissions and
  8844	// limitations under the License.
  8845	
  8846	#include <algorithm>
  8847	#include <functional>
  8848	#include <limits>
  8849	#include <sstream>
  8850	#include <unordered_map>
  8851	#include <utility>
  8852	#include <vector>
  8853	
  8854	#include "base/kaldi-math.h"
  8855	#include "fstext/remove-eps-local.h"
  8856	#include "lm/arpa-lm-compiler.h"
  8857	#include "util/stl-utils.h"
  8858	#include "util/text-utils.h"
  8859	
  8860	namespace kaldi {
  8861	
  8862	class ArpaLmCompilerImplInterface {
  8863	 public:
  8864	  virtual ~ArpaLmCompilerImplInterface() {}
  8865	  virtual void ConsumeNGram(const NGram& ngram, bool is_highest) = 0;
  8866	};
  8867	
  8868	namespace {
  8869	
  8870	typedef int32 StateId;
  8871	typedef int32 Symbol;
  8872	
  8873	// GeneralHistKey can represent state history in an arbitrarily large n
  8874	// n-gram model with symbol ids fitting int32.
  8875	class GeneralHistKey {
  8876	 public:
  8877	  // Construct key from being and end iterators.
  8878	  template <class InputIt>
  8879	  GeneralHistKey(InputIt begin, InputIt end) : vector_(begin, end) {}
  8880	  // Construct empty history key.
  8881	  GeneralHistKey() : vector_() {}
  8882	  // Return tails of the key as a GeneralHistKey. The tails of an n-gram
  8883	  // w[1..n] is the sequence w[2..n] (and the heads is w[1..n-1], but the
  8884	  // key class does not need this operartion).
  8885	  GeneralHistKey Tails() const {
  8886	    return GeneralHistKey(vector_.begin() + 1, vector_.end());
  8887	  }
  8888	  // Keys are equal if represent same state.
  8889	  friend bool operator==(const GeneralHistKey& a, const GeneralHistKey& b) {
  8890	    return a.vector_ == b.vector_;
  8891	  }
  8892	  // Public typename HashType for hashing.
  8893	  struct HashType : public std::unary_function<GeneralHistKey, size_t> {
  8894	    size_t operator()(const GeneralHistKey& key) const {
  8895	      return VectorHasher<Symbol>().operator()(key.vector_);
  8896	    }
  8897	  };
  8898	
  8899	 private:
  8900	  std::vector<Symbol> vector_;
  8901	};
  8902	
  8903	// OptimizedHistKey combines 3 21-bit symbol ID values into one 64-bit
  8904	// machine word. allowing significant memory reduction and some runtime
  8905	// benefit over GeneralHistKey. Since 3 symbols are enough to track history
  8906	// in a 4-gram model, this optimized key is used for smaller models with up
  8907	// to 4-gram and symbol values up to 2^21-1.
  8908	//
  8909	// See GeneralHistKey for interface requirements of a key class.
  8910	class OptimizedHistKey {
  8911	 public:
  8912	  enum {
  8913	    kShift = 21,  // 21 * 3 = 63 bits for data.
  8914	    kMaxData = (1 << kShift) - 1
  8915	  };
  8916	  template <class InputIt>
  8917	  OptimizedHistKey(InputIt begin, InputIt end) : data_(0) {
  8918	    for (uint32 shift = 0; begin != end; ++begin, shift += kShift) {
  8919	      data_ |= static_cast<uint64>(*begin) << shift;
  8920	    }
  8921	  }
  8922	  OptimizedHistKey() : data_(0) {}
  8923	  OptimizedHistKey Tails() const { return OptimizedHistKey(data_ >> kShift); }
  8924	  friend bool operator==(const OptimizedHistKey& a, const OptimizedHistKey& b) {
  8925	    return a.data_ == b.data_;
  8926	  }
  8927	  struct HashType : public std::unary_function<OptimizedHistKey, size_t> {
  8928	    size_t operator()(const OptimizedHistKey& key) const { return key.data_; }
  8929	  };
  8930	
  8931	 private:
  8932	  explicit OptimizedHistKey(uint64 data) : data_(data) {}
  8933	  uint64 data_;
  8934	};
  8935	
  8936	}  // namespace
  8937	
  8938	template <class HistKey>
  8939	class ArpaLmCompilerImpl : public ArpaLmCompilerImplInterface {
  8940	 public:
  8941	  ArpaLmCompilerImpl(ArpaLmCompiler* parent, fst::StdVectorFst* fst,
  8942	                     Symbol sub_eps);
  8943	
  8944	  virtual void ConsumeNGram(const NGram& ngram, bool is_highest);
  8945	
  8946	 private:
  8947	  StateId AddStateWithBackoff(HistKey key, float backoff);
  8948	  void CreateBackoff(HistKey key, StateId state, float weight);
  8949	
  8950	  ArpaLmCompiler* parent_;  // Not owned.
  8951	  fst::StdVectorFst* fst_;  // Not owned.
  8952	  Symbol bos_symbol_;
  8953	  Symbol eos_symbol_;
  8954	  Symbol sub_eps_;
  8955	
  8956	  StateId eos_state_;
  8957	  typedef unordered_map<HistKey, StateId, typename HistKey::HashType>
  8958	      HistoryMap;
  8959	  HistoryMap history_;
  8960	};
  8961	
  8962	template <class HistKey>
  8963	ArpaLmCompilerImpl<HistKey>::ArpaLmCompilerImpl(ArpaLmCompiler* parent,
  8964	                                                fst::StdVectorFst* fst,
  8965	                                                Symbol sub_eps)
  8966	    : parent_(parent),
  8967	      fst_(fst),
  8968	      bos_symbol_(parent->Options().bos_symbol),
  8969	      eos_symbol_(parent->Options().eos_symbol),
  8970	      sub_eps_(sub_eps) {
  8971	  // The algorithm maintains state per history. The 0-gram is a special state
  8972	  // for empty history. All unigrams (including BOS) backoff into this state.
  8973	  StateId zerogram = fst_->AddState();
  8974	  history_[HistKey()] = zerogram;
  8975	
  8976	  // Also, if </s> is not treated as epsilon, create a common end state for
  8977	  // all transitions accepting the </s>, since they do not back off. This small
  8978	  // optimization saves about 2% states in an average grammar.
  8979	  if (sub_eps_ == 0) {
  8980	    eos_state_ = fst_->AddState();
  8981	    fst_->SetFinal(eos_state_, 0);
  8982	  }
  8983	}
  8984	
  8985	template <class HistKey>
  8986	void ArpaLmCompilerImpl<HistKey>::ConsumeNGram(const NGram& ngram,
  8987	                                               bool is_highest) {
  8988	  // Generally, we do the following. Suppose we are adding an n-gram "A B
  8989	  // C". Then find the node for "A B", add a new node for "A B C", and connect
  8990	  // them with the arc accepting "C" with the specified weight. Also, add a
  8991	  // backoff arc from the new "A B C" node to its backoff state "B C".
  8992	  //
  8993	  // Two notable exceptions are the highest order n-grams, and final n-grams.
  8994	  //
  8995	  // When adding a highest order n-gram (e. g., our "A B C" is in a 3-gram LM),
  8996	  // the following optimization is performed. There is no point adding a node
  8997	  // for "A B C" with a "C" arc from "A B", since there will be no other
  8998	  // arcs ingoing to this node, and an epsilon backoff arc into the backoff
  8999	  // model "B C", with the weight of \bar{1}. To save a node, create an arc
  9000	  // accepting "C" directly from "A B" to "B C". This saves as many nodes
  9001	  // as there are the highest order n-grams, which is typically about half
  9002	  // the size of a large 3-gram model.
  9003	  //
  9004	  // Indeed, this does not apply to n-grams ending in EOS, since they do not
  9005	  // back off. These are special, as they do not have a back-off state, and
  9006	  // the node for "(..anything..) </s>" is always final. These are handled
  9007	  // in one of the two possible ways, If symbols <s> and </s> are being
  9008	  // replaced by epsilons, neither node nor arc is created, and the logprob
  9009	  // of the n-gram is applied to its source node as final weight. If <s> and
  9010	  // </s> are preserved, then a special final node for </s> is allocated and
  9011	  // used as the destination of the "</s>" acceptor arc.
  9012	  HistKey heads(ngram.words.begin(), ngram.words.end() - 1);
  9013	  typename HistoryMap::iterator source_it = history_.find(heads);
  9014	  if (source_it == history_.end()) {
  9015	    // There was no "A B", therefore the probability of "A B C" is zero.
  9016	    // Print a warning and discard current n-gram.
  9017	    if (parent_->ShouldWarn())
  9018	      KALDI_WARN << parent_->LineReference()
  9019	                 << " skipped: no parent (n-1)-gram exists";
  9020	    return;
  9021	  }
  9022	
  9023	  StateId source = source_it->second;
  9024	  StateId dest;
  9025	  Symbol sym = ngram.words.back();
  9026	  float weight = -ngram.logprob;
  9027	  if (sym == sub_eps_ || sym == 0) {
  9028	    KALDI_ERR << " <eps> or disambiguation symbol " << sym
  9029	              << "found in the ARPA file. ";
  9030	  }
  9031	  if (sym == eos_symbol_) {
  9032	    if (sub_eps_ == 0) {
  9033	      // Keep </s> as a real symbol when not substituting.
  9034	      dest = eos_state_;
  9035	    } else {
  9036	      // Treat </s> as if it was epsilon: mark source final, with the weight
  9037	      // of the n-gram.
  9038	      fst_->SetFinal(source, weight);
  9039	      return;
  9040	    }
  9041	  } else {
  9042	    // For the highest order n-gram, this may find an existing state, for
  9043	    // non-highest, will create one (unless there are duplicate n-grams
  9044	    // in the grammar, which cannot be reliably detected if highest order,
  9045	    // so we better do not do that at all).
  9046	    dest = AddStateWithBackoff(
  9047	        HistKey(ngram.words.begin() + (is_highest ? 1 : 0), ngram.words.end()),
  9048	        -ngram.backoff);
  9049	  }
  9050	
  9051	  if (sym == bos_symbol_) {
  9052	    weight = 0;  // Accepting <s> is always free.
  9053	    if (sub_eps_ == 0) {
  9054	      // <s> is as a real symbol, only accepted in the start state.
  9055	      source = fst_->AddState();
  9056	      fst_->SetStart(source);
  9057	    } else {
  9058	      // The new state for <s> unigram history *is* the start state.
  9059	      fst_->SetStart(dest);
  9060	      return;
  9061	    }
  9062	  }
  9063	
  9064	  // Add arc from source to dest, whichever way it was found.
  9065	  fst_->AddArc(source, fst::StdArc(sym, sym, weight, dest));
  9066	  return;
  9067	}
  9068	
  9069	// Find or create a new state for n-gram defined by key, and ensure it has a
  9070	// backoff transition.  The key is either the current n-gram for all but
  9071	// highest orders, or the tails of the n-gram for the highest order. The
  9072	// latter arises from the chain-collapsing optimization described above.
  9073	template <class HistKey>
  9074	StateId ArpaLmCompilerImpl<HistKey>::AddStateWithBackoff(HistKey key,
  9075	                                                         float backoff) {
  9076	  typename HistoryMap::iterator dest_it = history_.find(key);
  9077	  if (dest_it != history_.end()) {
  9078	    // Found an existing state in the history map. Invariant: if the state in
  9079	    // the map, then its backoff arc is in the FST. We are done.
  9080	    return dest_it->second;
  9081	  }
  9082	  // Otherwise create a new state and its backoff arc, and register in the map.
  9083	  StateId dest = fst_->AddState();
  9084	  history_[key] = dest;
  9085	  CreateBackoff(key.Tails(), dest, backoff);
  9086	  return dest;
  9087	}
  9088	
  9089	// Create a backoff arc for a state. Key is a backoff destination that may or
  9090	// may not exist. When the destination is not found, naturally fall back to
  9091	// the lower order model, and all the way down until one is found (since the
  9092	// 0-gram model is always present, the search is guaranteed to terminate).
  9093	template <class HistKey>
  9094	inline void ArpaLmCompilerImpl<HistKey>::CreateBackoff(HistKey key,
  9095	                                                       StateId state,
  9096	                                                       float weight) {
  9097	  typename HistoryMap::iterator dest_it = history_.find(key);
  9098	  while (dest_it == history_.end()) {
  9099	    key = key.Tails();
  9100	    dest_it = history_.find(key);
  9101	  }
  9102	
  9103	  // The arc should transduce either <eos> or #0 to <eps>, depending on the
  9104	  // epsilon substitution mode. This is the only case when input and output
  9105	  // label may differ.
  9106	  fst_->AddArc(state, fst::StdArc(sub_eps_, 0, weight, dest_it->second));
  9107	}
  9108	
  9109	ArpaLmCompiler::~ArpaLmCompiler() {
  9110	  if (impl_ != NULL) delete impl_;
  9111	}
  9112	
  9113	void ArpaLmCompiler::HeaderAvailable() {
  9114	  KALDI_ASSERT(impl_ == NULL);
  9115	  // Use optimized implementation if the grammar is 4-gram or less, and the
  9116	  // maximum attained symbol id will fit into the optimized range.
  9117	  int64 max_symbol = 0;
  9118	  if (Symbols() != NULL) max_symbol = Symbols()->AvailableKey() - 1;
  9119	  // If augmenting the symbol table, assume the worst case when all words in
  9120	  // the model being read are novel.
  9121	  if (Options().oov_handling == ArpaParseOptions::kAddToSymbols)
  9122	    max_symbol += NgramCounts()[0];
  9123	
  9124	  if (NgramCounts().size() <= 4 && max_symbol < OptimizedHistKey::kMaxData) {
  9125	    impl_ = new ArpaLmCompilerImpl<OptimizedHistKey>(this, &fst_, sub_eps_);
  9126	  } else {
  9127	    impl_ = new ArpaLmCompilerImpl<GeneralHistKey>(this, &fst_, sub_eps_);
  9128	    KALDI_LOG << "Reverting to slower state tracking because model is large: "
  9129	              << NgramCounts().size() << "-gram with symbols up to "
  9130	              << max_symbol;
  9131	  }
  9132	}
  9133	
  9134	void ArpaLmCompiler::ConsumeNGram(const NGram& ngram) {
  9135	  // <s> is invalid in tails, </s> in heads of an n-gram.
  9136	  for (int i = 0; i < ngram.words.size(); ++i) {
  9137	    if ((i > 0 && ngram.words[i] == Options().bos_symbol) ||
  9138	        (i + 1 < ngram.words.size() &&
  9139	         ngram.words[i] == Options().eos_symbol)) {
  9140	      if (ShouldWarn())
  9141	        KALDI_WARN << LineReference()
  9142	                   << " skipped: n-gram has invalid BOS/EOS placement";
  9143	      return;
  9144	    }
  9145	  }
  9146	
  9147	  bool is_highest = ngram.words.size() == NgramCounts().size();
  9148	  impl_->ConsumeNGram(ngram, is_highest);
  9149	}
  9150	
  9151	void ArpaLmCompiler::RemoveRedundantStates() {
  9152	  fst::StdArc::Label backoff_symbol = sub_eps_;
  9153	  if (backoff_symbol == 0) {
  9154	    // The method of removing redundant states implemented in this function
  9155	    // leads to slow determinization of L o G when people use the older style of
  9156	    // usage of arpa2fst where the --disambig-symbol option was not specified.
  9157	    // The issue seems to be that it creates a non-deterministic FST, while G is
  9158	    // supposed to be deterministic.  By 'return'ing below, we just disable this
  9159	    // method if people were using an older script.  This method isn't really
  9160	    // that consequential anyway, and people will move to the newer-style
  9161	    // scripts (see current utils/format_lm.sh), so this isn't much of a
  9162	    // problem.
  9163	    return;
  9164	  }
  9165	
  9166	  fst::StdArc::StateId num_states = fst_.NumStates();
  9167	
  9168	  // replace the #0 symbols on the input of arcs out of redundant states (states
  9169	  // that are not final and have only a backoff arc leaving them), with <eps>.
  9170	  for (fst::StdArc::StateId state = 0; state < num_states; state++) {
  9171	    if (fst_.NumArcs(state) == 1 &&
  9172	        fst_.Final(state) == fst::TropicalWeight::Zero()) {
  9173	      fst::MutableArcIterator<fst::StdVectorFst> iter(&fst_, state);
  9174	      fst::StdArc arc = iter.Value();
  9175	      if (arc.ilabel == backoff_symbol) {
  9176	        arc.ilabel = 0;
  9177	        iter.SetValue(arc);
  9178	      }
  9179	    }
  9180	  }
  9181	
  9182	  // we could call fst::RemoveEps, and it would have the same effect in normal
  9183	  // cases, where backoff_symbol != 0 and there are no epsilons in unexpected
  9184	  // places, but RemoveEpsLocal is a bit safer in case something weird is going
  9185	  // on; it guarantees not to blow up the FST.
  9186	  fst::RemoveEpsLocal(&fst_);
  9187	  KALDI_LOG << "Reduced num-states from " << num_states << " to "
  9188	            << fst_.NumStates();
  9189	}
  9190	
  9191	void ArpaLmCompiler::Check() const {
  9192	  if (fst_.Start() == fst::kNoStateId) {
  9193	    KALDI_ERR << "Arpa file did not contain the beginning-of-sentence symbol "
  9194	              << Symbols()->Find(Options().bos_symbol) << ".";
  9195	  }
  9196	}
  9197	
  9198	void ArpaLmCompiler::ReadComplete() {
  9199	  fst_.SetInputSymbols(Symbols());
  9200	  fst_.SetOutputSymbols(Symbols());
  9201	  RemoveRedundantStates();
  9202	  Check();
  9203	}
  9204	
  9205	}  // namespace kaldi
  9206	// bin/arpa2fst.cc
  9207	//
  9208	// Copyright 2009-2011  Gilles Boulianne.
  9209	//
  9210	// See ../../COPYING for clarification regarding multiple authors
  9211	//
  9212	// Licensed under the Apache License, Version 2.0 (the "License");
  9213	// you may not use this file except in compliance with the License.
  9214	// You may obtain a copy of the License at
  9215	//
  9216	//  http://www.apache.org/licenses/LICENSE-2.0
  9217	//
  9218	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  9219	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  9220	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  9221	// MERCHANTABILITY OR NON-INFRINGEMENT.
  9222	// See the Apache 2 License for the specific language governing permissions and
  9223	// limitations under the License.
  9224	
  9225	#include <string>
  9226	
  9227	#include "lm/arpa-lm-compiler.h"
  9228	#include "util/kaldi-io.h"
  9229	#include "util/parse-options.h"
  9230	
  9231	int main(int argc, char *argv[]) {
  9232	  using namespace kaldi;  // NOLINT
  9233	  try {
  9234	    const char *usage =
  9235	        "Convert an ARPA format language model into an FST\n"
  9236	        "Usage: arpa2fst [opts] <input-arpa> <output-fst>\n"
  9237	        " e.g.: arpa2fst --disambig-symbol=#0 --read-symbol-table="
  9238	        "data/lang/words_zh.txt lm/input.arpa G.fst\n\n"
  9239	        "Note: When called without switches, the output G.fst will contain\n"
  9240	        "an embedded symbol table. This is compatible with the way a previous\n"
  9241	        "version of arpa2fst worked.\n";
  9242	
  9243	    ParseOptions po(usage);
  9244	
  9245	    ArpaParseOptions options;
  9246	    options.Register(&po);
  9247	
  9248	    // Option flags.
  9249	    std::string bos_symbol = "<s>";
  9250	    std::string eos_symbol = "</s>";
  9251	    std::string disambig_symbol;
  9252	    std::string read_syms_filename;
  9253	    std::string write_syms_filename;
  9254	    bool keep_symbols = false;
  9255	    bool ilabel_sort = true;
  9256	
  9257	    po.Register("bos-symbol", &bos_symbol, "Beginning of sentence symbol");
  9258	    po.Register("eos-symbol", &eos_symbol, "End of sentence symbol");
  9259	    po.Register("disambig-symbol", &disambig_symbol,
  9260	                "Disambiguator. If provided (e. g. #0), used on input side of "
  9261	                "backoff links, and <s> and </s> are replaced with epsilons");
  9262	    po.Register("read-symbol-table", &read_syms_filename,
  9263	                "Use existing symbol table");
  9264	    po.Register("write-symbol-table", &write_syms_filename,
  9265	                "Write generated symbol table to a file");
  9266	    po.Register("keep-symbols", &keep_symbols,
  9267	                "Store symbol table with FST. Symbols always saved to FST if "
  9268	                "symbol tables are neither read or written (otherwise symbols "
  9269	                "would be lost entirely)");
  9270	    po.Register("ilabel-sort", &ilabel_sort, "Ilabel-sort the output FST");
  9271	
  9272	    po.Read(argc, argv);
  9273	
  9274	    if (po.NumArgs() != 1 && po.NumArgs() != 2) {
  9275	      po.PrintUsage();
  9276	      exit(1);
  9277	    }
  9278	    std::string arpa_rxfilename = po.GetArg(1),
  9279	                fst_wxfilename = po.GetOptArg(2);
  9280	
  9281	    int64 disambig_symbol_id = 0;
  9282	
  9283	    fst::SymbolTable *symbols;
  9284	    if (!read_syms_filename.empty()) {
  9285	      // Use existing symbols. Required symbols must be in the table.
  9286	      kaldi::Input kisym(read_syms_filename);
  9287	      symbols = fst::SymbolTable::ReadText(
  9288	          kisym.Stream(), PrintableWxfilename(read_syms_filename));
  9289	      if (symbols == NULL)
  9290	        KALDI_ERR << "Could not read symbol table from file "
  9291	                  << read_syms_filename;
  9292	
  9293	      options.oov_handling = ArpaParseOptions::kSkipNGram;
  9294	      if (!disambig_symbol.empty()) {
  9295	        disambig_symbol_id = symbols->Find(disambig_symbol);
  9296	        if (disambig_symbol_id == -1)  // fst::kNoSymbol
  9297	          KALDI_ERR << "Symbol table " << read_syms_filename
  9298	                    << " has no symbol for " << disambig_symbol;
  9299	      }
  9300	    } else {
  9301	      // Create a new symbol table and populate it from ARPA file.
  9302	      symbols = new fst::SymbolTable(PrintableWxfilename(fst_wxfilename));
  9303	      options.oov_handling = ArpaParseOptions::kAddToSymbols;
  9304	      symbols->AddSymbol("<eps>", 0);
  9305	      if (!disambig_symbol.empty()) {
  9306	        disambig_symbol_id = symbols->AddSymbol(disambig_symbol);
  9307	      }
  9308	    }
  9309	
  9310	    // Add or use existing BOS and EOS.
  9311	    options.bos_symbol = symbols->AddSymbol(bos_symbol);
  9312	    options.eos_symbol = symbols->AddSymbol(eos_symbol);
  9313	
  9314	    // If producing new (not reading existing) symbols and not saving them,
  9315	    // need to keep symbols with FST, otherwise they would be lost.
  9316	    if (read_syms_filename.empty() && write_syms_filename.empty())
  9317	      keep_symbols = true;
  9318	
  9319	    // Actually compile LM.
  9320	    KALDI_ASSERT(symbols != NULL);
  9321	    ArpaLmCompiler lm_compiler(options, disambig_symbol_id, symbols);
  9322	    {
  9323	      Input ki(arpa_rxfilename);
  9324	      lm_compiler.Read(ki.Stream());
  9325	    }
  9326	
  9327	    // Sort the FST in-place if requested by options.
  9328	    if (ilabel_sort) {
  9329	      fst::ArcSort(lm_compiler.MutableFst(), fst::StdILabelCompare());
  9330	    }
  9331	
  9332	    // Write symbols if requested.
  9333	    if (!write_syms_filename.empty()) {
  9334	      kaldi::Output kosym(write_syms_filename, false);
  9335	      symbols->WriteText(kosym.Stream());
  9336	    }
  9337	
  9338	    // Write LM FST.
  9339	    bool write_binary = true, write_header = false;
  9340	    kaldi::Output kofst(fst_wxfilename, write_binary, write_header);
  9341	    fst::FstWriteOptions wopts(PrintableWxfilename(fst_wxfilename));
  9342	    wopts.write_isymbols = wopts.write_osymbols = keep_symbols;
  9343	    lm_compiler.Fst().Write(kofst.Stream(), wopts);
  9344	
  9345	    delete symbols;
  9346	  } catch (const std::exception &e) {
  9347	    std::cerr << e.what();
  9348	    return -1;
  9349	  }
  9350	}
  9351	// util/kaldi-io.cc
  9352	
  9353	// Copyright 2009-2011  Microsoft Corporation;  Jan Silovsky
  9354	//                2016  Xiaohui Zhang
  9355	
  9356	// See ../../COPYING for clarification regarding multiple authors
  9357	//
  9358	// Licensed under the Apache License, Version 2.0 (the "License");
  9359	// you may not use this file except in compliance with the License.
  9360	// You may obtain a copy of the License at
  9361	
  9362	//  http://www.apache.org/licenses/LICENSE-2.0
  9363	
  9364	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  9365	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  9366	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  9367	// MERCHANTABLITY OR NON-INFRINGEMENT.
  9368	// See the Apache 2 License for the specific language governing permissions and
  9369	// limitations under the License.
  9370	#include "util/kaldi-io.h"
  9371	
  9372	#include <errno.h>
  9373	#include <stdio.h>
  9374	#include <stdlib.h>
  9375	
  9376	#include <cstdlib>
  9377	
  9378	#include "base/io-funcs.h"
  9379	#include "base/kaldi-math.h"
  9380	#include "util/kaldi-pipebuf.h"
  9381	#include "util/parse-options.h"
  9382	#include "util/text-utils.h"
  9383	
  9384	#ifdef KALDI_CYGWIN_COMPAT
  9385	#include "util/kaldi-cygwin-io-inl.h"
  9386	#define MapOsPath(x) MapCygwinPath(x)
  9387	#else  // KALDI_CYGWIN_COMPAT
  9388	#define MapOsPath(x) x
  9389	#endif  // KALDI_CYGWIN_COMPAT
  9390	
  9391	#if defined(_MSC_VER)
  9392	static FILE *popen(const char *command, const char *mode) {
  9393	#ifdef KALDI_CYGWIN_COMPAT
  9394	  return kaldi::CygwinCompatPopen(command, mode);
  9395	#else  // KALDI_CYGWIN_COMPAT
  9396	  return _popen(command, mode);
  9397	#endif  // KALDI_CYGWIN_COMPAT
  9398	}
  9399	#endif  // _MSC_VER
  9400	
  9401	namespace kaldi {
  9402	
  9403	#ifndef _MSC_VER  // on VS, we don't need this type.
  9404	// could replace basic_pipebuf<char> with stdio_filebuf<char> on some platforms.
  9405	// Would mean we could use less of our own code.
  9406	typedef basic_pipebuf<char> PipebufType;
  9407	#endif
  9408	}  // namespace kaldi
  9409	
  9410	namespace kaldi {
  9411	
  9412	std::string PrintableRxfilename(const std::string &rxfilename) {
  9413	  if (rxfilename == "" || rxfilename == "-") {
  9414	    return "standard input";
  9415	  } else {
  9416	    // If this call to Escape later causes compilation issues,
  9417	    // just replace it with "return rxfilename"; it's only a
  9418	    // pretty-printing issue.
  9419	    return ParseOptions::Escape(rxfilename);
  9420	  }
  9421	}
  9422	
  9423	std::string PrintableWxfilename(const std::string &wxfilename) {
  9424	  if (wxfilename == "" || wxfilename == "-") {
  9425	    return "standard output";
  9426	  } else {
  9427	    // If this call to Escape later causes compilation issues,
  9428	    // just replace it with "return wxfilename"; it's only a
  9429	    // pretty-printing issue.
  9430	    return ParseOptions::Escape(wxfilename);
  9431	  }
  9432	}
  9433	
  9434	OutputType ClassifyWxfilename(const std::string &filename) {
  9435	  const char *c = filename.c_str();
  9436	  size_t length = filename.length();
  9437	  char first_char = c[0],
  9438	       last_char = (length == 0 ? '\0' : c[filename.length() - 1]);
  9439	
  9440	  // if 'filename' is "" or "-", return kStandardOutput.
  9441	  if (length == 0 || (length == 1 && first_char == '-')) {
  9442	    return kStandardOutput;
  9443	  } else if (first_char == '|') {
  9444	    return kPipeOutput;  // An output pipe like "|blah".
  9445	  } else if (isspace(first_char) || isspace(last_char) || last_char == '|') {
  9446	    return kNoOutput;  // Leading or trailing space: can't interpret this.
  9447	                       // Final '|' would represent an input pipe, not an
  9448	                       // output pipe.
  9449	    // } else if ((first_char == 'a' || first_char == 's') &&
  9450	    //            strchr(c, ':') != NULL &&
  9451	    //            (ClassifyWspecifier(filename, NULL, NULL, NULL) !=
  9452	    //            kNoWspecifier ||
  9453	    //             ClassifyRspecifier(filename, NULL, NULL) != kNoRspecifier)) {
  9454	    //   // e.g. ark:something or scp:something... this is almost certainly a
  9455	    //   // scripting error, so call it an error rather than treating it as a
  9456	    //   file.
  9457	    //   // In practice in modern kaldi scripts all (r,w)filenames begin with
  9458	    //   "ark"
  9459	    //   // or "scp", even though technically speaking options like "b", "t",
  9460	    //   "s" or
  9461	    //   // "cs" can appear before the ark or scp, like "b,ark".  For
  9462	    //   efficiency,
  9463	    //   // and because this code is really just a nicety to catch errors
  9464	    //   earlier
  9465	    //   // than they would otherwise be caught, we only call those extra
  9466	    //   functions
  9467	    //   // for filenames beginning with 'a' or 's'.
  9468	    //   return kNoOutput;
  9469	  } else if (isdigit(last_char)) {
  9470	    // This could be a file, but we have to see if it's an offset into a file
  9471	    // (like foo.ark:4314328), which is not allowed for writing (but is
  9472	    // allowed for reaching).  This eliminates some things which would be
  9473	    // valid UNIX filenames but are not allowed by Kaldi.  (Even if we allowed
  9474	    // such filenames for writing, we woudln't be able to correctly read them).
  9475	    const char *d = c + length - 1;
  9476	    while (isdigit(*d) && d > c) d--;
  9477	    if (*d == ':') return kNoOutput;
  9478	    // else it could still be a filename; continue to the next check.
  9479	  }
  9480	
  9481	  // At this point it matched no other pattern so we assume a filename, but we
  9482	  // check for internal '|' as it's a common source of errors to have pipe
  9483	  // commands without the pipe in the right place.  Say that it can't be
  9484	  // classified.
  9485	  if (strchr(c, '|') != NULL) {
  9486	    KALDI_WARN << "Trying to classify wxfilename with pipe symbol in the"
  9487	                  " wrong place (pipe without | at the beginning?): "
  9488	               << filename;
  9489	    return kNoOutput;
  9490	  }
  9491	  return kFileOutput;  // It matched no other pattern: assume it's a filename.
  9492	}
  9493	
  9494	InputType ClassifyRxfilename(const std::string &filename) {
  9495	  const char *c = filename.c_str();
  9496	  size_t length = filename.length();
  9497	  char first_char = c[0],
  9498	       last_char = (length == 0 ? '\0' : c[filename.length() - 1]);
  9499	
  9500	  // if 'filename' is "" or "-", return kStandardInput.
  9501	  if (length == 0 || (length == 1 && first_char == '-')) {
  9502	    return kStandardInput;
  9503	  } else if (first_char == '|') {
  9504	    return kNoInput;  // An output pipe like "|blah": not
  9505	                      // valid for input.
  9506	  } else if (last_char == '|') {
  9507	    return kPipeInput;
  9508	  } else if (isspace(first_char) || isspace(last_char)) {
  9509	    return kNoInput;  // We don't allow leading or trailing space in a filename.
  9510	    // } else if ((first_char == 'a' || first_char == 's') &&
  9511	    //            strchr(c, ':') != NULL &&
  9512	    //           (ClassifyWspecifier(filename, NULL, NULL, NULL) !=
  9513	    //           kNoWspecifier ||
  9514	    //            ClassifyRspecifier(filename, NULL, NULL) != kNoRspecifier)) {
  9515	    //   // e.g. ark:something or scp:something... this is almost certainly a
  9516	    //   // scripting error, so call it an error rather than treating it as a
  9517	    //   file.
  9518	    //   // In practice in modern kaldi scripts all (r,w)filenames begin with
  9519	    //   "ark"
  9520	    //   // or "scp", even though technically speaking options like "b", "t",
  9521	    //   "s" or
  9522	    //   // "cs" can appear before the ark or scp, like "b,ark".  For
  9523	    //   efficiency,
  9524	    //   // and because this code is really just a nicety to catch errors
  9525	    //   earlier
  9526	    //   // than they would otherwise be caught, we only call those extra
  9527	    //   functions
  9528	    //   // for filenames beginning with 'a' or 's'.
  9529	    //   return kNoInput;
  9530	  } else if (isdigit(last_char)) {
  9531	    const char *d = c + length - 1;
  9532	    while (isdigit(*d) && d > c) d--;
  9533	    if (*d == ':')
  9534	      return kOffsetFileInput;  // Filename is like
  9535	                                // some_file:12345
  9536	    // otherwise it could still be a filename; continue to the next check.
  9537	  }
  9538	
  9539	  // At this point it matched no other pattern so we assume a filename, but
  9540	  // we check for '|' as it's a common source of errors to have pipe
  9541	  // commands without the pipe in the right place.  Say that it can't be
  9542	  // classified in this case.
  9543	  if (strchr(c, '|') != NULL) {
  9544	    KALDI_WARN << "Trying to classify rxfilename with pipe symbol in the"
  9545	                  " wrong place (pipe without | at the end?): "
  9546	               << filename;
  9547	    return kNoInput;
  9548	  }
  9549	  return kFileInput;  // It matched no other pattern: assume it's a filename.
  9550	}
  9551	
  9552	class OutputImplBase {
  9553	 public:
  9554	  // Open will open it as a file (no header), and return true
  9555	  // on success.  It cannot be called on an already open stream.
  9556	  virtual bool Open(const std::string &filename, bool binary) = 0;
  9557	  virtual std::ostream &Stream() = 0;
  9558	  virtual bool Close() = 0;
  9559	  virtual ~OutputImplBase() {}
  9560	};
  9561	
  9562	class FileOutputImpl : public OutputImplBase {
  9563	 public:
  9564	  virtual bool Open(const std::string &filename, bool binary) {
  9565	    if (os_.is_open())
  9566	      KALDI_ERR << "FileOutputImpl::Open(), "
  9567	                << "open called on already open file.";
  9568	    filename_ = filename;
  9569	    os_.open(MapOsPath(filename_).c_str(),
  9570	             binary ? std::ios_base::out | std::ios_base::binary
  9571	                    : std::ios_base::out);
  9572	    return os_.is_open();
  9573	  }
  9574	
  9575	  virtual std::ostream &Stream() {
  9576	    if (!os_.is_open())
  9577	      KALDI_ERR << "FileOutputImpl::Stream(), file is not open.";
  9578	    // I believe this error can only arise from coding error.
  9579	    return os_;
  9580	  }
  9581	
  9582	  virtual bool Close() {
  9583	    if (!os_.is_open())
  9584	      KALDI_ERR << "FileOutputImpl::Close(), file is not open.";
  9585	    // I believe this error can only arise from coding error.
  9586	    os_.close();
  9587	    return !(os_.fail());
  9588	  }
  9589	  virtual ~FileOutputImpl() {
  9590	    if (os_.is_open()) {
  9591	      os_.close();
  9592	      if (os_.fail()) KALDI_ERR << "Error closing output file " << filename_;
  9593	    }
  9594	  }
  9595	
  9596	 private:
  9597	  std::string filename_;
  9598	  std::ofstream os_;
  9599	};
  9600	
  9601	class StandardOutputImpl : public OutputImplBase {
  9602	 public:
  9603	  StandardOutputImpl() : is_open_(false) {}
  9604	
  9605	  virtual bool Open(const std::string &filename, bool binary) {
  9606	    if (is_open_)
  9607	      KALDI_ERR << "StandardOutputImpl::Open(), "
  9608	                   "open called on already open file.";
  9609	#ifdef _MSC_VER
  9610	    _setmode(_fileno(stdout), binary ? _O_BINARY : _O_TEXT);
  9611	#endif
  9612	    is_open_ = std::cout.good();
  9613	    return is_open_;
  9614	  }
  9615	
  9616	  virtual std::ostream &Stream() {
  9617	    if (!is_open_)
  9618	      KALDI_ERR << "StandardOutputImpl::Stream(), object not initialized.";
  9619	    // I believe this error can only arise from coding error.
  9620	    return std::cout;
  9621	  }
  9622	
  9623	  virtual bool Close() {
  9624	    if (!is_open_)
  9625	      KALDI_ERR << "StandardOutputImpl::Close(), file is not open.";
  9626	    is_open_ = false;
  9627	    std::cout << std::flush;
  9628	    return !(std::cout.fail());
  9629	  }
  9630	  virtual ~StandardOutputImpl() {
  9631	    if (is_open_) {
  9632	      std::cout << std::flush;
  9633	      if (std::cout.fail()) KALDI_ERR << "Error writing to standard output";
  9634	    }
  9635	  }
  9636	
  9637	 private:
  9638	  bool is_open_;
  9639	};
  9640	
  9641	class PipeOutputImpl : public OutputImplBase {
  9642	 public:
  9643	  PipeOutputImpl() : f_(NULL), os_(NULL) {}
  9644	
  9645	  virtual bool Open(const std::string &wxfilename, bool binary) {
  9646	    filename_ = wxfilename;
  9647	    KALDI_ASSERT(f_ == NULL);  // Make sure closed.
  9648	    KALDI_ASSERT(wxfilename.length() != 0 && wxfilename[0] == '|');  // should
  9649	    // start with '|'
  9650	    std::string cmd_name(wxfilename, 1);
  9651	#if defined(_MSC_VER) || defined(__CYGWIN__)
  9652	    f_ = popen(cmd_name.c_str(), (binary ? "wb" : "w"));
  9653	#else
  9654	    f_ = popen(cmd_name.c_str(), "w");
  9655	#endif
  9656	    if (!f_) {  // Failure.
  9657	      KALDI_WARN << "Failed opening pipe for writing, command is: " << cmd_name
  9658	                 << ", errno is " << strerror(errno);
  9659	      return false;
  9660	    } else {
  9661	#ifndef _MSC_VER
  9662	      fb_ = new PipebufType(f_,  // Using this constructor won't make the
  9663	                                 // destructor try to close the stream when
  9664	                                 // we're done.
  9665	                            (binary ? std::ios_base::out | std::ios_base::binary
  9666	                                    : std::ios_base::out));
  9667	      KALDI_ASSERT(fb_ != NULL);  // or would be alloc error.
  9668	      os_ = new std::ostream(fb_);
  9669	#else
  9670	      os_ = new std::ofstream(f_);
  9671	#endif
  9672	      return os_->good();
  9673	    }
  9674	  }
  9675	
  9676	  virtual std::ostream &Stream() {
  9677	    if (os_ == NULL)
  9678	      KALDI_ERR << "PipeOutputImpl::Stream(),"
  9679	                   " object not initialized.";
  9680	    // I believe this error can only arise from coding error.
  9681	    return *os_;
  9682	  }
  9683	
  9684	  virtual bool Close() {
  9685	    if (os_ == NULL) KALDI_ERR << "PipeOutputImpl::Close(), file is not open.";
  9686	    bool ok = true;
  9687	    os_->flush();
  9688	    if (os_->fail()) ok = false;
  9689	    delete os_;
  9690	    os_ = NULL;
  9691	    int status;
  9692	#ifdef _MSC_VER
  9693	    status = _pclose(f_);
  9694	#else
  9695	    status = pclose(f_);
  9696	#endif
  9697	    if (status)
  9698	      KALDI_WARN << "Pipe " << filename_ << " had nonzero return status "
  9699	                 << status;
  9700	    f_ = NULL;
  9701	#ifndef _MSC_VER
  9702	    delete fb_;
  9703	    fb_ = NULL;
  9704	#endif
  9705	    return ok;
  9706	  }
  9707	  virtual ~PipeOutputImpl() {
  9708	    if (os_) {
  9709	      if (!Close())
  9710	        KALDI_ERR << "Error writing to pipe " << PrintableWxfilename(filename_);
  9711	    }
  9712	  }
  9713	
  9714	 private:
  9715	  std::string filename_;
  9716	  FILE *f_;
  9717	#ifndef _MSC_VER
  9718	  PipebufType *fb_;
  9719	#endif
  9720	  std::ostream *os_;
  9721	};
  9722	
  9723	class InputImplBase {
  9724	 public:
  9725	  // Open will open it as a file, and return true on success.
  9726	  // May be called twice only for kOffsetFileInput (otherwise,
  9727	  // if called twice, we just create a new Input object, to avoid
  9728	  // having to deal with the extra hassle of reopening with the
  9729	  // same object.
  9730	  // Note that we will to call Open with true (binary) for
  9731	  // for text-mode Kaldi files; the only actual text-mode input
  9732	  // is for non-Kaldi files.
  9733	  virtual bool Open(const std::string &filename, bool binary) = 0;
  9734	  virtual std::istream &Stream() = 0;
  9735	  virtual int32 Close() = 0;  // We only need to check failure in the case of
  9736	                              // kPipeInput.
  9737	  // on close for input streams.
  9738	  virtual InputType MyType() = 0;  // Because if it's kOffsetFileInput, we may
  9739	                                   // call Open twice
  9740	  // (has efficiency benefits).
  9741	
  9742	  virtual ~InputImplBase() {}
  9743	};
  9744	
  9745	class FileInputImpl : public InputImplBase {
  9746	 public:
  9747	  virtual bool Open(const std::string &filename, bool binary) {
  9748	    if (is_.is_open())
  9749	      KALDI_ERR << "FileInputImpl::Open(), "
  9750	                << "open called on already open file.";
  9751	    is_.open(
  9752	        MapOsPath(filename).c_str(),
  9753	        binary ? std::ios_base::in | std::ios_base::binary : std::ios_base::in);
  9754	    return is_.is_open();
  9755	  }
  9756	
  9757	  virtual std::istream &Stream() {
  9758	    if (!is_.is_open())
  9759	      KALDI_ERR << "FileInputImpl::Stream(), file is not open.";
  9760	    // I believe this error can only arise from coding error.
  9761	    return is_;
  9762	  }
  9763	
  9764	  virtual int32 Close() {
  9765	    if (!is_.is_open())
  9766	      KALDI_ERR << "FileInputImpl::Close(), file is not open.";
  9767	    // I believe this error can only arise from coding error.
  9768	    is_.close();
  9769	    // Don't check status.
  9770	    return 0;
  9771	  }
  9772	
  9773	  virtual InputType MyType() { return kFileInput; }
  9774	
  9775	  virtual ~FileInputImpl() {
  9776	    // Stream will automatically be closed, and we don't care about
  9777	    // whether it fails.
  9778	  }
  9779	
  9780	 private:
  9781	  std::ifstream is_;
  9782	};
  9783	
  9784	class StandardInputImpl : public InputImplBase {
  9785	 public:
  9786	  StandardInputImpl() : is_open_(false) {}
  9787	
  9788	  virtual bool Open(const std::string &filename, bool binary) {
  9789	    if (is_open_)
  9790	      KALDI_ERR << "StandardInputImpl::Open(), "
  9791	                   "open called on already open file.";
  9792	    is_open_ = true;
  9793	#ifdef _MSC_VER
  9794	    _setmode(_fileno(stdin), binary ? _O_BINARY : _O_TEXT);
  9795	#endif
  9796	    return true;  // Don't check good() because would be false if
  9797	    // eof, which may be valid input.
  9798	  }
  9799	
  9800	  virtual std::istream &Stream() {
  9801	    if (!is_open_)
  9802	      KALDI_ERR << "StandardInputImpl::Stream(), object not initialized.";
  9803	    // I believe this error can only arise from coding error.
  9804	    return std::cin;
  9805	  }
  9806	
  9807	  virtual InputType MyType() { return kStandardInput; }
  9808	
  9809	  virtual int32 Close() {
  9810	    if (!is_open_) KALDI_ERR << "StandardInputImpl::Close(), file is not open.";
  9811	    is_open_ = false;
  9812	    return 0;
  9813	  }
  9814	  virtual ~StandardInputImpl() {}
  9815	
  9816	 private:
  9817	  bool is_open_;
  9818	};
  9819	
  9820	class PipeInputImpl : public InputImplBase {
  9821	 public:
  9822	  PipeInputImpl() : f_(NULL), is_(NULL) {}
  9823	
  9824	  virtual bool Open(const std::string &rxfilename, bool binary) {
  9825	    filename_ = rxfilename;
  9826	    KALDI_ASSERT(f_ == NULL);  // Make sure closed.
  9827	    KALDI_ASSERT(rxfilename.length() != 0 &&
  9828	                 rxfilename[rxfilename.length() - 1] ==
  9829	                     '|');  // should end with '|'
  9830	    std::string cmd_name(rxfilename, 0, rxfilename.length() - 1);
  9831	#if defined(_MSC_VER) || defined(__CYGWIN__)
  9832	    f_ = popen(cmd_name.c_str(), (binary ? "rb" : "r"));
  9833	#else
  9834	    f_ = popen(cmd_name.c_str(), "r");
  9835	#endif
  9836	
  9837	    if (!f_) {  // Failure.
  9838	      KALDI_WARN << "Failed opening pipe for reading, command is: " << cmd_name
  9839	                 << ", errno is " << strerror(errno);
  9840	      return false;
  9841	    } else {
  9842	#ifndef _MSC_VER
  9843	      fb_ = new PipebufType(f_,  // Using this constructor won't lead the
  9844	                                 // destructor to close the stream.
  9845	                            (binary ? std::ios_base::in | std::ios_base::binary
  9846	                                    : std::ios_base::in));
  9847	      KALDI_ASSERT(fb_ != NULL);  // or would be alloc error.
  9848	      is_ = new std::istream(fb_);
  9849	#else
  9850	      is_ = new std::ifstream(f_);
  9851	#endif
  9852	      if (is_->fail() || is_->bad()) return false;
  9853	      if (is_->eof()) {
  9854	        KALDI_WARN << "Pipe opened with command "
  9855	                   << PrintableRxfilename(rxfilename) << " is empty.";
  9856	        // don't return false: empty may be valid.
  9857	      }
  9858	      return true;
  9859	    }
  9860	  }
  9861	
  9862	  virtual std::istream &Stream() {
  9863	    if (is_ == NULL)
  9864	      KALDI_ERR << "PipeInputImpl::Stream(), object not initialized.";
  9865	    // I believe this error can only arise from coding error.
  9866	    return *is_;
  9867	  }
  9868	
  9869	  virtual int32 Close() {
  9870	    if (is_ == NULL) KALDI_ERR << "PipeInputImpl::Close(), file is not open.";
  9871	    delete is_;
  9872	    is_ = NULL;
  9873	    int32 status;
  9874	#ifdef _MSC_VER
  9875	    status = _pclose(f_);
  9876	#else
  9877	    status = pclose(f_);
  9878	#endif
  9879	    if (status)
  9880	      KALDI_WARN << "Pipe " << filename_ << " had nonzero return status "
  9881	                 << status;
  9882	    f_ = NULL;
  9883	#ifndef _MSC_VER
  9884	    delete fb_;
  9885	    fb_ = NULL;
  9886	#endif
  9887	    return status;
  9888	  }
  9889	  virtual ~PipeInputImpl() {
  9890	    if (is_) Close();
  9891	  }
  9892	  virtual InputType MyType() { return kPipeInput; }
  9893	
  9894	 private:
  9895	  std::string filename_;
  9896	  FILE *f_;
  9897	#ifndef _MSC_VER
  9898	  PipebufType *fb_;
  9899	#endif
  9900	  std::istream *is_;
  9901	};
  9902	
  9903	/*
  9904	#else
  9905	
  9906	// Just have an empty implementation of the pipe input that crashes if
  9907	// called.
  9908	class PipeInputImpl: public InputImplBase {
  9909	 public:
  9910	  PipeInputImpl() { KALDI_ASSERT(0 && "Pipe input not yet supported on this
  9911	  platform."); }
  9912	  virtual bool Open(const std::string, bool) { return 0; }
  9913	  virtual std::istream &Stream() const { return NULL; }
  9914	  virtual void Close() {}
  9915	  virtual InputType MyType() { return kPipeInput; }
  9916	};
  9917	
  9918	#endif
  9919	*/
  9920	
  9921	class OffsetFileInputImpl : public InputImplBase {
  9922	  // This class is a bit more complicated than the
  9923	
  9924	 public:
  9925	  // splits a filename like /my/file:123 into /my/file and the
  9926	  // number 123.  Crashes if not this format.
  9927	  static void SplitFilename(const std::string &rxfilename,
  9928	                            std::string *filename, size_t *offset) {
  9929	    size_t pos = rxfilename.find_last_of(':');
  9930	    KALDI_ASSERT(pos != std::string::npos);  // would indicate error in calling
  9931	    // code, as the filename is supposed to be of the correct form at this
  9932	    // point.
  9933	    *filename = std::string(rxfilename, 0, pos);
  9934	    std::string number(rxfilename, pos + 1);
  9935	    bool ans = ConvertStringToInteger(number, offset);
  9936	    if (!ans)
  9937	      KALDI_ERR << "Cannot get offset from filename " << rxfilename
  9938	                << " (possibly you compiled in 32-bit and have a >32-bit"
  9939	                << " byte offset into a file; you'll have to compile 64-bit.";
  9940	  }
  9941	
  9942	  bool Seek(size_t offset) {
  9943	    size_t cur_pos = is_.tellg();
  9944	    if (cur_pos == offset) {
  9945	      return true;
  9946	    } else if (cur_pos < offset && cur_pos + 100 > offset) {
  9947	      // We're close enough that it may be faster to just
  9948	      // read that data, rather than seek.
  9949	      for (size_t i = cur_pos; i < offset; i++) is_.get();
  9950	      return (is_.tellg() == std::streampos(offset));
  9951	    }
  9952	    // Try to actually seek.
  9953	    is_.seekg(offset, std::ios_base::beg);
  9954	    if (is_.fail()) {  // failbit or badbit is set [error happened]
  9955	      is_.close();
  9956	      return false;  // failure.
  9957	    } else {
  9958	      is_.clear();  // Clear any failure bits (e.g. eof).
  9959	      return true;  // success.
  9960	    }
  9961	  }
  9962	
  9963	  // This Open routine is unusual in that it is designed to work even
  9964	  // if it was already open.  This for efficiency when seeking multiple
  9965	  // times.
  9966	  virtual bool Open(const std::string &rxfilename, bool binary) {
  9967	    if (is_.is_open()) {
  9968	      // We are opening when we have an already-open file.
  9969	      // We may have to seek within this file, or else close it and
  9970	      // open a different one.
  9971	      std::string tmp_filename;
  9972	      size_t offset;
  9973	      SplitFilename(rxfilename, &tmp_filename, &offset);
  9974	      if (tmp_filename == filename_ && binary == binary_) {  // Just seek
  9975	        is_.clear();  // clear fail bit, etc.
  9976	        return Seek(offset);
  9977	      } else {
  9978	        is_.close();  // don't bother checking error status of is_.
  9979	        filename_ = tmp_filename;
  9980	        is_.open(MapOsPath(filename_).c_str(),
  9981	                 binary ? std::ios_base::in | std::ios_base::binary
  9982	                        : std::ios_base::in);
  9983	        if (!is_.is_open())
  9984	          return false;
  9985	        else
  9986	          return Seek(offset);
  9987	      }
  9988	    } else {
  9989	      size_t offset;
  9990	      SplitFilename(rxfilename, &filename_, &offset);
  9991	      binary_ = binary;
  9992	      is_.open(MapOsPath(filename_).c_str(),
  9993	               binary ? std::ios_base::in | std::ios_base::binary
  9994	                      : std::ios_base::in);
  9995	      if (!is_.is_open())
  9996	        return false;
  9997	      else
  9998	        return Seek(offset);
  9999	    }
 10000	  }
 10001	
 10002	  virtual std::istream &Stream() {
 10003	    if (!is_.is_open())
 10004	      KALDI_ERR << "FileInputImpl::Stream(), file is not open.";
 10005	    // I believe this error can only arise from coding error.
 10006	    return is_;
 10007	  }
 10008	
 10009	  virtual int32 Close() {
 10010	    if (!is_.is_open())
 10011	      KALDI_ERR << "FileInputImpl::Close(), file is not open.";
 10012	    // I believe this error can only arise from coding error.
 10013	    is_.close();
 10014	    // Don't check status.
 10015	    return 0;
 10016	  }
 10017	
 10018	  virtual InputType MyType() { return kOffsetFileInput; }
 10019	
 10020	  virtual ~OffsetFileInputImpl() {
 10021	    // Stream will automatically be closed, and we don't care about
 10022	    // whether it fails.
 10023	  }
 10024	
 10025	 private:
 10026	  std::string filename_;  // the actual filename
 10027	  bool binary_;           // true if was opened in binary mode.
 10028	  std::ifstream is_;
 10029	};
 10030	
 10031	Output::Output(const std::string &wxfilename, bool binary, bool write_header)
 10032	    : impl_(NULL) {
 10033	  if (!Open(wxfilename, binary, write_header)) {
 10034	    if (impl_) {
 10035	      delete impl_;
 10036	      impl_ = NULL;
 10037	    }
 10038	    KALDI_ERR << "Error opening output stream "
 10039	              << PrintableWxfilename(wxfilename);
 10040	  }
 10041	}
 10042	
 10043	bool Output::Close() {
 10044	  if (!impl_) {
 10045	    return false;  // error to call Close if not open.
 10046	  } else {
 10047	    bool ans = impl_->Close();
 10048	    delete impl_;
 10049	    impl_ = NULL;
 10050	    return ans;
 10051	  }
 10052	}
 10053	
 10054	Output::~Output() {
 10055	  if (impl_) {
 10056	    bool ok = impl_->Close();
 10057	    delete impl_;
 10058	    impl_ = NULL;
 10059	    if (!ok)
 10060	      KALDI_ERR << "Error closing output file "
 10061	                << PrintableWxfilename(filename_)
 10062	                << (ClassifyWxfilename(filename_) == kFileOutput
 10063	                        ? " (disk full?)"
 10064	                        : "");
 10065	  }
 10066	}
 10067	
 10068	std::ostream &Output::Stream() {  // will throw if not open; else returns
 10069	  // stream.
 10070	  if (!impl_) KALDI_ERR << "Output::Stream() called but not open.";
 10071	  return impl_->Stream();
 10072	}
 10073	
 10074	bool Output::Open(const std::string &wxfn, bool binary, bool header) {
 10075	  if (IsOpen()) {
 10076	    if (!Close()) {  // Throw here rather than return status, as it's an error
 10077	      // about something else: if the user wanted to avoid the exception he/she
 10078	      // could have called Close().
 10079	      KALDI_ERR << "Output::Open(), failed to close output stream: "
 10080	                << PrintableWxfilename(filename_);
 10081	    }
 10082	  }
 10083	
 10084	  filename_ = wxfn;
 10085	
 10086	  OutputType type = ClassifyWxfilename(wxfn);
 10087	  KALDI_ASSERT(impl_ == NULL);
 10088	
 10089	  if (type == kFileOutput) {
 10090	    impl_ = new FileOutputImpl();
 10091	  } else if (type == kStandardOutput) {
 10092	    impl_ = new StandardOutputImpl();
 10093	  } else if (type == kPipeOutput) {
 10094	    impl_ = new PipeOutputImpl();
 10095	  } else {  // type == kNoOutput
 10096	    KALDI_WARN << "Invalid output filename format "
 10097	               << PrintableWxfilename(wxfn);
 10098	    return false;
 10099	  }
 10100	  if (!impl_->Open(wxfn, binary)) {
 10101	    delete impl_;
 10102	    impl_ = NULL;
 10103	    return false;  // failed to open.
 10104	  } else {         // successfully opened it.
 10105	    if (header) {
 10106	      InitKaldiOutputStream(impl_->Stream(), binary);
 10107	      bool ok = impl_->Stream().good();  // still OK?
 10108	      if (!ok) {
 10109	        delete impl_;
 10110	        impl_ = NULL;
 10111	        return false;
 10112	      }
 10113	      return true;
 10114	    } else {
 10115	      return true;
 10116	    }
 10117	  }
 10118	}
 10119	
 10120	Input::Input(const std::string &rxfilename, bool *binary) : impl_(NULL) {
 10121	  if (!Open(rxfilename, binary)) {
 10122	    KALDI_ERR << "Error opening input stream "
 10123	              << PrintableRxfilename(rxfilename);
 10124	  }
 10125	}
 10126	
 10127	int32 Input::Close() {
 10128	  if (impl_) {
 10129	    int32 ans = impl_->Close();
 10130	    delete impl_;
 10131	    impl_ = NULL;
 10132	    return ans;
 10133	  } else {
 10134	    return 0;
 10135	  }
 10136	}
 10137	
 10138	bool Input::OpenInternal(const std::string &rxfilename, bool file_binary,
 10139	                         bool *contents_binary) {
 10140	  InputType type = ClassifyRxfilename(rxfilename);
 10141	  if (IsOpen()) {
 10142	    // May have to close the stream first.
 10143	    if (type == kOffsetFileInput && impl_->MyType() == kOffsetFileInput) {
 10144	      // We want to use the same object to Open... this is in case
 10145	      // the files are the same, so we can just seek.
 10146	      if (!impl_->Open(rxfilename, file_binary)) {  // true is binary mode--
 10147	        // always open in binary.
 10148	        delete impl_;
 10149	        impl_ = NULL;
 10150	        return false;
 10151	      }
 10152	      // read the binary header, if requested.
 10153	      if (contents_binary != NULL)
 10154	        return InitKaldiInputStream(impl_->Stream(), contents_binary);
 10155	      else
 10156	        return true;
 10157	    } else {
 10158	      Close();
 10159	      // and fall through to code below which actually opens the file.
 10160	    }
 10161	  }
 10162	  if (type == kFileInput) {
 10163	    impl_ = new FileInputImpl();
 10164	  } else if (type == kStandardInput) {
 10165	    impl_ = new StandardInputImpl();
 10166	  } else if (type == kPipeInput) {
 10167	    impl_ = new PipeInputImpl();
 10168	  } else if (type == kOffsetFileInput) {
 10169	    impl_ = new OffsetFileInputImpl();
 10170	  } else {  // type == kNoInput
 10171	    KALDI_WARN << "Invalid input filename format "
 10172	               << PrintableRxfilename(rxfilename);
 10173	    return false;
 10174	  }
 10175	  if (!impl_->Open(rxfilename, file_binary)) {  // true is binary mode--
 10176	    // always read in binary.
 10177	    delete impl_;
 10178	    impl_ = NULL;
 10179	    return false;
 10180	  }
 10181	  if (contents_binary != NULL)
 10182	    return InitKaldiInputStream(impl_->Stream(), contents_binary);
 10183	  else
 10184	    return true;
 10185	}
 10186	
 10187	Input::~Input() {
 10188	  if (impl_) Close();
 10189	}
 10190	
 10191	std::istream &Input::Stream() {
 10192	  if (!IsOpen()) KALDI_ERR << "Input::Stream(), not open.";
 10193	  return impl_->Stream();
 10194	}
 10195	
 10196	// template <> void ReadKaldiObject(const std::string &filename,
 10197	//                                  Matrix<float> *m) {
 10198	//   if (!filename.empty() && filename[filename.size() - 1] == ']') {
 10199	//     // This filename seems to have a 'range'... like foo.ark:4312423[20:30].
 10200	//     // (the bit in square brackets is the range).
 10201	//     std::string rxfilename, range;
 10202	//     if (!ExtractRangeSpecifier(filename, &rxfilename, &range)) {
 10203	//       KALDI_ERR << "Could not make sense of possible range specifier in
 10204	//       filename "
 10205	//                 << "while reading matrix: " << filename;
 10206	//     }
 10207	//     Matrix<float> temp;
 10208	//     bool binary_in;
 10209	//     Input ki(rxfilename, &binary_in);
 10210	//     temp.Read(ki.Stream(), binary_in);
 10211	//     if (!ExtractObjectRange(temp, range, m)) {
 10212	//       KALDI_ERR << "Error extracting range of object: " << filename;
 10213	//     }
 10214	//   } else {
 10215	//     // The normal case, there is no range.
 10216	//     bool binary_in;
 10217	//     Input ki(filename, &binary_in);
 10218	//     m->Read(ki.Stream(), binary_in);
 10219	//   }
 10220	// }
 10221	//
 10222	// template <> void ReadKaldiObject(const std::string &filename,
 10223	//                                  Matrix<double> *m) {
 10224	//   if (!filename.empty() && filename[filename.size() - 1] == ']') {
 10225	//     // This filename seems to have a 'range'... like foo.ark:4312423[20:30].
 10226	//     // (the bit in square brackets is the range).
 10227	//     std::string rxfilename, range;
 10228	//     if (!ExtractRangeSpecifier(filename, &rxfilename, &range)) {
 10229	//       KALDI_ERR << "Could not make sense of possible range specifier in
 10230	//       filename "
 10231	//                 << "while reading matrix: " << filename;
 10232	//     }
 10233	//     Matrix<double> temp;
 10234	//     bool binary_in;
 10235	//     Input ki(rxfilename, &binary_in);
 10236	//     temp.Read(ki.Stream(), binary_in);
 10237	//     if (!ExtractObjectRange(temp, range, m)) {
 10238	//       KALDI_ERR << "Error extracting range of object: " << filename;
 10239	//     }
 10240	//   } else {
 10241	//     // The normal case, there is no range.
 10242	//     bool binary_in;
 10243	//     Input ki(filename, &binary_in);
 10244	//     m->Read(ki.Stream(), binary_in);
 10245	//   }
 10246	// }
 10247	
 10248	}  // end namespace kaldi
 10249	// util/parse-options.cc
 10250	
 10251	// Copyright 2009-2011  Karel Vesely;  Microsoft Corporation;
 10252	//                      Saarland University (Author: Arnab Ghoshal);
 10253	// Copyright 2012-2013  Johns Hopkins University (Author: Daniel Povey);
 10254	//                      Frantisek Skala;  Arnab Ghoshal
 10255	// Copyright 2013       Tanel Alumae
 10256	//
 10257	// See ../../COPYING for clarification regarding multiple authors
 10258	//
 10259	// Licensed under the Apache License, Version 2.0 (the "License");
 10260	// you may not use this file except in compliance with the License.
 10261	// You may obtain a copy of the License at
 10262	//
 10263	//  http://www.apache.org/licenses/LICENSE-2.0
 10264	//
 10265	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 10266	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
 10267	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 10268	// MERCHANTABLITY OR NON-INFRINGEMENT.
 10269	// See the Apache 2 License for the specific language governing permissions and
 10270	// limitations under the License.
 10271	
 10272	#include <algorithm>
 10273	#include <cassert>
 10274	#include <cstdlib>
 10275	#include <cstring>
 10276	#include <fstream>
 10277	#include <iomanip>
 10278	#include <iostream>
 10279	
 10280	#include "base/kaldi-common.h"
 10281	#include "util/parse-options.h"
 10282	#include "util/text-utils.h"
 10283	
 10284	namespace kaldi {
 10285	
 10286	ParseOptions::ParseOptions(const std::string &prefix, OptionsItf *other)
 10287	    : print_args_(false), help_(false), usage_(""), argc_(0), argv_(NULL) {
 10288	  ParseOptions *po = dynamic_cast<ParseOptions *>(other);
 10289	  if (po != NULL && po->other_parser_ != NULL) {
 10290	    // we get here if this constructor is used twice, recursively.
 10291	    other_parser_ = po->other_parser_;
 10292	  } else {
 10293	    other_parser_ = other;
 10294	  }
 10295	  if (po != NULL && po->prefix_ != "") {
 10296	    prefix_ = po->prefix_ + std::string(".") + prefix;
 10297	  } else {
 10298	    prefix_ = prefix;
 10299	  }
 10300	}
 10301	
 10302	void ParseOptions::Register(const std::string &name, bool *ptr,
 10303	                            const std::string &doc) {
 10304	  RegisterTmpl(name, ptr, doc);
 10305	}
 10306	
 10307	void ParseOptions::Register(const std::string &name, int32 *ptr,
 10308	                            const std::string &doc) {
 10309	  RegisterTmpl(name, ptr, doc);
 10310	}
 10311	
 10312	void ParseOptions::Register(const std::string &name, uint32 *ptr,
 10313	                            const std::string &doc) {
 10314	  RegisterTmpl(name, ptr, doc);
 10315	}
 10316	
 10317	void ParseOptions::Register(const std::string &name, float *ptr,
 10318	                            const std::string &doc) {
 10319	  RegisterTmpl(name, ptr, doc);
 10320	}
 10321	
 10322	void ParseOptions::Register(const std::string &name, double *ptr,
 10323	                            const std::string &doc) {
 10324	  RegisterTmpl(name, ptr, doc);
 10325	}
 10326	
 10327	void ParseOptions::Register(const std::string &name, std::string *ptr,
 10328	                            const std::string &doc) {
 10329	  RegisterTmpl(name, ptr, doc);
 10330	}
 10331	
 10332	// old-style, used for registering application-specific parameters
 10333	template <typename T>
 10334	void ParseOptions::RegisterTmpl(const std::string &name, T *ptr,
 10335	                                const std::string &doc) {
 10336	  if (other_parser_ == NULL) {
 10337	    this->RegisterCommon(name, ptr, doc, false);
 10338	  } else {
 10339	    KALDI_ASSERT(prefix_ != "" &&
 10340	                 "Cannot use empty prefix when registering with prefix.");
 10341	    std::string new_name = prefix_ + '.' + name;  // name becomes prefix.name
 10342	    other_parser_->Register(new_name, ptr, doc);
 10343	  }
 10344	}
 10345	
 10346	// does the common part of the job of registering a parameter
 10347	template <typename T>
 10348	void ParseOptions::RegisterCommon(const std::string &name, T *ptr,
 10349	                                  const std::string &doc, bool is_standard) {
 10350	  KALDI_ASSERT(ptr != NULL);
 10351	  std::string idx = name;
 10352	  NormalizeArgName(&idx);
 10353	  if (doc_map_.find(idx) != doc_map_.end())
 10354	    KALDI_WARN << "Registering option twice, ignoring second time: " << name;
 10355	  this->RegisterSpecific(name, idx, ptr, doc, is_standard);
 10356	}
 10357	
 10358	// used to register standard parameters (those that are present in all of the
 10359	// applications)
 10360	template <typename T>
 10361	void ParseOptions::RegisterStandard(const std::string &name, T *ptr,
 10362	                                    const std::string &doc) {
 10363	  this->RegisterCommon(name, ptr, doc, true);
 10364	}
 10365	
 10366	void ParseOptions::RegisterSpecific(const std::string &name,
 10367	                                    const std::string &idx, bool *b,
 10368	                                    const std::string &doc, bool is_standard) {
 10369	  bool_map_[idx] = b;
 10370	  doc_map_[idx] =
 10371	      DocInfo(name, doc + " (bool, default = " + ((*b) ? "true)" : "false)"),
 10372	              is_standard);
 10373	}
 10374	
 10375	void ParseOptions::RegisterSpecific(const std::string &name,
 10376	                                    const std::string &idx, int32 *i,
 10377	                                    const std::string &doc, bool is_standard) {
 10378	  int_map_[idx] = i;
 10379	  std::ostringstream ss;
 10380	  ss << doc << " (int, default = " << *i << ")";
 10381	  doc_map_[idx] = DocInfo(name, ss.str(), is_standard);
 10382	}
 10383	
 10384	void ParseOptions::RegisterSpecific(const std::string &name,
 10385	                                    const std::string &idx, uint32 *u,
 10386	                                    const std::string &doc, bool is_standard) {
 10387	  uint_map_[idx] = u;
 10388	  std::ostringstream ss;
 10389	  ss << doc << " (uint, default = " << *u << ")";
 10390	  doc_map_[idx] = DocInfo(name, ss.str(), is_standard);
 10391	}
 10392	
 10393	void ParseOptions::RegisterSpecific(const std::string &name,
 10394	                                    const std::string &idx, float *f,
 10395	                                    const std::string &doc, bool is_standard) {
 10396	  float_map_[idx] = f;
 10397	  std::ostringstream ss;
 10398	  ss << doc << " (float, default = " << *f << ")";
 10399	  doc_map_[idx] = DocInfo(name, ss.str(), is_standard);
 10400	}
 10401	
 10402	void ParseOptions::RegisterSpecific(const std::string &name,
 10403	                                    const std::string &idx, double *f,
 10404	                                    const std::string &doc, bool is_standard) {
 10405	  double_map_[idx] = f;
 10406	  std::ostringstream ss;
 10407	  ss << doc << " (double, default = " << *f << ")";
 10408	  doc_map_[idx] = DocInfo(name, ss.str(), is_standard);
 10409	}
 10410	
 10411	void ParseOptions::RegisterSpecific(const std::string &name,
 10412	                                    const std::string &idx, std::string *s,
 10413	                                    const std::string &doc, bool is_standard) {
 10414	  string_map_[idx] = s;
 10415	  doc_map_[idx] =
 10416	      DocInfo(name, doc + " (string, default = \"" + *s + "\")", is_standard);
 10417	}
 10418	void ParseOptions::DisableOption(const std::string &name) {
 10419	  if (argv_ != NULL)
 10420	    KALDI_ERR << "DisableOption must not be called after calling Read().";
 10421	  if (doc_map_.erase(name) == 0)
 10422	    KALDI_ERR << "Option " << name
 10423	              << " was not registered so cannot be disabled: ";
 10424	  bool_map_.erase(name);
 10425	  int_map_.erase(name);
 10426	  uint_map_.erase(name);
 10427	  float_map_.erase(name);
 10428	  double_map_.erase(name);
 10429	  string_map_.erase(name);
 10430	}
 10431	
 10432	int ParseOptions::NumArgs() const { return positional_args_.size(); }
 10433	
 10434	std::string ParseOptions::GetArg(int i) const {
 10435	  // use KALDI_ERR if code error
 10436	  if (i < 1 || i > static_cast<int>(positional_args_.size()))
 10437	    KALDI_ERR << "ParseOptions::GetArg, invalid index " << i;
 10438	  return positional_args_[i - 1];
 10439	}
 10440	
 10441	// We currently do not support any other options.
 10442	enum ShellType { kBash = 0 };
 10443	
 10444	// This can be changed in the code if it ever does need to be changed (as it's
 10445	// unlikely that one compilation of this tool-set would use both shells).
 10446	static ShellType kShellType = kBash;
 10447	
 10448	// Returns true if we need to escape a string before putting it into
 10449	// a shell (mainly thinking of bash shell, but should work for others)
 10450	// This is for the convenience of the user so command-lines that are
 10451	// printed out by ParseOptions::Read (with --print-args=true) are
 10452	// paste-able into the shell and will run. If you use a different type of
 10453	// shell, it might be necessary to change this function.
 10454	// But it's mostly a cosmetic issue as it basically affects how
 10455	// the program echoes its command-line arguments to the screen.
 10456	static bool MustBeQuoted(const std::string &str, ShellType st) {
 10457	  // Only Bash is supported (for the moment).
 10458	  KALDI_ASSERT(st == kBash && "Invalid shell type.");
 10459	
 10460	  const char *c = str.c_str();
 10461	  if (*c == '\0') {
 10462	    return true;  // Must quote empty string
 10463	  } else {
 10464	    const char *ok_chars[2];
 10465	
 10466	    // These seem not to be interpreted as long as there are no other "bad"
 10467	    // characters involved (e.g. "," would be interpreted as part of something
 10468	    // like a{b,c}, but not on its own.
 10469	    ok_chars[kBash] = "[]~#^_-+=:.,/";
 10470	
 10471	    // Just want to make sure that a space character doesn't get automatically
 10472	    // inserted here via an automated style-checking script, like it did before.
 10473	    KALDI_ASSERT(!strchr(ok_chars[kBash], ' '));
 10474	
 10475	    for (; *c != '\0'; c++) {
 10476	      // For non-alphanumeric characters we have a list of characters which
 10477	      // are OK. All others are forbidden (this is easier since the shell
 10478	      // interprets most non-alphanumeric characters).
 10479	      if (!isalnum(*c)) {
 10480	        const char *d;
 10481	        for (d = ok_chars[st]; *d != '\0'; d++)
 10482	          if (*c == *d) break;
 10483	        // If not alphanumeric or one of the "ok_chars", it must be escaped.
 10484	        if (*d == '\0') return true;
 10485	      }
 10486	    }
 10487	    return false;  // The string was OK. No quoting or escaping.
 10488	  }
 10489	}
 10490	
 10491	// Returns a quoted and escaped version of "str"
 10492	// which has previously been determined to need escaping.
 10493	// Our aim is to print out the command line in such a way that if it's
 10494	// pasted into a shell of ShellType "st" (only bash for now), it
 10495	// will get passed to the program in the same way.
 10496	static std::string QuoteAndEscape(const std::string &str, ShellType st) {
 10497	  // Only Bash is supported (for the moment).
 10498	  KALDI_ASSERT(st == kBash && "Invalid shell type.");
 10499	
 10500	  // For now we use the following rules:
 10501	  // In the normal case, we quote with single-quote "'", and to escape
 10502	  // a single-quote we use the string: '\'' (interpreted as closing the
 10503	  // single-quote, putting an escaped single-quote from the shell, and
 10504	  // then reopening the single quote).
 10505	  char quote_char = '\'';
 10506	  const char *escape_str = "'\\''";  // e.g. echo 'a'\''b' returns a'b
 10507	
 10508	  // If the string contains single-quotes that would need escaping this
 10509	  // way, and we determine that the string could be safely double-quoted
 10510	  // without requiring any escaping, then we double-quote the string.
 10511	  // This is the case if the characters "`$\ do not appear in the string.
 10512	  // e.g. see http://www.redhat.com/mirrors/LDP/LDP/abs/html/quotingvar.html
 10513	  const char *c_str = str.c_str();
 10514	  if (strchr(c_str, '\'') && !strpbrk(c_str, "\"`$\\")) {
 10515	    quote_char = '"';
 10516	    escape_str = "\\\"";  // should never be accessed.
 10517	  }
 10518	
 10519	  char buf[2];
 10520	  buf[1] = '\0';
 10521	
 10522	  buf[0] = quote_char;
 10523	  std::string ans = buf;
 10524	  const char *c = str.c_str();
 10525	  for (; *c != '\0'; c++) {
 10526	    if (*c == quote_char) {
 10527	      ans += escape_str;
 10528	    } else {
 10529	      buf[0] = *c;
 10530	      ans += buf;
 10531	    }
 10532	  }
 10533	  buf[0] = quote_char;
 10534	  ans += buf;
 10535	  return ans;
 10536	}
 10537	
 10538	// static function
 10539	std::string ParseOptions::Escape(const std::string &str) {
 10540	  return MustBeQuoted(str, kShellType) ? QuoteAndEscape(str, kShellType) : str;
 10541	}
 10542	
 10543	int ParseOptions::Read(int argc, const char *const argv[]) {
 10544	  argc_ = argc;
 10545	  argv_ = argv;
 10546	  std::string key, value;
 10547	  int i;
 10548	  if (argc > 0) {
 10549	    // set global "const char*" g_program_name (name of the program)
 10550	    // so it can be printed out in error messages;
 10551	    // it's useful because often the stderr of different programs will
 10552	    // be mixed together in the same log file.
 10553	#ifdef _MSC_VER
 10554	    const char *c = strrchr(argv[0], '\\');
 10555	#else
 10556	    const char *c = strrchr(argv[0], '/');
 10557	#endif
 10558	    SetProgramName(c == NULL ? argv[0] : c + 1);
 10559	  }
 10560	  // first pass: look for config parameter, look for priority
 10561	  for (i = 1; i < argc; i++) {
 10562	    if (std::strncmp(argv[i], "--", 2) == 0) {
 10563	      if (std::strcmp(argv[i], "--") == 0) {
 10564	        // a lone "--" marks the end of named options
 10565	        break;
 10566	      }
 10567	      bool has_equal_sign;
 10568	      SplitLongArg(argv[i], &key, &value, &has_equal_sign);
 10569	      NormalizeArgName(&key);
 10570	      Trim(&value);
 10571	      if (key.compare("config") == 0) {
 10572	        ReadConfigFile(value);
 10573	      }
 10574	      if (key.compare("help") == 0) {
 10575	        PrintUsage();
 10576	        exit(0);
 10577	      }
 10578	    }
 10579	  }
 10580	  bool double_dash_seen = false;
 10581	  // second pass: add the command line options
 10582	  for (i = 1; i < argc; i++) {
 10583	    if (std::strncmp(argv[i], "--", 2) == 0) {
 10584	      if (std::strcmp(argv[i], "--") == 0) {
 10585	        // A lone "--" marks the end of named options.
 10586	        // Skip that option and break the processing of named options
 10587	        i += 1;
 10588	        double_dash_seen = true;
 10589	        break;
 10590	      }
 10591	      bool has_equal_sign;
 10592	      SplitLongArg(argv[i], &key, &value, &has_equal_sign);
 10593	      NormalizeArgName(&key);
 10594	      Trim(&value);
 10595	      if (!SetOption(key, value, has_equal_sign)) {
 10596	        PrintUsage(true);
 10597	        KALDI_ERR << "Invalid option " << argv[i];
 10598	      }
 10599	    } else {
 10600	      break;
 10601	    }
 10602	  }
 10603	
 10604	  // process remaining arguments as positional
 10605	  for (; i < argc; i++) {
 10606	    if ((std::strcmp(argv[i], "--") == 0) && !double_dash_seen) {
 10607	      double_dash_seen = true;
 10608	    } else {
 10609	      positional_args_.push_back(std::string(argv[i]));
 10610	    }
 10611	  }
 10612	
 10613	  // if the user did not suppress this with --print-args = false....
 10614	  if (print_args_) {
 10615	    std::ostringstream strm;
 10616	    for (int j = 0; j < argc; j++) strm << Escape(argv[j]) << " ";
 10617	    strm << '\n';
 10618	    std::cerr << strm.str() << std::flush;
 10619	  }
 10620	  return i;
 10621	}
 10622	
 10623	void ParseOptions::PrintUsage(bool print_command_line) {
 10624	  std::cerr << '\n' << usage_ << '\n';
 10625	  DocMapType::iterator it;
 10626	  // first we print application-specific options
 10627	  bool app_specific_header_printed = false;
 10628	  for (it = doc_map_.begin(); it != doc_map_.end(); ++it) {
 10629	    if (it->second.is_standard_ == false) {  // application-specific option
 10630	      if (app_specific_header_printed == false) {  // header was not yet printed
 10631	        std::cerr << "Options:" << '\n';
 10632	        app_specific_header_printed = true;
 10633	      }
 10634	      std::cerr << "  --" << std::setw(25) << std::left << it->second.name_
 10635	                << " : " << it->second.use_msg_ << '\n';
 10636	    }
 10637	  }
 10638	  if (app_specific_header_printed == true) {
 10639	    std::cerr << '\n';
 10640	  }
 10641	
 10642	  // then the standard options
 10643	  std::cerr << "Standard options:" << '\n';
 10644	  for (it = doc_map_.begin(); it != doc_map_.end(); ++it) {
 10645	    if (it->second.is_standard_ == true) {  // we have standard option
 10646	      std::cerr << "  --" << std::setw(25) << std::left << it->second.name_
 10647	                << " : " << it->second.use_msg_ << '\n';
 10648	    }
 10649	  }
 10650	  std::cerr << '\n';
 10651	  if (print_command_line) {
 10652	    std::ostringstream strm;
 10653	    strm << "Command line was: ";
 10654	    for (int j = 0; j < argc_; j++) strm << Escape(argv_[j]) << " ";
 10655	    strm << '\n';
 10656	    std::cerr << strm.str() << std::flush;
 10657	  }
 10658	}
 10659	
 10660	void ParseOptions::PrintConfig(std::ostream &os) {
 10661	  os << '\n' << "[[ Configuration of UI-Registered options ]]" << '\n';
 10662	  std::string key;
 10663	  DocMapType::iterator it;
 10664	  for (it = doc_map_.begin(); it != doc_map_.end(); ++it) {
 10665	    key = it->first;
 10666	    os << it->second.name_ << " = ";
 10667	    if (bool_map_.end() != bool_map_.find(key)) {
 10668	      os << (*bool_map_[key] ? "true" : "false");
 10669	    } else if (int_map_.end() != int_map_.find(key)) {
 10670	      os << (*int_map_[key]);
 10671	    } else if (uint_map_.end() != uint_map_.find(key)) {
 10672	      os << (*uint_map_[key]);
 10673	    } else if (float_map_.end() != float_map_.find(key)) {
 10674	      os << (*float_map_[key]);
 10675	    } else if (double_map_.end() != double_map_.find(key)) {
 10676	      os << (*double_map_[key]);
 10677	    } else if (string_map_.end() != string_map_.find(key)) {
 10678	      os << "'" << *string_map_[key] << "'";
 10679	    } else {
 10680	      KALDI_ERR << "PrintConfig: unrecognized option " << key << "[code error]";
 10681	    }
 10682	    os << '\n';
 10683	  }
 10684	  os << '\n';
 10685	}
 10686	
 10687	void ParseOptions::ReadConfigFile(const std::string &filename) {
 10688	  std::ifstream is(filename.c_str(), std::ifstream::in);
 10689	  if (!is.good()) {
 10690	    KALDI_ERR << "Cannot open config file: " << filename;
 10691	  }
 10692	
 10693	  std::string line, key, value;
 10694	  int32 line_number = 0;
 10695	  while (std::getline(is, line)) {
 10696	    line_number++;
 10697	    // trim out the comments
 10698	    size_t pos;
 10699	    if ((pos = line.find_first_of('#')) != std::string::npos) {
 10700	      line.erase(pos);
 10701	    }
 10702	    // skip empty lines
 10703	    Trim(&line);
 10704	    if (line.length() == 0) continue;
 10705	
 10706	    if (line.substr(0, 2) != "--") {
 10707	      KALDI_ERR << "Reading config file " << filename << ": line "
 10708	                << line_number << " does not look like a line "
 10709	                << "from a Kaldi command-line program's config file: should "
 10710	                << "be of the form --x=y.  Note: config files intended to "
 10711	                << "be sourced by shell scripts lack the '--'.";
 10712	    }
 10713	
 10714	    // parse option
 10715	    bool has_equal_sign;
 10716	    SplitLongArg(line, &key, &value, &has_equal_sign);
 10717	    NormalizeArgName(&key);
 10718	    Trim(&value);
 10719	    if (!SetOption(key, value, has_equal_sign)) {
 10720	      PrintUsage(true);
 10721	      KALDI_ERR << "Invalid option " << line << " in config file " << filename;
 10722	    }
 10723	  }
 10724	}
 10725	
 10726	void ParseOptions::SplitLongArg(const std::string &in, std::string *key,
 10727	                                std::string *value, bool *has_equal_sign) {
 10728	  KALDI_ASSERT(in.substr(0, 2) == "--");  // precondition.
 10729	  size_t pos = in.find_first_of('=', 0);
 10730	  if (pos == std::string::npos) {  // we allow --option for bools
 10731	    // defaults to empty.  We handle this differently in different cases.
 10732	    *key = in.substr(2, in.size() - 2);  // 2 because starts with --.
 10733	    *value = "";
 10734	    *has_equal_sign = false;
 10735	  } else if (pos == 2) {  // we also don't allow empty keys: --=value
 10736	    PrintUsage(true);
 10737	    KALDI_ERR << "Invalid option (no key): " << in;
 10738	  } else {                         // normal case: --option=value
 10739	    *key = in.substr(2, pos - 2);  // 2 because starts with --.
 10740	    *value = in.substr(pos + 1);
 10741	    *has_equal_sign = true;
 10742	  }
 10743	}
 10744	
 10745	void ParseOptions::NormalizeArgName(std::string *str) {
 10746	  std::string out;
 10747	  std::string::iterator it;
 10748	
 10749	  for (it = str->begin(); it != str->end(); ++it) {
 10750	    if (*it == '_')
 10751	      out += '-';  // convert _ to -
 10752	    else
 10753	      out += std::tolower(*it);
 10754	  }
 10755	  *str = out;
 10756	
 10757	  KALDI_ASSERT(str->length() > 0);
 10758	}
 10759	
 10760	bool ParseOptions::SetOption(const std::string &key, const std::string &value,
 10761	                             bool has_equal_sign) {
 10762	  if (bool_map_.end() != bool_map_.find(key)) {
 10763	    if (has_equal_sign && value == "")
 10764	      KALDI_ERR << "Invalid option --" << key << "=";
 10765	    *(bool_map_[key]) = ToBool(value);
 10766	  } else if (int_map_.end() != int_map_.find(key)) {
 10767	    *(int_map_[key]) = ToInt(value);
 10768	  } else if (uint_map_.end() != uint_map_.find(key)) {
 10769	    *(uint_map_[key]) = ToUint(value);
 10770	  } else if (float_map_.end() != float_map_.find(key)) {
 10771	    *(float_map_[key]) = ToFloat(value);
 10772	  } else if (double_map_.end() != double_map_.find(key)) {
 10773	    *(double_map_[key]) = ToDouble(value);
 10774	  } else if (string_map_.end() != string_map_.find(key)) {
 10775	    if (!has_equal_sign)
 10776	      KALDI_ERR << "Invalid option --" << key << " (option format is --x=y).";
 10777	    *(string_map_[key]) = value;
 10778	  } else {
 10779	    return false;
 10780	  }
 10781	  return true;
 10782	}
 10783	
 10784	bool ParseOptions::ToBool(std::string str) {
 10785	  std::transform(str.begin(), str.end(), str.begin(), ::tolower);
 10786	
 10787	  // allow "" as a valid option for "true", so that --x is the same as --x=true
 10788	  if ((str.compare("true") == 0) || (str.compare("t") == 0) ||
 10789	      (str.compare("1") == 0) || (str.compare("") == 0)) {
 10790	    return true;
 10791	  }
 10792	  if ((str.compare("false") == 0) || (str.compare("f") == 0) ||
 10793	      (str.compare("0") == 0)) {
 10794	    return false;
 10795	  }
 10796	  // if it is neither true nor false:
 10797	  PrintUsage(true);
 10798	  KALDI_ERR << "Invalid format for boolean argument [expected true or false]: "
 10799	            << str;
 10800	  return false;  // never reached
 10801	}
 10802	
 10803	int32 ParseOptions::ToInt(const std::string &str) {
 10804	  int32 ret;
 10805	  if (!ConvertStringToInteger(str, &ret))
 10806	    KALDI_ERR << "Invalid integer option \"" << str << "\"";
 10807	  return ret;
 10808	}
 10809	
 10810	uint32 ParseOptions::ToUint(const std::string &str) {
 10811	  uint32 ret;
 10812	  if (!ConvertStringToInteger(str, &ret))
 10813	    KALDI_ERR << "Invalid integer option \"" << str << "\"";
 10814	  return ret;
 10815	}
 10816	
 10817	float ParseOptions::ToFloat(const std::string &str) {
 10818	  float ret;
 10819	  if (!ConvertStringToReal(str, &ret))
 10820	    KALDI_ERR << "Invalid floating-point option \"" << str << "\"";
 10821	  return ret;
 10822	}
 10823	
 10824	double ParseOptions::ToDouble(const std::string &str) {
 10825	  double ret;
 10826	  if (!ConvertStringToReal(str, &ret))
 10827	    KALDI_ERR << "Invalid floating-point option \"" << str << "\"";
 10828	  return ret;
 10829	}
 10830	
 10831	// instantiate templates
 10832	template void ParseOptions::RegisterTmpl(const std::string &name, bool *ptr,
 10833	                                         const std::string &doc);
 10834	template void ParseOptions::RegisterTmpl(const std::string &name, int32 *ptr,
 10835	                                         const std::string &doc);
 10836	template void ParseOptions::RegisterTmpl(const std::string &name, uint32 *ptr,
 10837	                                         const std::string &doc);
 10838	template void ParseOptions::RegisterTmpl(const std::string &name, float *ptr,
 10839	                                         const std::string &doc);
 10840	template void ParseOptions::RegisterTmpl(const std::string &name, double *ptr,
 10841	                                         const std::string &doc);
 10842	template void ParseOptions::RegisterTmpl(const std::string &name,
 10843	                                         std::string *ptr,
 10844	                                         const std::string &doc);
 10845	
 10846	template void ParseOptions::RegisterStandard(const std::string &name, bool *ptr,
 10847	                                             const std::string &doc);
 10848	template void ParseOptions::RegisterStandard(const std::string &name,
 10849	                                             int32 *ptr,
 10850	                                             const std::string &doc);
 10851	template void ParseOptions::RegisterStandard(const std::string &name,
 10852	                                             uint32 *ptr,
 10853	                                             const std::string &doc);
 10854	template void ParseOptions::RegisterStandard(const std::string &name,
 10855	                                             float *ptr,
 10856	                                             const std::string &doc);
 10857	template void ParseOptions::RegisterStandard(const std::string &name,
 10858	                                             double *ptr,
 10859	                                             const std::string &doc);
 10860	template void ParseOptions::RegisterStandard(const std::string &name,
 10861	                                             std::string *ptr,
 10862	                                             const std::string &doc);
 10863	
 10864	template void ParseOptions::RegisterCommon(const std::string &name, bool *ptr,
 10865	                                           const std::string &doc,
 10866	                                           bool is_standard);
 10867	template void ParseOptions::RegisterCommon(const std::string &name, int32 *ptr,
 10868	                                           const std::string &doc,
 10869	                                           bool is_standard);
 10870	template void ParseOptions::RegisterCommon(const std::string &name, uint32 *ptr,
 10871	                                           const std::string &doc,
 10872	                                           bool is_standard);
 10873	template void ParseOptions::RegisterCommon(const std::string &name, float *ptr,
 10874	                                           const std::string &doc,
 10875	                                           bool is_standard);
 10876	template void ParseOptions::RegisterCommon(const std::string &name, double *ptr,
 10877	                                           const std::string &doc,
 10878	                                           bool is_standard);
 10879	template void ParseOptions::RegisterCommon(const std::string &name,
 10880	                                           std::string *ptr,
 10881	                                           const std::string &doc,
 10882	                                           bool is_standard);
 10883	
 10884	}  // namespace kaldi
 10885	// util/simple-io-funcs.cc
 10886	
 10887	// Copyright 2009-2011  Microsoft Corporation
 10888	
 10889	// See ../../COPYING for clarification regarding multiple authors
 10890	//
 10891	// Licensed under the Apache License, Version 2.0 (the "License");
 10892	// you may not use this file except in compliance with the License.
 10893	// You may obtain a copy of the License at
 10894	
 10895	//  http://www.apache.org/licenses/LICENSE-2.0
 10896	
 10897	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 10898	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
 10899	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 10900	// MERCHANTABLITY OR NON-INFRINGEMENT.
 10901	// See the Apache 2 License for the specific language governing permissions and
 10902	// limitations under the License.
 10903	#include "util/simple-io-funcs.h"
 10904	#include "util/text-utils.h"
 10905	
 10906	namespace kaldi {
 10907	
 10908	bool WriteIntegerVectorSimple(const std::string &wxfilename,
 10909	                              const std::vector<int32> &list) {
 10910	  kaldi::Output ko;
 10911	  // false, false is: text-mode, no Kaldi header.
 10912	  if (!ko.Open(wxfilename, false, false)) return false;
 10913	  for (size_t i = 0; i < list.size(); i++) ko.Stream() << list[i] << '\n';
 10914	  return ko.Close();
 10915	}
 10916	
 10917	bool ReadIntegerVectorSimple(const std::string &rxfilename,
 10918	                             std::vector<int32> *list) {
 10919	  kaldi::Input ki;
 10920	  if (!ki.OpenTextMode(rxfilename)) return false;
 10921	  std::istream &is = ki.Stream();
 10922	  int32 i;
 10923	  list->clear();
 10924	  while (!(is >> i).fail()) list->push_back(i);
 10925	  is >> std::ws;
 10926	  return is.eof();  // should be eof, or junk at end of file.
 10927	}
 10928	
 10929	bool WriteIntegerVectorVectorSimple(
 10930	    const std::string &wxfilename,
 10931	    const std::vector<std::vector<int32> > &list) {
 10932	  kaldi::Output ko;
 10933	  // false, false is: text-mode, no Kaldi header.
 10934	  if (!ko.Open(wxfilename, false, false)) return false;
 10935	  std::ostream &os = ko.Stream();
 10936	  for (size_t i = 0; i < list.size(); i++) {
 10937	    for (size_t j = 0; j < list[i].size(); j++) {
 10938	      os << list[i][j];
 10939	      if (j + 1 < list[i].size()) os << ' ';
 10940	    }
 10941	    os << '\n';
 10942	  }
 10943	  return ko.Close();
 10944	}
 10945	
 10946	bool ReadIntegerVectorVectorSimple(const std::string &rxfilename,
 10947	                                   std::vector<std::vector<int32> > *list) {
 10948	  kaldi::Input ki;
 10949	  if (!ki.OpenTextMode(rxfilename)) return false;
 10950	  std::istream &is = ki.Stream();
 10951	  list->clear();
 10952	  std::string line;
 10953	  while (std::getline(is, line)) {
 10954	    std::vector<int32> v;
 10955	    if (!SplitStringToIntegers(line, " \t\r", true, &v)) {
 10956	      list->clear();
 10957	      return false;
 10958	    }
 10959	    list->push_back(v);
 10960	  }
 10961	  return is.eof();  // if we're not at EOF, something weird happened.
 10962	}
 10963	
 10964	}  // end namespace kaldi
 10965	// util/text-utils.cc
 10966	
 10967	// Copyright 2009-2011  Saarland University;  Microsoft Corporation
 10968	
 10969	// See ../../COPYING for clarification regarding multiple authors
 10970	//
 10971	// Licensed under the Apache License, Version 2.0 (the "License");
 10972	// you may not use this file except in compliance with the License.
 10973	// You may obtain a copy of the License at
 10974	
 10975	//  http://www.apache.org/licenses/LICENSE-2.0
 10976	
 10977	// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 10978	// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
 10979	// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
 10980	// MERCHANTABLITY OR NON-INFRINGEMENT.
 10981	// See the Apache 2 License for the specific language governing permissions and
 10982	// limitations under the License.
 10983	
 10984	#include "util/text-utils.h"
 10985	
 10986	#include <algorithm>
 10987	#include <limits>
 10988	#include <map>
 10989	#include <utility>
 10990	
 10991	#include "base/kaldi-common.h"
 10992	
 10993	namespace kaldi {
 10994	
 10995	template <class F>
 10996	bool SplitStringToFloats(const std::string &full, const char *delim,
 10997	                         bool omit_empty_strings,  // typically false
 10998	                         std::vector<F> *out) {
 10999	  KALDI_ASSERT(out != NULL);
 11000	  if (*(full.c_str()) == '\0') {
 11001	    out->clear();
 11002	    return true;
 11003	  }
 11004	  std::vector<std::string> split;
 11005	  SplitStringToVector(full, delim, omit_empty_strings, &split);
 11006	  out->resize(split.size());
 11007	  for (size_t i = 0; i < split.size(); i++) {
 11008	    F f = 0;
 11009	    if (!ConvertStringToReal(split[i], &f)) return false;
 11010	    (*out)[i] = f;
 11011	  }
 11012	  return true;
 11013	}
 11014	
 11015	// Instantiate the template above for float and double.
 11016	template bool SplitStringToFloats(const std::string &full, const char *delim,
 11017	                                  bool omit_empty_strings,
 11018	                                  std::vector<float> *out);
 11019	template bool SplitStringToFloats(const std::string &full, const char *delim,
 11020	                                  bool omit_empty_strings,
 11021	                                  std::vector<double> *out);
 11022	
 11023	void SplitStringToVector(const std::string &full, const char *delim,
 11024	                         bool omit_empty_strings,
 11025	                         std::vector<std::string> *out) {
 11026	  size_t start = 0, found = 0, end = full.size();
 11027	  out->clear();
 11028	  while (found != std::string::npos) {
 11029	    found = full.find_first_of(delim, start);
 11030	    // start != end condition is for when the delimiter is at the end
 11031	    if (!omit_empty_strings || (found != start && start != end))
 11032	      out->push_back(full.substr(start, found - start));
 11033	    start = found + 1;
 11034	  }
 11035	}
 11036	
 11037	void JoinVectorToString(const std::vector<std::string> &vec_in,
 11038	                        const char *delim, bool omit_empty_strings,
 11039	                        std::string *str_out) {
 11040	  std::string tmp_str;
 11041	  for (size_t i = 0; i < vec_in.size(); i++) {
 11042	    if (!omit_empty_strings || !vec_in[i].empty()) {
 11043	      tmp_str.append(vec_in[i]);
 11044	      if (i < vec_in.size() - 1)
 11045	        if (!omit_empty_strings || !vec_in[i + 1].empty())
 11046	          tmp_str.append(delim);
 11047	    }
 11048	  }
 11049	  str_out->swap(tmp_str);
 11050	}
 11051	
 11052	void Trim(std::string *str) {
 11053	  const char *white_chars = " \t\n\r\f\v";
 11054	
 11055	  std::string::size_type pos = str->find_last_not_of(white_chars);
 11056	  if (pos != std::string::npos) {
 11057	    str->erase(pos + 1);
 11058	    pos = str->find_first_not_of(white_chars);
 11059	    if (pos != std::string::npos) str->erase(0, pos);
 11060	  } else {
 11061	    str->erase(str->begin(), str->end());
 11062	  }
 11063	}
 11064	
 11065	bool IsToken(const std::string &token) {
 11066	  size_t l = token.length();
 11067	  if (l == 0) return false;
 11068	  for (size_t i = 0; i < l; i++) {
 11069	    unsigned char c = token[i];
 11070	    if ((!isprint(c) || isspace(c)) && (isascii(c) || c == (unsigned char)255))
 11071	      return false;
 11072	    // The "&& (isascii(c) || c == 255)" was added so that we won't reject
 11073	    // non-ASCII characters such as French characters with accents [except for
 11074	    // 255 which is "nbsp", a form of space].
 11075	  }
 11076	  return true;
 11077	}
 11078	
 11079	void SplitStringOnFirstSpace(const std::string &str, std::string *first,
 11080	                             std::string *rest) {
 11081	  const char *white_chars = " \t\n\r\f\v";
 11082	  typedef std::string::size_type I;
 11083	  const I npos = std::string::npos;
 11084	  I first_nonwhite = str.find_first_not_of(white_chars);
 11085	  if (first_nonwhite == npos) {
 11086	    first->clear();
 11087	    rest->clear();
 11088	    return;
 11089	  }
 11090	  // next_white is first whitespace after first nonwhitespace.
 11091	  I next_white = str.find_first_of(white_chars, first_nonwhite);
 11092	
 11093	  if (next_white == npos) {  // no more whitespace...
 11094	    *first = std::string(str, first_nonwhite);
 11095	    rest->clear();
 11096	    return;
 11097	  }
 11098	  I next_nonwhite = str.find_first_not_of(white_chars, next_white);
 11099	  if (next_nonwhite == npos) {
 11100	    *first = std::string(str, first_nonwhite, next_white - first_nonwhite);
 11101	    rest->clear();
 11102	    return;
 11103	  }
 11104	
 11105	  I last_nonwhite = str.find_last_not_of(white_chars);
 11106	  KALDI_ASSERT(last_nonwhite != npos);  // or coding error.
 11107	
 11108	  *first = std::string(str, first_nonwhite, next_white - first_nonwhite);
 11109	  *rest = std::string(str, next_nonwhite, last_nonwhite + 1 - next_nonwhite);
 11110	}
 11111	
 11112	bool IsLine(const std::string &line) {
 11113	  if (line.find('\n') != std::string::npos) return false;
 11114	  if (line.empty()) return true;
 11115	  if (isspace(*(line.begin()))) return false;
 11116	  if (isspace(*(line.rbegin()))) return false;
 11117	  std::string::const_iterator iter = line.begin(), end = line.end();
 11118	  for (; iter != end; iter++)
 11119	    if (!isprint(*iter)) return false;
 11120	  return true;
 11121	}
 11122	
 11123	template <class T>
 11124	class NumberIstream {
 11125	 public:
 11126	  explicit NumberIstream(std::istream &i) : in_(i) {}
 11127	
 11128	  NumberIstream &operator>>(T &x) {
 11129	    if (!in_.good()) return *this;
 11130	    in_ >> x;
 11131	    if (!in_.fail() && RemainderIsOnlySpaces()) return *this;
 11132	    return ParseOnFail(&x);
 11133	  }
 11134	
 11135	 private:
 11136	  std::istream &in_;
 11137	
 11138	  bool RemainderIsOnlySpaces() {
 11139	    if (in_.tellg() != std::istream::pos_type(-1)) {
 11140	      std::string rem;
 11141	      in_ >> rem;
 11142	
 11143	      if (rem.find_first_not_of(' ') != std::string::npos) {
 11144	        // there is not only spaces
 11145	        return false;
 11146	      }
 11147	    }
 11148	
 11149	    in_.clear();
 11150	    return true;
 11151	  }
 11152	
 11153	  NumberIstream &ParseOnFail(T *x) {
 11154	    std::string str;
 11155	    in_.clear();
 11156	    in_.seekg(0);
 11157	    // If the stream is broken even before trying
 11158	    // to read from it or if there are many tokens,
 11159	    // it's pointless to try.
 11160	    if (!(in_ >> str) || !RemainderIsOnlySpaces()) {
 11161	      in_.setstate(std::ios_base::failbit);
 11162	      return *this;
 11163	    }
 11164	
 11165	    std::map<std::string, T> inf_nan_map;
 11166	    // we'll keep just uppercase values.
 11167	    inf_nan_map["INF"] = std::numeric_limits<T>::infinity();
 11168	    inf_nan_map["+INF"] = std::numeric_limits<T>::infinity();
 11169	    inf_nan_map["-INF"] = -std::numeric_limits<T>::infinity();
 11170	    inf_nan_map["INFINITY"] = std::numeric_limits<T>::infinity();
 11171	    inf_nan_map["+INFINITY"] = std::numeric_limits<T>::infinity();
 11172	    inf_nan_map["-INFINITY"] = -std::numeric_limits<T>::infinity();
 11173	    inf_nan_map["NAN"] = std::numeric_limits<T>::quiet_NaN();
 11174	    inf_nan_map["+NAN"] = std::numeric_limits<T>::quiet_NaN();
 11175	    inf_nan_map["-NAN"] = -std::numeric_limits<T>::quiet_NaN();
 11176	    // MSVC
 11177	    inf_nan_map["1.#INF"] = std::numeric_limits<T>::infinity();
 11178	    inf_nan_map["-1.#INF"] = -std::numeric_limits<T>::infinity();
 11179	    inf_nan_map["1.#QNAN"] = std::numeric_limits<T>::quiet_NaN();
 11180	    inf_nan_map["-1.#QNAN"] = -std::numeric_limits<T>::quiet_NaN();
 11181	
 11182	    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
 11183	
 11184	    if (inf_nan_map.find(str) != inf_nan_map.end()) {
 11185	      *x = inf_nan_map[str];
 11186	    } else {
 11187	      in_.setstate(std::ios_base::failbit);
 11188	    }
 11189	
 11190	    return *this;
 11191	  }
 11192	};
 11193	
 11194	template <typename T>
 11195	bool ConvertStringToReal(const std::string &str, T *out) {
 11196	  std::istringstream iss(str);
 11197	
 11198	  NumberIstream<T> i(iss);
 11199	
 11200	  i >> *out;
 11201	
 11202	  if (iss.fail()) {
 11203	    // Number conversion failed.
 11204	    return false;
 11205	  }
 11206	
 11207	  return true;
 11208	}
 11209	
 11210	template bool ConvertStringToReal(const std::string &str, float *out);
 11211	template bool ConvertStringToReal(const std::string &str, double *out);
 11212	
 11213	/*
 11214	  This function is a helper function of StringsApproxEqual.  It should be
 11215	  thought of as a recursive function-- it was designed that way-- but rather
 11216	  than actually recursing (which would cause problems with stack overflow), we
 11217	  just set the args and return to the start.
 11218	
 11219	  The 'decimal_places_tolerance' argument is just passed in from outside,
 11220	  see the documentation for StringsApproxEqual in text-utils.h to see an
 11221	  explanation.  The argument 'places_into_number' provides some information
 11222	  about the strings 'a' and 'b' that precedes the current pointers.
 11223	  For purposes of this comment, let's define the 'decimal' of a number
 11224	  as the part that comes after the decimal point, e.g. in '99.123',
 11225	  '123' would be the decimal.  If 'places_into_number' is -1, it means
 11226	  we're not currently inside some place like that (i.e. it's not the
 11227	  case that we're pointing to the '1' or the '2' or the '3').
 11228	  If it's 0, then we'd be pointing to the first place after the decimal,
 11229	  '1' in this case.  Note if one of the numbers is shorter than the
 11230	  other, like '99.123' versus '99.1234' and 'a' points to the first '3'
 11231	  while 'b' points to the second '4', 'places_into_number' referes to the
 11232	  shorter of the two, i.e. it would be 2 in this example.
 11233	
 11234	
 11235	 */
 11236	bool StringsApproxEqualInternal(const char *a, const char *b,
 11237	                                int32 decimal_places_tolerance,
 11238	                                int32 places_into_number) {
 11239	start:
 11240	  char ca = *a, cb = *b;
 11241	  if (ca == cb) {
 11242	    if (ca == '\0') {
 11243	      return true;
 11244	    } else {
 11245	      if (places_into_number >= 0) {
 11246	        if (isdigit(ca)) {
 11247	          places_into_number++;
 11248	        } else {
 11249	          places_into_number = -1;
 11250	        }
 11251	      } else {
 11252	        if (ca == '.') {
 11253	          places_into_number = 0;
 11254	        }
 11255	      }
 11256	      a++;
 11257	      b++;
 11258	      goto start;
 11259	    }
 11260	  } else {
 11261	    if (places_into_number >= decimal_places_tolerance &&
 11262	        (isdigit(ca) || isdigit(cb))) {
 11263	      // we're potentially willing to accept this difference between the
 11264	      // strings.
 11265	      if (isdigit(ca)) a++;
 11266	      if (isdigit(cb)) b++;
 11267	      // we'll have advanced at least one of the two strings.
 11268	      goto start;
 11269	    } else if (places_into_number >= 0 &&
 11270	               ((ca == '0' && !isdigit(cb)) || (cb == '0' && !isdigit(ca)))) {
 11271	      // this clause is designed to ensure that, for example,
 11272	      // "0.1" would count the same as "0.100001".
 11273	      if (ca == '0')
 11274	        a++;
 11275	      else
 11276	        b++;
 11277	      places_into_number++;
 11278	      goto start;
 11279	    } else {
 11280	      return false;
 11281	    }
 11282	  }
 11283	}
 11284	
 11285	bool StringsApproxEqual(const std::string &a, const std::string &b,
 11286	                        int32 decimal_places_tolerance) {
 11287	  return StringsApproxEqualInternal(a.c_str(), b.c_str(),
 11288	                                    decimal_places_tolerance, -1);
 11289	}
 11290	
 11291	bool ConfigLine::ParseLine(const std::string &line) {
 11292	  data_.clear();
 11293	  whole_line_ = line;
 11294	  if (line.size() == 0) return false;  // Empty line
 11295	  size_t pos = 0, size = line.size();
 11296	  while (isspace(line[pos]) && pos < size) pos++;
 11297	  if (pos == size) return false;  // whitespace-only line
 11298	  size_t first_token_start_pos = pos;
 11299	  // first get first_token_.
 11300	  while (!isspace(line[pos]) && pos < size) {
 11301	    if (line[pos] == '=') {
 11302	      // If the first block of non-whitespace looks like "foo-bar=...",
 11303	      // then we ignore it: there is no initial token, and FirstToken()
 11304	      // is empty.
 11305	      pos = first_token_start_pos;
 11306	      break;
 11307	    }
 11308	    pos++;
 11309	  }
 11310	  first_token_ =
 11311	      std::string(line, first_token_start_pos, pos - first_token_start_pos);
 11312	  // first_token_ is expected to be either empty or something like
 11313	  // "component-node", which actually is a slightly more restrictive set of
 11314	  // strings than IsValidName() checks for this is a convenient way to check it.
 11315	  if (!first_token_.empty() && !IsValidName(first_token_)) return false;
 11316	
 11317	  while (pos < size) {
 11318	    if (isspace(line[pos])) {
 11319	      pos++;
 11320	      continue;
 11321	    }
 11322	
 11323	    // OK, at this point we know that we are pointing at nonspace.
 11324	    size_t next_equals_sign = line.find_first_of("=", pos);
 11325	    if (next_equals_sign == pos || next_equals_sign == std::string::npos) {
 11326	      // we're looking for something like 'key=value'.  If there is no equals
 11327	      // sign, or it's not preceded by something, it's a parsing failure.
 11328	      return false;
 11329	    }
 11330	    std::string key(line, pos, next_equals_sign - pos);
 11331	    if (!IsValidName(key)) return false;
 11332	
 11333	    // handle any quotes.  we support key='blah blah' or key="foo bar".
 11334	    // no escaping is supported.
 11335	    if (line[next_equals_sign + 1] == '\'' ||
 11336	        line[next_equals_sign + 1] == '"') {
 11337	      char my_quote = line[next_equals_sign + 1];
 11338	      size_t next_quote = line.find_first_of(my_quote, next_equals_sign + 2);
 11339	      if (next_quote == std::string::npos) {  // no matching quote was found.
 11340	        KALDI_WARN << "No matching quote for " << my_quote
 11341	                   << " in config line '" << line << "'";
 11342	        return false;
 11343	      } else {
 11344	        std::string value(line, next_equals_sign + 2,
 11345	                          next_quote - next_equals_sign - 2);
 11346	        data_.insert(std::make_pair(key, std::make_pair(value, false)));
 11347	        pos = next_quote + 1;
 11348	        continue;
 11349	      }
 11350	    } else {
 11351	      // we want to be able to parse something like "... input=Offset(a, -1)
 11352	      // foo=bar": in general, config values with spaces in them, even without
 11353	      // quoting.
 11354	
 11355	      size_t next_next_equals_sign =
 11356	                 line.find_first_of("=", next_equals_sign + 1),
 11357	             terminating_space = size;
 11358	
 11359	      if (next_next_equals_sign !=
 11360	          std::string::npos) {  // found a later equals sign.
 11361	        size_t preceding_space =
 11362	            line.find_last_of(" \t", next_next_equals_sign);
 11363	        if (preceding_space != std::string::npos &&
 11364	            preceding_space > next_equals_sign)
 11365	          terminating_space = preceding_space;
 11366	      }
 11367	      while (isspace(line[terminating_space - 1]) && terminating_space > 0)
 11368	        terminating_space--;
 11369	
 11370	      std::string value(line, next_equals_sign + 1,
 11371	                        terminating_space - (next_equals_sign + 1));
 11372	      data_.insert(std::make_pair(key, std::make_pair(value, false)));
 11373	      pos = terminating_space;
 11374	    }
 11375	  }
 11376	  return true;
 11377	}
 11378	
 11379	bool ConfigLine::GetValue(const std::string &key, std::string *value) {
 11380	  KALDI_ASSERT(value != NULL);
 11381	  std::map<std::string, std::pair<std::string, bool> >::iterator it =
 11382	      data_.begin();
 11383	  for (; it != data_.end(); ++it) {
 11384	    if (it->first == key) {
 11385	      *value = (it->second).first;
 11386	      (it->second).second = true;
 11387	      return true;
 11388	    }
 11389	  }
 11390	  return false;
 11391	}
 11392	
 11393	bool ConfigLine::GetValue(const std::string &key, BaseFloat *value) {
 11394	  KALDI_ASSERT(value != NULL);
 11395	  std::map<std::string, std::pair<std::string, bool> >::iterator it =
 11396	      data_.begin();
 11397	  for (; it != data_.end(); ++it) {
 11398	    if (it->first == key) {
 11399	      if (!ConvertStringToReal((it->second).first, value)) return false;
 11400	      (it->second).second = true;
 11401	      return true;
 11402	    }
 11403	  }
 11404	  return false;
 11405	}
 11406	
 11407	bool ConfigLine::GetValue(const std::string &key, int32 *value) {
 11408	  KALDI_ASSERT(value != NULL);
 11409	  std::map<std::string, std::pair<std::string, bool> >::iterator it =
 11410	      data_.begin();
 11411	  for (; it != data_.end(); ++it) {
 11412	    if (it->first == key) {
 11413	      if (!ConvertStringToInteger((it->second).first, value)) return false;
 11414	      (it->second).second = true;
 11415	      return true;
 11416	    }
 11417	  }
 11418	  return false;
 11419	}
 11420	
 11421	bool ConfigLine::GetValue(const std::string &key, std::vector<int32> *value) {
 11422	  KALDI_ASSERT(value != NULL);
 11423	  value->clear();
 11424	  std::map<std::string, std::pair<std::string, bool> >::iterator it =
 11425	      data_.begin();
 11426	  for (; it != data_.end(); ++it) {
 11427	    if (it->first == key) {
 11428	      if (!SplitStringToIntegers((it->second).first, ":,", true, value)) {
 11429	        // KALDI_WARN << "Bad option " << (it->second).first;
 11430	        return false;
 11431	      }
 11432	      (it->second).second = true;
 11433	      return true;
 11434	    }
 11435	  }
 11436	  return false;
 11437	}
 11438	
 11439	bool ConfigLine::GetValue(const std::string &key, bool *value) {
 11440	  KALDI_ASSERT(value != NULL);
 11441	  std::map<std::string, std::pair<std::string, bool> >::iterator it =
 11442	      data_.begin();
 11443	  for (; it != data_.end(); ++it) {
 11444	    if (it->first == key) {
 11445	      if ((it->second).first.size() == 0) return false;
 11446	      switch (((it->second).first)[0]) {
 11447	        case 'F':
 11448	        case 'f':
 11449	          *value = false;
 11450	          break;
 11451	        case 'T':
 11452	        case 't':
 11453	          *value = true;
 11454	          break;
 11455	        default:
 11456	          return false;
 11457	      }
 11458	      (it->second).second = true;
 11459	      return true;
 11460	    }
 11461	  }
 11462	  return false;
 11463	}
 11464	
 11465	bool ConfigLine::HasUnusedValues() const {
 11466	  std::map<std::string, std::pair<std::string, bool> >::const_iterator it =
 11467	      data_.begin();
 11468	  for (; it != data_.end(); ++it) {
 11469	    if (!(it->second).second) return true;
 11470	  }
 11471	  return false;
 11472	}
 11473	
 11474	std::string ConfigLine::UnusedValues() const {
 11475	  std::string unused_str;
 11476	  std::map<std::string, std::pair<std::string, bool> >::const_iterator it =
 11477	      data_.begin();
 11478	  for (; it != data_.end(); ++it) {
 11479	    if (!(it->second).second) {
 11480	      if (unused_str == "")
 11481	        unused_str = it->first + "=" + (it->second).first;
 11482	      else
 11483	        unused_str += " " + it->first + "=" + (it->second).first;
 11484	    }
 11485	  }
 11486	  return unused_str;
 11487	}
 11488	
 11489	// This is like ExpectToken but for two tokens, and it
 11490	// will either accept token1 and then token2, or just token2.
 11491	// This is useful in Read functions where the first token
 11492	// may already have been consumed.
 11493	// void ExpectOneOrTwoTokens(std::istream &is, bool binary,
 11494	//                           const std::string &token1,
 11495	//                           const std::string &token2) {
 11496	//   KALDI_ASSERT(token1 != token2);
 11497	//   std::string temp;
 11498	//   ReadToken(is, binary, &temp);
 11499	//   if (temp == token1) {
 11500	//     ExpectToken(is, binary, token2);
 11501	//   } else {
 11502	//     if (temp != token2) {
 11503	//       KALDI_ERR << "Expecting token " << token1 << " or " << token2
 11504	//                 << " but got " << temp;
 11505	//     }
 11506	//   }
 11507	// }
 11508	
 11509	bool IsValidName(const std::string &name) {
 11510	  if (name.size() == 0) return false;
 11511	  for (size_t i = 0; i < name.size(); i++) {
 11512	    if (i == 0 && !isalpha(name[i]) && name[i] != '_') return false;
 11513	    if (!isalnum(name[i]) && name[i] != '_' && name[i] != '-' && name[i] != '.')
 11514	      return false;
 11515	  }
 11516	  return true;
 11517	}
 11518	
 11519	void ReadConfigLines(std::istream &is, std::vector<std::string> *lines) {
 11520	  KALDI_ASSERT(lines != NULL);
 11521	  std::string line;
 11522	  while (std::getline(is, line)) {
 11523	    if (line.size() == 0) continue;
 11524	    size_t start = line.find_first_not_of(" \t");
 11525	    size_t end = line.find_first_of('#');
 11526	    if (start == std::string::npos || start == end) continue;
 11527	    end = line.find_last_not_of(" \t", end - 1);
 11528	    KALDI_ASSERT(end >= start);
 11529	    lines->push_back(line.substr(start, end - start + 1));
 11530	  }
 11531	}
 11532	
 11533	void ParseConfigLines(const std::vector<std::string> &lines,
 11534	                      std::vector<ConfigLine> *config_lines) {
 11535	  config_lines->resize(lines.size());
 11536	  for (size_t i = 0; i < lines.size(); i++) {
 11537	    bool ret = (*config_lines)[i].ParseLine(lines[i]);
 11538	    if (!ret) {
 11539	      KALDI_ERR << "Error parsing config line: " << lines[i];
 11540	    }
 11541	  }
 11542	}
 11543	
 11544	}  // end namespace kaldi
 11545	// Licensed under the Apache License, Version 2.0 (the "License");
 11546	// you may not use this file except in compliance with the License.
 11547	// You may obtain a copy of the License at
 11548	//
 11549	//      http://www.apache.org/licenses/LICENSE-2.0
 11550	//
 11551	// Unless required by applicable law or agreed to in writing, software
 11552	// distributed under the License is distributed on an "AS IS" BASIS,
 11553	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 11554	// See the License for the specific language governing permissions and
 11555	// limitations under the License.
 11556	//
 11557	// Google-style flag handling definitions.
 11558	
 11559	#include <cstring>
 11560	
 11561	#if _MSC_VER
 11562	#include <io.h>
 11563	#include <fcntl.h>
 11564	#endif
 11565	
 11566	#include <fst/compat.h>
 11567	#include <fst/flags.h>
 11568	
 11569	static const char *private_tmpdir = getenv("TMPDIR");
 11570	
 11571	// DEFINE_int32(v, 0, "verbosity level");
 11572	// DEFINE_bool(help, false, "show usage information");
 11573	// DEFINE_bool(helpshort, false, "show brief usage information");
 11574	#ifndef _MSC_VER
 11575	DEFINE_string(tmpdir, private_tmpdir ? private_tmpdir : "/tmp",
 11576	              "temporary directory");
 11577	#else
 11578	DEFINE_string(tmpdir, private_tmpdir ? private_tmpdir : getenv("TEMP"),
 11579	              "temporary directory");
 11580	#endif // !_MSC_VER
 11581	
 11582	using namespace std;
 11583	
 11584	static string flag_usage;
 11585	static string prog_src;
 11586	
 11587	// Sets prog_src to src.
 11588	static void SetProgSrc(const char *src) {
 11589	  prog_src = src;
 11590	#if _MSC_VER
 11591	  // This common code is invoked by all FST binaries, and only by them. Switch
 11592	  // stdin and stdout into "binary" mode, so that 0x0A won't be translated into
 11593	  // a 0x0D 0x0A byte pair in a pipe or a shell redirect. Other streams are
 11594	  // already using ios::binary where binary files are read or written.
 11595	  // Kudos to @daanzu for the suggested fix.
 11596	  //    https://github.com/kkm000/openfst/issues/20
 11597	  //    https://github.com/kkm000/openfst/pull/23
 11598	  //    https://github.com/kkm000/openfst/pull/32
 11599	  _setmode(_fileno(stdin), O_BINARY);
 11600	  _setmode(_fileno(stdout), O_BINARY);
 11601	#endif
 11602	  // Remove "-main" in src filename. Flags are defined in fstx.cc but SetFlags()
 11603	  // is called in fstx-main.cc, which results in a filename mismatch in
 11604	  // ShowUsageRestrict() below.
 11605	  static constexpr char kMainSuffix[] = "-main.cc";
 11606	  const int prefix_length = prog_src.size() - strlen(kMainSuffix);
 11607	  if (prefix_length > 0 && prog_src.substr(prefix_length) == kMainSuffix) {
 11608	    prog_src.erase(prefix_length, strlen("-main"));
 11609	  }
 11610	}
 11611	
 11612	void SetFlags(const char *usage, int *argc, char ***argv,
 11613	              bool remove_flags, const char *src) {
 11614	  flag_usage = usage;
 11615	  SetProgSrc(src);
 11616	
 11617	  int index = 1;
 11618	  for (; index < *argc; ++index) {
 11619	    string argval = (*argv)[index];
 11620	    if (argval[0] != '-' || argval == "-") break;
 11621	    while (argval[0] == '-') argval = argval.substr(1);  // Removes initial '-'.
 11622	    string arg = argval;
 11623	    string val = "";
 11624	    // Splits argval (arg=val) into arg and val.
 11625	    auto pos = argval.find("=");
 11626	    if (pos != string::npos) {
 11627	      arg = argval.substr(0, pos);
 11628	      val = argval.substr(pos + 1);
 11629	    }
 11630	    auto bool_register = FlagRegister<bool>::GetRegister();
 11631	    if (bool_register->SetFlag(arg, val))
 11632	      continue;
 11633	    auto string_register = FlagRegister<string>::GetRegister();
 11634	    if (string_register->SetFlag(arg, val))
 11635	      continue;
 11636	    auto int32_register = FlagRegister<int32>::GetRegister();
 11637	    if (int32_register->SetFlag(arg, val))
 11638	      continue;
 11639	    auto int64_register = FlagRegister<int64>::GetRegister();
 11640	    if (int64_register->SetFlag(arg, val))
 11641	      continue;
 11642	    auto double_register = FlagRegister<double>::GetRegister();
 11643	    if (double_register->SetFlag(arg, val))
 11644	      continue;
 11645	    LOG(FATAL) << "SetFlags: Bad option: " << (*argv)[index];
 11646	  }
 11647	  if (remove_flags) {
 11648	    for (auto i = 0; i < *argc - index; ++i) {
 11649	      (*argv)[i + 1] = (*argv)[i + index];
 11650	    }
 11651	    *argc -= index - 1;
 11652	  }
 11653	  // if (FLAGS_help) {
 11654	  //   ShowUsage(true);
 11655	  //   exit(1);
 11656	  // }
 11657	  // if (FLAGS_helpshort) {
 11658	  //   ShowUsage(false);
 11659	  //   exit(1);
 11660	  // }
 11661	}
 11662	
 11663	// If flag is defined in file 'src' and 'in_src' true or is not
 11664	// defined in file 'src' and 'in_src' is false, then print usage.
 11665	static void
 11666	ShowUsageRestrict(const std::set<pair<string, string>> &usage_set,
 11667	                  const string &src, bool in_src, bool show_file) {
 11668	  string old_file;
 11669	  bool file_out = false;
 11670	  bool usage_out = false;
 11671	  for (const auto &pair : usage_set) {
 11672	    const auto &file = pair.first;
 11673	    const auto &usage = pair.second;
 11674	    bool match = file == src;
 11675	    if ((match && !in_src) || (!match && in_src)) continue;
 11676	    if (file != old_file) {
 11677	      if (show_file) {
 11678	        if (file_out) cout << "\n";
 11679	        cout << "Flags from: " << file << "\n";
 11680	        file_out = true;
 11681	      }
 11682	      old_file = file;
 11683	    }
 11684	    cout << usage << "\n";
 11685	    usage_out = true;
 11686	  }
 11687	  if (usage_out) cout << "\n";
 11688	}
 11689	
 11690	void ShowUsage(bool long_usage) {
 11691	  std::set<pair<string, string>> usage_set;
 11692	  cout << flag_usage << "\n";
 11693	  auto bool_register = FlagRegister<bool>::GetRegister();
 11694	  bool_register->GetUsage(&usage_set);
 11695	  auto string_register = FlagRegister<string>::GetRegister();
 11696	  string_register->GetUsage(&usage_set);
 11697	  auto int32_register = FlagRegister<int32>::GetRegister();
 11698	  int32_register->GetUsage(&usage_set);
 11699	  auto int64_register = FlagRegister<int64>::GetRegister();
 11700	  int64_register->GetUsage(&usage_set);
 11701	  auto double_register = FlagRegister<double>::GetRegister();
 11702	  double_register->GetUsage(&usage_set);
 11703	  if (!prog_src.empty()) {
 11704	    cout << "PROGRAM FLAGS:\n\n";
 11705	    ShowUsageRestrict(usage_set, prog_src, true, false);
 11706	  }
 11707	  if (!long_usage) return;
 11708	  if (!prog_src.empty()) cout << "LIBRARY FLAGS:\n\n";
 11709	  ShowUsageRestrict(usage_set, prog_src, false, true);
 11710	}
 11711	// Copyright (c) 2021 Xingchen Song sxc19@mails.tsinghua.edu.cn
 11712	//
 11713	// Licensed under the Apache License, Version 2.0 (the "License");
 11714	// you may not use this file except in compliance with the License.
 11715	// You may obtain a copy of the License at
 11716	//
 11717	// http://www.apache.org/licenses/LICENSE-2.0
 11718	//
 11719	// Unless required by applicable law or agreed to in writing, software
 11720	// distributed under the License is distributed on an "AS IS" BASIS,
 11721	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 11722	// See the License for the specific language governing permissions and
 11723	// limitations under the License
 11724	
 11725	#include "post_processor/post_processor.h"
 11726	
 11727	#include <vector>
 11728	#include <sstream>
 11729	
 11730	#include "utils/string.h"
 11731	
 11732	namespace wenet {
 11733	
 11734	std::string PostProcessor::ProcessSpace(const std::string& str) {
 11735	  std::string result = str;
 11736	  // 1. remove ' ' if needed
 11737	  // only spaces between mandarin words need to be removed, please note that
 11738	  // if str contains '_', we assume that the decoding type must be
 11739	  // `CtcPrefixBeamSearch` and this branch will do nothing since str must be
 11740	  // obtained via "".join() (in function `TorchAsrDecoder::UpdateResult()`)
 11741	  if (opts_.language_type == kMandarinEnglish && !str.empty()) {
 11742	    result.clear();
 11743	    // split str by ' '
 11744	    std::vector<std::string> words;
 11745	    std::stringstream ss(str);
 11746	    std::string tmp;
 11747	    while (ss >> tmp) {
 11748	      words.push_back(tmp);
 11749	    }
 11750	    // check english word
 11751	    bool is_englishword_prev = false;
 11752	    bool is_englishword_now = false;
 11753	    for (std::string& w : words) {
 11754	      is_englishword_now = CheckEnglishWord(w);
 11755	      if (is_englishword_prev && is_englishword_now) {
 11756	        result += (' ' + w);
 11757	      } else {
 11758	        result += (w);
 11759	      }
 11760	      is_englishword_prev = is_englishword_now;
 11761	    }
 11762	  }
 11763	  // 2. replace '_' with ' '
 11764	  // this should be done for all cases (both kMandarinEnglish and kIndoEuropean)
 11765	  result = ProcessBlank(result, opts_.lowercase);
 11766	  return result;
 11767	}
 11768	
 11769	std::string PostProcessor::Process(const std::string& str, bool finish) {
 11770	  std::string result;
 11771	  result = ProcessSpace(str);
 11772	  // TODO(xcsong): do itn/punctuation if finish == true
 11773	  return result;
 11774	}
 11775	
 11776	}  // namespace com.demo.wenet
 11777	// Copyright (c) 2021 Xingchen Song sxc19@mails.tsinghua.edu.cn
 11778	//
 11779	// Licensed under the Apache License, Version 2.0 (the "License");
 11780	// you may not use this file except in compliance with the License.
 11781	// You may obtain a copy of the License at
 11782	//
 11783	// http://www.apache.org/licenses/LICENSE-2.0
 11784	//
 11785	// Unless required by applicable law or agreed to in writing, software
 11786	// distributed under the License is distributed on an "AS IS" BASIS,
 11787	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 11788	// See the License for the specific language governing permissions and
 11789	// limitations under the License
 11790	
 11791	#include "post_processor/post_processor.h"
 11792	
 11793	#include <string>
 11794	#include <vector>
 11795	
 11796	#include "gmock/gmock.h"
 11797	#include "gtest/gtest.h"
 11798	
 11799	#include "utils/utils.h"
 11800	
 11801	TEST(PostProcessorTest, ProcessSpacekMandarinEnglishTest) {
 11802	  wenet::PostProcessOptions opts_lowercase;
 11803	  wenet::PostProcessor post_processor_lowercase(opts_lowercase);
 11804	
 11805	  wenet::PostProcessOptions opts_uppercase;
 11806	  opts_uppercase.lowercase = false;
 11807	  wenet::PostProcessor post_processor_uppercase(opts_uppercase);
 11808	
 11809	  std::vector<std::string> input = {
 11810	    // modeling unit: mandarin character
 11811	    // decode type: CtcPrefixBeamSearch, "".join()
 11812	    "震东好帅",
 11813	    // modeling unit: mandarin word
 11814	    // decode type: CtcWfstBeamSearch, " ".join()
 11815	    " 吴迪 也 好帅",
 11816	    // modeling unit: english wordpiece
 11817	    // decode type: CtcPrefixBeamSearch, "".join()
 11818	    "▁binbin▁is▁also▁handsome",
 11819	    // modeling unit: english word
 11820	    // decode type: CtcWfstBeamSearch, " ".join()
 11821	    " life is short i use com.demo.wenet",
 11822	    // modeling unit: mandarin character + english wordpiece
 11823	    // decode type: CtcPrefixBeamSearch, "".join()
 11824	    "超哥▁is▁the▁most▁handsome",
 11825	    // modeling unit: mandarin word + english word
 11826	    // decode type: CtcWfstBeamSearch, " ".join()
 11827	    " 人生 苦短 i use com.demo.wenet",
 11828	  };
 11829	
 11830	  std::vector<std::string> result_lowercase = {
 11831	    "震东好帅",
 11832	    "吴迪也好帅",
 11833	    "binbin is also handsome",
 11834	    "life is short i use com.demo.wenet",
 11835	    "超哥 is the most handsome",
 11836	    "人生苦短i use com.demo.wenet",
 11837	  };
 11838	
 11839	  std::vector<std::string> result_uppercase = {
 11840	    "震东好帅",
 11841	    "吴迪也好帅",
 11842	    "BINBIN IS ALSO HANDSOME",
 11843	    "LIFE IS SHORT I USE WENET",
 11844	    "超哥 IS THE MOST HANDSOME",
 11845	    "人生苦短I USE WENET",
 11846	  };
 11847	
 11848	  for (size_t i = 0; i < input.size(); ++i) {
 11849	    EXPECT_EQ(post_processor_lowercase.ProcessSpace(input[i]),
 11850	              result_lowercase[i]);
 11851	    EXPECT_EQ(post_processor_uppercase.ProcessSpace(input[i]),
 11852	              result_uppercase[i]);
 11853	  }
 11854	}
 11855	
 11856	TEST(PostProcessorTest, ProcessSpacekIndoEuropeanTest) {
 11857	  wenet::PostProcessOptions opts_lowercase;
 11858	  opts_lowercase.language_type = wenet::kIndoEuropean;
 11859	  wenet::PostProcessor post_processor_lowercase(opts_lowercase);
 11860	
 11861	  wenet::PostProcessOptions opts_uppercase;
 11862	  opts_uppercase.language_type = wenet::kIndoEuropean;
 11863	  opts_uppercase.lowercase = false;
 11864	  wenet::PostProcessor post_processor_uppercase(opts_uppercase);
 11865	
 11866	  std::vector<std::string> input = {
 11867	    // modeling unit: wordpiece
 11868	    // decode type: CtcPrefixBeamSearch, "".join()
 11869	    "▁zhendong▁ist▁so▁schön",
 11870	    // modeling unit: word
 11871	    // decode type: CtcWfstBeamSearch, " ".join()
 11872	    " zhendong ist so schön"
 11873	  };
 11874	
 11875	  std::vector<std::string> result_lowercase = {
 11876	    "zhendong ist so schön",
 11877	    "zhendong ist so schön"
 11878	  };
 11879	
 11880	  std::vector<std::string> result_uppercase = {
 11881	    "ZHENDONG IST SO SCHÖN",
 11882	    "ZHENDONG IST SO SCHÖN"
 11883	  };
 11884	
 11885	  for (size_t i = 0; i < input.size(); ++i) {
 11886	    EXPECT_EQ(post_processor_lowercase.ProcessSpace(input[i]),
 11887	              result_lowercase[i]);
 11888	    EXPECT_EQ(post_processor_uppercase.ProcessSpace(input[i]),
 11889	              result_uppercase[i]);
 11890	  }
 11891	}
 11892	// Copyright (c) 2021 Mobvoi Inc (Binbin Zhang)
 11893	//
 11894	// Licensed under the Apache License, Version 2.0 (the "License");
 11895	// you may not use this file except in compliance with the License.
 11896	// You may obtain a copy of the License at
 11897	//
 11898	//   http://www.apache.org/licenses/LICENSE-2.0
 11899	//
 11900	// Unless required by applicable law or agreed to in writing, software
 11901	// distributed under the License is distributed on an "AS IS" BASIS,
 11902	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 11903	// See the License for the specific language governing permissions and
 11904	// limitations under the License.
 11905	
 11906	#include "utils/string.h"
 11907	
 11908	#include <sstream>
 11909	#include <string>
 11910	#include <vector>
 11911	
 11912	#include "utils/log.h"
 11913	#include "utils/utils.h"
 11914	
 11915	namespace wenet {
 11916	
 11917	void SplitString(const std::string& str, std::vector<std::string>* strs) {
 11918	  SplitStringToVector(Trim(str), " \t", true, strs);
 11919	}
 11920	
 11921	void SplitStringToVector(const std::string& full, const char* delim,
 11922	                         bool omit_empty_strings,
 11923	                         std::vector<std::string>* out) {
 11924	  size_t start = 0, found = 0, end = full.size();
 11925	  out->clear();
 11926	  while (found != std::string::npos) {
 11927	    found = full.find_first_of(delim, start);
 11928	    // start != end condition is for when the delimiter is at the end
 11929	    if (!omit_empty_strings || (found != start && start != end))
 11930	      out->push_back(full.substr(start, found - start));
 11931	    start = found + 1;
 11932	  }
 11933	}
 11934	
 11935	void SplitUTF8StringToChars(const std::string& str,
 11936	                            std::vector<std::string>* chars) {
 11937	  chars->clear();
 11938	  int bytes = 1;
 11939	  for (size_t i = 0; i < str.length(); i += bytes) {
 11940	    assert((str[i] & 0xF8) <= 0xF0);
 11941	    if ((str[i] & 0x80) == 0x00) {
 11942	      // The first 128 characters (US-ASCII) in UTF-8 format only need one byte.
 11943	      bytes = 1;
 11944	    } else if ((str[i] & 0xE0) == 0xC0) {
 11945	      // The next 1,920 characters need two bytes to encode,
 11946	      // which covers the remainder of almost all Latin-script alphabets.
 11947	      bytes = 2;
 11948	    } else if ((str[i] & 0xF0) == 0xE0) {
 11949	      // Three bytes are needed for characters in the rest of
 11950	      // the Basic Multilingual Plane, which contains virtually all characters
 11951	      // in common use, including most Chinese, Japanese and Korean characters.
 11952	      bytes = 3;
 11953	    } else if ((str[i] & 0xF8) == 0xF0) {
 11954	      // Four bytes are needed for characters in the other planes of Unicode,
 11955	      // which include less common CJK characters, various historic scripts,
 11956	      // mathematical symbols, and emoji (pictographic symbols).
 11957	      bytes = 4;
 11958	    }
 11959	    chars->push_back(str.substr(i, bytes));
 11960	  }
 11961	}
 11962	
 11963	int UTF8StringLength(const std::string& str) {
 11964	  int len = 0;
 11965	  int bytes = 1;
 11966	  for (size_t i = 0; i < str.length(); i += bytes) {
 11967	    if ((str[i] & 0x80) == 0x00) {
 11968	      bytes = 1;
 11969	    } else if ((str[i] & 0xE0) == 0xC0) {
 11970	      bytes = 2;
 11971	    } else if ((str[i] & 0xF0) == 0xE0) {
 11972	      bytes = 3;
 11973	    } else if ((str[i] & 0xF8) == 0xF0) {
 11974	      bytes = 4;
 11975	    }
 11976	    ++len;
 11977	  }
 11978	  return len;
 11979	}
 11980	
 11981	bool CheckEnglishChar(const std::string& ch) {
 11982	  // all english characters should be encoded in one byte
 11983	  if (ch.size() != 1) return false;
 11984	  // english words may contain apostrophe, i.e., "He's"
 11985	  return isalpha(ch[0]) || ch[0] == '\'';
 11986	}
 11987	
 11988	bool CheckEnglishWord(const std::string& word) {
 11989	  std::vector<std::string> chars;
 11990	  SplitUTF8StringToChars(word, &chars);
 11991	  for (size_t k = 0; k < chars.size(); k++) {
 11992	    if (!CheckEnglishChar(chars[k])) {
 11993	      return false;
 11994	    }
 11995	  }
 11996	  return true;
 11997	}
 11998	
 11999	std::string JoinString(const std::string& c,
 12000	                       const std::vector<std::string>& strs) {
 12001	  std::string result;
 12002	  if (strs.size() > 0) {
 12003	    for (int i = 0; i < strs.size() - 1; i++) {
 12004	      result += (strs[i] + c);
 12005	    }
 12006	    result += strs.back();
 12007	  }
 12008	  return result;
 12009	}
 12010	
 12011	bool SplitUTF8StringToWords(
 12012	    const std::string& str,
 12013	    const std::shared_ptr<fst::SymbolTable>& symbol_table,
 12014	    std::vector<std::string>* words) {
 12015	  std::vector<std::string> chars;
 12016	  SplitUTF8StringToChars(Trim(str), &chars);
 12017	
 12018	  bool no_oov = true;
 12019	  for (size_t start = 0; start < chars.size();) {
 12020	    for (size_t end = chars.size(); end > start; --end) {
 12021	      std::string word;
 12022	      for (size_t i = start; i < end; i++) {
 12023	        word += chars[i];
 12024	      }
 12025	      if (symbol_table->Find(word) != -1) {
 12026	        words->emplace_back(word);
 12027	        start = end;
 12028	        continue;
 12029	      }
 12030	      if (end == start + 1) {
 12031	        ++start;
 12032	        no_oov = false;
 12033	        LOG(WARNING) << word << " is oov.";
 12034	      }
 12035	    }
 12036	  }
 12037	  return no_oov;
 12038	}
 12039	
 12040	std::string ProcessBlank(const std::string& str, bool lowercase) {
 12041	  std::string result;
 12042	  if (!str.empty()) {
 12043	    std::vector<std::string> chars;
 12044	    SplitUTF8StringToChars(Trim(str), &chars);
 12045	
 12046	    for (std::string& ch : chars) {
 12047	      if (ch != kSpaceSymbol) {
 12048	        result.append(ch);
 12049	      } else {
 12050	        // Ignore consecutive space or located in head
 12051	        if (!result.empty() && result.back() != ' ') {
 12052	          result.push_back(' ');
 12053	        }
 12054	      }
 12055	    }
 12056	    // Ignore tailing space
 12057	    if (!result.empty() && result.back() == ' ') {
 12058	      result.pop_back();
 12059	    }
 12060	    // NOTE: convert string to wstring
 12061	    //       see issue 745: https://github.com/wenet-e2e/wenet/issues/745
 12062	    std::locale loc("");
 12063	    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> converter;
 12064	    std::wstring wsresult = converter.from_bytes(result);
 12065	    for (auto &c : wsresult) {
 12066	      c = lowercase ? tolower(c, loc) : toupper(c, loc);
 12067	    }
 12068	    result = converter.to_bytes(wsresult);
 12069	  }
 12070	  return result;
 12071	}
 12072	
 12073	std::string Ltrim(const std::string& str) {
 12074	  size_t start = str.find_first_not_of(WHITESPACE);
 12075	  return (start == std::string::npos) ? "" : str.substr(start);
 12076	}
 12077	
 12078	std::string Rtrim(const std::string& str) {
 12079	  size_t end = str.find_last_not_of(WHITESPACE);
 12080	  return (end == std::string::npos) ? "" : str.substr(0, end + 1);
 12081	}
 12082	
 12083	std::string Trim(const std::string& str) { return Rtrim(Ltrim(str)); }
 12084	
 12085	}  // namespace com.demo.wenet
 12086	// Copyright (c) 2021 Mobvoi Inc (Zhendong Peng)
 12087	//
 12088	// Licensed under the Apache License, Version 2.0 (the "License");
 12089	// you may not use this file except in compliance with the License.
 12090	// You may obtain a copy of the License at
 12091	//
 12092	//   http://www.apache.org/licenses/LICENSE-2.0
 12093	//
 12094	// Unless required by applicable law or agreed to in writing, software
 12095	// distributed under the License is distributed on an "AS IS" BASIS,
 12096	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 12097	// See the License for the specific language governing permissions and
 12098	// limitations under the License.
 12099	
 12100	#include "utils/utils.h"
 12101	
 12102	#include <algorithm>
 12103	#include <cmath>
 12104	
 12105	#include "utils/log.h"
 12106	
 12107	namespace wenet {
 12108	
 12109	float LogAdd(float x, float y) {
 12110	  static float num_min = -std::numeric_limits<float>::max();
 12111	  if (x <= num_min) return y;
 12112	  if (y <= num_min) return x;
 12113	  float xmax = std::max(x, y);
 12114	  return std::log(std::exp(x - xmax) + std::exp(y - xmax)) + xmax;
 12115	}
 12116	
 12117	}  // namespace com.demo.wenet
 12118	// Copyright (c) 2020 Mobvoi Inc (Binbin Zhang)
 12119	//
 12120	// Licensed under the Apache License, Version 2.0 (the "License");
 12121	// you may not use this file except in compliance with the License.
 12122	// You may obtain a copy of the License at
 12123	//
 12124	//   http://www.apache.org/licenses/LICENSE-2.0
 12125	//
 12126	// Unless required by applicable law or agreed to in writing, software
 12127	// distributed under the License is distributed on an "AS IS" BASIS,
 12128	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 12129	// See the License for the specific language governing permissions and
 12130	// limitations under the License.
 12131	
 12132	#include "websocket/websocket_client.h"
 12133	
 12134	#include "boost/json/src.hpp"
 12135	
 12136	#include "utils/log.h"
 12137	
 12138	namespace wenet {
 12139	
 12140	namespace beast = boost::beast;          // from <boost/beast.hpp>
 12141	namespace http = beast::http;            // from <boost/beast/http.hpp>
 12142	namespace websocket = beast::websocket;  // from <boost/beast/websocket.hpp>
 12143	namespace asio = boost::asio;            // from <boost/asio.hpp>
 12144	using tcp = boost::asio::ip::tcp;        // from <boost/asio/ip/tcp.hpp>
 12145	namespace json = boost::json;
 12146	
 12147	WebSocketClient::WebSocketClient(const std::string& host, int port)
 12148	    : host_(host), port_(port) {
 12149	  Connect();
 12150	  t_.reset(new std::thread(&WebSocketClient::ReadLoopFunc, this));
 12151	}
 12152	
 12153	void WebSocketClient::Connect() {
 12154	  tcp::resolver resolver{ioc_};
 12155	  // Look up the domain name
 12156	  auto const results = resolver.resolve(host_, std::to_string(port_));
 12157	  // Make the connection on the IP address we get from a lookup
 12158	  auto ep = asio::connect(ws_.next_layer(), results);
 12159	  // Update the host_ string. This will provide the value of the
 12160	  // Host HTTP header during the WebSocket handshake.
 12161	  // See https://tools.ietf.org/html/rfc7230#section-5.4
 12162	  std::string host = host_ + ":" + std::to_string(ep.port());
 12163	  // Perform the websocket handshake
 12164	  ws_.handshake(host, "/");
 12165	}
 12166	
 12167	void WebSocketClient::SendTextData(const std::string& data) {
 12168	  ws_.text(true);
 12169	  ws_.write(asio::buffer(data));
 12170	}
 12171	
 12172	void WebSocketClient::SendBinaryData(const void* data, size_t size) {
 12173	  ws_.binary(true);
 12174	  ws_.write(asio::buffer(data, size));
 12175	}
 12176	
 12177	void WebSocketClient::Close() { ws_.close(websocket::close_code::normal); }
 12178	
 12179	void WebSocketClient::ReadLoopFunc() {
 12180	  try {
 12181	    while (true) {
 12182	      beast::flat_buffer buffer;
 12183	      ws_.read(buffer);
 12184	      std::string message = beast::buffers_to_string(buffer.data());
 12185	//      LOG(INFO) << message;
 12186	      CHECK(ws_.got_text());
 12187	      json::object obj = json::parse(message).as_object();
 12188	      if (obj["status"] != "ok") {
 12189	        break;
 12190	      }
 12191	      if (obj["type"] == "speech_end") {
 12192	        done_ = true;
 12193	        break;
 12194	      }
 12195	    }
 12196	  } catch (beast::system_error const& se) {
 12197	    // This indicates that the session was closed
 12198	    if (se.code() != websocket::error::closed) {
 12199	      LOG(ERROR) << se.code().message();
 12200	    }
 12201	  } catch (std::exception const& e) {
 12202	    LOG(ERROR) << e.what();
 12203	  }
 12204	}
 12205	
 12206	void WebSocketClient::Join() { t_->join(); }
 12207	
 12208	void WebSocketClient::SendStartSignal() {
 12209	  // TODO(Binbin Zhang): Add sample rate and other setting surpport
 12210	  json::value start_tag = {{"signal", "start"},
 12211	                           {"nbest", nbest_},
 12212	                           {"continuous_decoding", continuous_decoding_}};
 12213	  std::string start_message = json::serialize(start_tag);
 12214	  this->SendTextData(start_message);
 12215	}
 12216	
 12217	void WebSocketClient::SendEndSignal() {
 12218	  json::value end_tag = {{"signal", "end"}};
 12219	  std::string end_message = json::serialize(end_tag);
 12220	  this->SendTextData(end_message);
 12221	}
 12222	
 12223	}  // namespace com.demo.wenet
 12224	// Copyright (c) 2020 Mobvoi Inc (Binbin Zhang)
 12225	//
 12226	// Licensed under the Apache License, Version 2.0 (the "License");
 12227	// you may not use this file except in compliance with the License.
 12228	// You may obtain a copy of the License at
 12229	//
 12230	//   http://www.apache.org/licenses/LICENSE-2.0
 12231	//
 12232	// Unless required by applicable law or agreed to in writing, software
 12233	// distributed under the License is distributed on an "AS IS" BASIS,
 12234	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 12235	// See the License for the specific language governing permissions and
 12236	// limitations under the License.
 12237	
 12238	#include "websocket/websocket_server.h"
 12239	
 12240	#include <thread>
 12241	#include <utility>
 12242	#include <vector>
 12243	
 12244	#include "boost/json/src.hpp"
 12245	#include "utils/log.h"
 12246	
 12247	namespace wenet {
 12248	
 12249	namespace beast = boost::beast;          // from <boost/beast.hpp>
 12250	namespace http = beast::http;            // from <boost/beast/http.hpp>
 12251	namespace websocket = beast::websocket;  // from <boost/beast/websocket.hpp>
 12252	namespace asio = boost::asio;            // from <boost/asio.hpp>
 12253	using tcp = boost::asio::ip::tcp;        // from <boost/asio/ip/tcp.hpp>
 12254	namespace json = boost::json;
 12255	
 12256	ConnectionHandler::ConnectionHandler(
 12257	    tcp::socket&& socket, std::shared_ptr<FeaturePipelineConfig> feature_config,
 12258	    std::shared_ptr<DecodeOptions> decode_config,
 12259	    std::shared_ptr<DecodeResource> decode_resource)
 12260	    : ws_(std::move(socket)),
 12261	      feature_config_(std::move(feature_config)),
 12262	      decode_config_(std::move(decode_config)),
 12263	      decode_resource_(std::move(decode_resource)) {}
 12264	
 12265	void ConnectionHandler::OnSpeechStart() {
 12266	  LOG(INFO) << "Recieved speech start signal, start reading speech";
 12267	  got_start_tag_ = true;
 12268	  json::value rv = {{"status", "ok"}, {"type", "server_ready"}};
 12269	  ws_.text(true);
 12270	  ws_.write(asio::buffer(json::serialize(rv)));
 12271	  feature_pipeline_ = std::make_shared<FeaturePipeline>(*feature_config_);
 12272	  decoder_ = std::make_shared<TorchAsrDecoder>(
 12273	      feature_pipeline_, decode_resource_, *decode_config_);
 12274	  // Start decoder thread
 12275	  decode_thread_ =
 12276	      std::make_shared<std::thread>(&ConnectionHandler::DecodeThreadFunc, this);
 12277	}
 12278	
 12279	void ConnectionHandler::OnSpeechEnd() {
 12280	  LOG(INFO) << "Recieved speech end signal";
 12281	  CHECK(feature_pipeline_ != nullptr);
 12282	  feature_pipeline_->set_input_finished();
 12283	  got_end_tag_ = true;
 12284	}
 12285	
 12286	void ConnectionHandler::OnPartialResult(const std::string& result) {
 12287	  LOG(INFO) << "Partial result: " << result;
 12288	  json::value rv = {
 12289	      {"status", "ok"}, {"type", "partial_result"}, {"nbest", result}};
 12290	  ws_.text(true);
 12291	  ws_.write(asio::buffer(json::serialize(rv)));
 12292	}
 12293	
 12294	void ConnectionHandler::OnFinalResult(const std::string& result) {
 12295	  LOG(INFO) << "Final result: " << result;
 12296	  json::value rv = {
 12297	      {"status", "ok"}, {"type", "final_result"}, {"nbest", result}};
 12298	  ws_.text(true);
 12299	  ws_.write(asio::buffer(json::serialize(rv)));
 12300	}
 12301	
 12302	void ConnectionHandler::OnFinish() {
 12303	  // Send finish tag
 12304	  json::value rv = {{"status", "ok"}, {"type", "speech_end"}};
 12305	  ws_.text(true);
 12306	  ws_.write(asio::buffer(json::serialize(rv)));
 12307	}
 12308	
 12309	void ConnectionHandler::OnSpeechData(const beast::flat_buffer& buffer) {
 12310	  // Read binary PCM data
 12311	  int num_samples = buffer.size() / sizeof(int16_t);
 12312	  std::vector<float> pcm_data(num_samples);
 12313	  const int16_t* pdata = static_cast<const int16_t*>(buffer.data().data());
 12314	  for (int i = 0; i < num_samples; i++) {
 12315	    pcm_data[i] = static_cast<float>(*pdata);
 12316	    pdata++;
 12317	  }
 12318	  VLOG(2) << "Recieved " << num_samples << " samples";
 12319	  CHECK(feature_pipeline_ != nullptr);
 12320	  CHECK(decoder_ != nullptr);
 12321	  feature_pipeline_->AcceptWaveform(pcm_data);
 12322	}
 12323	
 12324	std::string ConnectionHandler::SerializeResult(bool finish) {
 12325	  json::array nbest;
 12326	  for (const DecodeResult& path : decoder_->result()) {
 12327	    json::object jpath({{"sentence", path.sentence}});
 12328	    if (finish) {
 12329	      json::array word_pieces;
 12330	      for (const WordPiece& word_piece : path.word_pieces) {
 12331	        json::object jword_piece({{"word", word_piece.word},
 12332	                                  {"start", word_piece.start},
 12333	                                  {"end", word_piece.end}});
 12334	        word_pieces.emplace_back(jword_piece);
 12335	      }
 12336	      jpath.emplace("word_pieces", word_pieces);
 12337	    }
 12338	    nbest.emplace_back(jpath);
 12339	
 12340	    if (nbest.size() == nbest_) {
 12341	      break;
 12342	    }
 12343	  }
 12344	  return json::serialize(nbest);
 12345	}
 12346	
 12347	void ConnectionHandler::DecodeThreadFunc() {
 12348	  try {
 12349	    while (true) {
 12350	      DecodeState state = decoder_->Decode();
 12351	      if (state == DecodeState::kEndFeats) {
 12352	        decoder_->Rescoring();
 12353	        std::string result = SerializeResult(true);
 12354	        OnFinalResult(result);
 12355	        OnFinish();
 12356	        stop_recognition_ = true;
 12357	        break;
 12358	      } else if (state == DecodeState::kEndpoint) {
 12359	        decoder_->Rescoring();
 12360	        std::string result = SerializeResult(true);
 12361	        OnFinalResult(result);
 12362	        // If it's not continuous decoidng, continue to do next recognition
 12363	        // otherwise stop the recognition
 12364	        if (continuous_decoding_) {
 12365	          decoder_->ResetContinuousDecoding();
 12366	        } else {
 12367	          OnFinish();
 12368	          stop_recognition_ = true;
 12369	          break;
 12370	        }
 12371	      } else {
 12372	        if (decoder_->DecodedSomething()) {
 12373	          std::string result = SerializeResult(false);
 12374	          OnPartialResult(result);
 12375	        }
 12376	      }
 12377	    }
 12378	  } catch (std::exception const& e) {
 12379	    LOG(ERROR) << e.what();
 12380	  }
 12381	}
 12382	
 12383	void ConnectionHandler::OnError(const std::string& message) {
 12384	  json::value rv = {{"status", "failed"}, {"message", message}};
 12385	  ws_.text(true);
 12386	  ws_.write(asio::buffer(json::serialize(rv)));
 12387	  // Close websocket
 12388	  ws_.close(websocket::close_code::normal);
 12389	}
 12390	
 12391	void ConnectionHandler::OnText(const std::string& message) {
 12392	  json::value v = json::parse(message);
 12393	  if (v.is_object()) {
 12394	    json::object obj = v.get_object();
 12395	    if (obj.find("signal") != obj.end()) {
 12396	      json::string signal = obj["signal"].as_string();
 12397	      if (signal == "start") {
 12398	        if (obj.find("nbest") != obj.end()) {
 12399	          if (obj["nbest"].is_int64()) {
 12400	            nbest_ = obj["nbest"].as_int64();
 12401	          } else {
 12402	            OnError("integer is expected for nbest option");
 12403	          }
 12404	        }
 12405	        if (obj.find("continuous_decoding") != obj.end()) {
 12406	          if (obj["continuous_decoding"].is_bool()) {
 12407	            continuous_decoding_ = obj["continuous_decoding"].as_bool();
 12408	          } else {
 12409	            OnError(
 12410	                "boolean true or false is expected for "
 12411	                "continuous_decoding option");
 12412	          }
 12413	        }
 12414	        OnSpeechStart();
 12415	      } else if (signal == "end") {
 12416	        OnSpeechEnd();
 12417	      } else {
 12418	        OnError("Unexpected signal type");
 12419	      }
 12420	    } else {
 12421	      OnError("Wrong message header");
 12422	    }
 12423	  } else {
 12424	    OnError("Wrong protocol");
 12425	  }
 12426	}
 12427	
 12428	void ConnectionHandler::operator()() {
 12429	  try {
 12430	    // Accept the websocket handshake
 12431	    ws_.accept();
 12432	    for (;;) {
 12433	      // This buffer will hold the incoming message
 12434	      beast::flat_buffer buffer;
 12435	      // Read a message
 12436	      ws_.read(buffer);
 12437	      if (ws_.got_text()) {
 12438	        std::string message = beast::buffers_to_string(buffer.data());
 12439	        LOG(INFO) << message;
 12440	        OnText(message);
 12441	        if (got_end_tag_) {
 12442	          break;
 12443	        }
 12444	      } else {
 12445	        if (!got_start_tag_) {
 12446	          OnError("Start signal is expected before binary data");
 12447	        } else {
 12448	          if (stop_recognition_) {
 12449	            break;
 12450	          }
 12451	          OnSpeechData(buffer);
 12452	        }
 12453	      }
 12454	    }
 12455	
 12456	    LOG(INFO) << "Read all pcm data, wait for decoding thread";
 12457	    if (decode_thread_ != nullptr) {
 12458	      decode_thread_->join();
 12459	    }
 12460	  } catch (beast::system_error const& se) {
 12461	    // This indicates that the session was closed
 12462	    if (se.code() != websocket::error::closed) {
 12463	      if (decode_thread_ != nullptr) {
 12464	        decode_thread_->join();
 12465	      }
 12466	      OnSpeechEnd();
 12467	      LOG(ERROR) << se.code().message();
 12468	    }
 12469	  } catch (std::exception const& e) {
 12470	    LOG(ERROR) << e.what();
 12471	  }
 12472	}
 12473	
 12474	void WebSocketServer::Start() {
 12475	  try {
 12476	    auto const address = asio::ip::make_address("0.0.0.0");
 12477	    tcp::acceptor acceptor{ioc_, {address, static_cast<uint16_t>(port_)}};
 12478	    for (;;) {
 12479	      // This will receive the new connection
 12480	      tcp::socket socket{ioc_};
 12481	      // Block until we get a connection
 12482	      acceptor.accept(socket);
 12483	      // Launch the session, transferring ownership of the socket
 12484	      ConnectionHandler handler(std::move(socket), feature_config_,
 12485	                                decode_config_, decode_resource_);
 12486	      std::thread t(std::move(handler));
 12487	      t.detach();
 12488	    }
 12489	  } catch (const std::exception& e) {
 12490	    LOG(FATAL) << e.what();
 12491	  }
 12492	}
 12493	
 12494	}  // namespace com.demo.wenet
 12495	// Copyright (c) 2021 Mobvoi Inc (authors: Xiaoyu Chen)
 12496	//
 12497	// Licensed under the Apache License, Version 2.0 (the "License");
 12498	// you may not use this file except in compliance with the License.
 12499	// You may obtain a copy of the License at
 12500	//
 12501	//   http://www.apache.org/licenses/LICENSE-2.0
 12502	//
 12503	// Unless required by applicable law or agreed to in writing, software
 12504	// distributed under the License is distributed on an "AS IS" BASIS,
 12505	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 12506	// See the License for the specific language governing permissions and
 12507	// limitations under the License.
 12508	#include <jni.h>
 12509	
 12510	#include "torch/script.h"
 12511	#include "torch/torch.h"
 12512	
 12513	#include "decoder/torch_asr_decoder.h"
 12514	#include "decoder/torch_asr_model.h"
 12515	#include "frontend/feature_pipeline.h"
 12516	#include "frontend/wav.h"
 12517	#include "post_processor/post_processor.h"
 12518	#include "utils/log.h"
 12519	#include "utils/string.h"
 12520	#include "queue"
 12521	
 12522	namespace wenet {
 12523	
 12524	std::shared_ptr<DecodeOptions> decode_config;
 12525	std::shared_ptr<FeaturePipelineConfig> feature_config;
 12526	std::shared_ptr<FeaturePipeline> feature_pipeline;
 12527	std::shared_ptr<TorchAsrDecoder> decoder;
 12528	std::shared_ptr<DecodeResource> resource;
 12529	DecodeState state = kEndBatch;
 12530	std::string total_result;  // NOLINT
 12531	std::queue<std::string> results;
 12532	std::string current_string;
 12533	
 12534	void init(JNIEnv *env, jobject, jstring jModelPath, jstring jDictPath) {
 12535	  resource = std::make_shared<DecodeResource>();
 12536	  resource->model = std::make_shared<TorchAsrModel>();
 12537	  const char *pModelPath = (env)->GetStringUTFChars(jModelPath, nullptr);
 12538	  std::string modelPath = std::string(pModelPath);
 12539	//  LOG(INFO) << "model path: " << modelPath;
 12540	  resource->model->Read(modelPath);
 12541	
 12542	  const char *pDictPath = (env)->GetStringUTFChars(jDictPath, nullptr);
 12543	  std::string dictPath = std::string(pDictPath);
 12544	//  LOG(INFO) << "dict path: " << dictPath;
 12545	  resource->symbol_table = std::shared_ptr<fst::SymbolTable>(
 12546	          fst::SymbolTable::ReadText(dictPath));
 12547	
 12548	
 12549	  //TODO add context_path  参看 wenet::InitDecodeResourceFromFlags()
 12550	  // decoder/params.h
 12551	
 12552	
 12553	  PostProcessOptions post_process_opts;
 12554	  resource->post_processor =
 12555	    std::make_shared<PostProcessor>(std::move(post_process_opts));
 12556	
 12557	  feature_config = std::make_shared<FeaturePipelineConfig>(80, 16000);
 12558	  feature_pipeline = std::make_shared<FeaturePipeline>(*feature_config);
 12559	
 12560	  decode_config = std::make_shared<DecodeOptions>();
 12561	  decode_config->chunk_size = 16;
 12562	
 12563	  decoder = std::make_shared<TorchAsrDecoder>(feature_pipeline, resource,
 12564	                                              *decode_config);
 12565	
 12566	  state = kEndFeats;
 12567	}
 12568	
 12569	void reset(JNIEnv *env, jobject) {
 12570	//  LOG(INFO) << "wenet reset";
 12571	  decoder->Reset();
 12572	  state = kEndBatch;
 12573	  total_result = "";
 12574	}
 12575	
 12576	void accept_waveform(JNIEnv *env, jobject, jshortArray jWaveform) {
 12577	  jsize size = env->GetArrayLength(jWaveform);
 12578	  std::vector<int16_t> waveform(size);
 12579	  env->GetShortArrayRegion(jWaveform, 0, size, &waveform[0]);
 12580	  std::vector<float> floatWaveform(waveform.begin(), waveform.end());
 12581	  feature_pipeline->AcceptWaveform(floatWaveform);
 12582	//  LOG(INFO) << "com.demo.wenet accept waveform in ms: "
 12583	//            << int(floatWaveform.size() / 16);
 12584	}
 12585	
 12586	void set_input_finished() {
 12587	//  LOG(INFO) << "wenet input finished";
 12588	  feature_pipeline->set_input_finished();
 12589	}
 12590	
 12591	void decode_thread_func() {
 12592	  while (true) {
 12593	    state = decoder->Decode();
 12594	    if (state == kEndFeats || state == kEndpoint) {
 12595	      decoder->Rescoring();
 12596	    }
 12597	
 12598	    std::string result;
 12599	    if (decoder->DecodedSomething()) {
 12600	      result = decoder->result()[0].sentence;
 12601	    }
 12602	
 12603	    if (state == kEndFeats) {
 12604	//      LOG(INFO) << "wenet endfeats final result: " << result;
 12605	      total_result += result;
 12606	      break;
 12607	    } else if (state == kEndpoint) {
 12608	//      LOG(INFO) << "wenet endpoint final result: " << result;
 12609	      if (!result.empty()) {
 12610	        results.push(result+" ");
 12611	      }
 12612	      total_result += result + ",";
 12613	      decoder->ResetContinuousDecoding();
 12614	    } else {
 12615	      if (decoder->DecodedSomething()) {
 12616	//        LOG(INFO) << "wenet partial result: " << result;
 12617	      }
 12618	    }
 12619	  }
 12620	}
 12621	
 12622	void start_decode() {
 12623	  std::thread decode_thread(decode_thread_func);
 12624	  decode_thread.detach();
 12625	}
 12626	
 12627	jboolean get_finished(JNIEnv *env, jobject) {
 12628	  if (state == kEndFeats) {
 12629	//    LOG(INFO) << "wenet recognize finished";
 12630	    return JNI_TRUE;
 12631	  }
 12632	  return JNI_FALSE;
 12633	}
 12634	
 12635	// 返回模型是否初始化
 12636	jboolean get_inited(JNIEnv *env, jobject) {
 12637	  return decoder == nullptr ? JNI_FALSE : JNI_TRUE;
 12638	}
 12639	
 12640	
 12641	// 更改以获取段句
 12642	jstring get_result(JNIEnv *env, jobject) {
 12643	  std::string result = decoder->DecodedSomething() ? decoder->result()[0].sentence : "";
 12644	  if (!results.empty()) {
 12645	    result = results.front();
 12646	    results.pop();
 12647	  }
 12648	
 12649	  return env->NewStringUTF(result.c_str());
 12650	}
 12651	}  // namespace wenet
 12652	
 12653	JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *) {
 12654	  JNIEnv *env;
 12655	  if (vm->GetEnv(reinterpret_cast<void **>(&env), JNI_VERSION_1_6) != JNI_OK) {
 12656	    return JNI_ERR;
 12657	  }
 12658	
 12659	  jclass c = env->FindClass("com/mobvoi/wenet/Recognize");
 12660	  if (c == nullptr) {
 12661	    return JNI_ERR;
 12662	  }
 12663	
 12664	  static const JNINativeMethod methods[] = {
 12665	    {"init", "(Ljava/lang/String;Ljava/lang/String;)V",
 12666	     reinterpret_cast<void *>(wenet::init)},
 12667	    {"reset", "()V",
 12668	     reinterpret_cast<void *>(wenet::reset)},
 12669	    {"acceptWaveform", "([S)V",
 12670	     reinterpret_cast<void *>(wenet::accept_waveform)},
 12671	    {"setInputFinished", "()V",
 12672	     reinterpret_cast<void *>(wenet::set_input_finished)},
 12673	    {"getFinished", "()Z",
 12674	     reinterpret_cast<void *>(wenet::get_finished)},
 12675	     {"getInit", "()Z",
 12676	      reinterpret_cast<void *>(wenet::get_inited)},
 12677	    {"startDecode", "()V",
 12678	     reinterpret_cast<void *>(wenet::start_decode)},
 12679	    {"getResult", "()Ljava/lang/String;",
 12680	     reinterpret_cast<void *>(wenet::get_result)},
 12681	  };
 12682	  int rc = env->RegisterNatives(c, methods,
 12683	                                sizeof(methods) / sizeof(JNINativeMethod));
 12684	
 12685	  if (rc != JNI_OK) {
 12686	    return rc;
 12687	  }
 12688	
 12689	  return JNI_VERSION_1_6;
 12690	}
 12691	
